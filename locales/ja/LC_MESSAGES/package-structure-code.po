# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, pyOpenSci
# This file is distributed under the same license as the pyOpenSci Python
# Package Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pyOpenSci Python Package Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-17 22:50+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../package-structure-code/code-style-linting-format.md:1
msgid "Python Package Code Style, Format and Linters"
msgstr "Pythonパッケージコードのスタイル、フォーマット、リンター"

#: ../../package-structure-code/code-style-linting-format.md:3
#: ../../package-structure-code/publish-python-package-pypi-conda.md:12
msgid "Take Aways"
msgstr "ポイント"

#: ../../package-structure-code/code-style-linting-format.md:5
msgid "pyOpenSci requires authors to follow PEP 8 code format guidelines"
msgstr "pyOpenSciは、作者がPEP 8コードフォーマットガイドラインに従うことを要求します。"

#: ../../package-structure-code/code-style-linting-format.md:6
msgid ""
"Setting up a code formatters like Black and isort will help you enforce "
"PEP 8 style guidelines and also consistent, readable code format"
msgstr ""
"Blackやisortのようなコードフォーマッタを設定することで、PEP "
"8のスタイルガイドラインを実施し、一貫性のある読みやすいコードフォーマットにすることができます。"

#: ../../package-structure-code/code-style-linting-format.md:7
msgid "Some commonly used tools are: Black, Isort, flake8, Ruff"
msgstr "よく使われるツールは以下の通り： Black、Isort、flake8、Ruff"

#: ../../package-structure-code/code-style-linting-format.md:8
msgid ""
"You can also setup pre-commit hooks which will run code formatters "
"locally each time you make a commit."
msgstr "また、コミット前にフックをセットアップして、コミットするたびにコードフォーマッタをローカルで実行することもできます。"

#: ../../package-structure-code/code-style-linting-format.md:10
msgid ""
"[precommit.ci](https://pre-commit.ci/) is a bot that you can add to your "
"GitHub repository. It will automagically apply code format to every PR "
"using the tools specified in your pre-commit-config.yaml file. It can "
"save significant time and make contributions easier for new contributors."
msgstr ""
"[precommit.ci](https://pre-commit.ci/) は、GitHub リポジトリに追加できるボットです。 pre-"
"commit-config.yaml ファイルで指定したツールを使って、すべての PR にコードフォーマットを自動的に適用します。 "
"時間を大幅に節約することができ、新しい貢献者にとっても貢献が簡単になります。"

#: ../../package-structure-code/code-style-linting-format.md:11
msgid ""
"Automation is good! By making code quality tools care of your code, you "
"can focus on structural and high values tasks."
msgstr "自動化は良いことです! コードクオリティツールにコードを管理させることで、あなたは構造的で価値の高いタスクに集中することができます。"

#: ../../package-structure-code/code-style-linting-format.md:14
msgid ""
"Consistent code format and style is useful to both your package and "
"across the scientific Python ecosystem because using similar formats "
"makes code easier to read."
msgstr "一貫したコードフォーマットとスタイルは、あなたのパッケージにとっても、科学的なPythonエコシステム全体にとっても有用です、なぜなら、同じようなフォーマットを使うことでコードが読みやすくなるからです。"

#: ../../package-structure-code/code-style-linting-format.md:18
msgid ""
"For instance, if you saw a sentence like this one without any spaces, or "
"punctuation, it would take your brain longer to process it."
msgstr "例えば、空白や句読点のないこのような文章を見た場合、脳がそれを処理するのに時間がかかるだろう。"

#: ../../package-structure-code/code-style-linting-format.md:25
msgid ""
"pyOpenSci peer review process requires that you to follow standard "
"[Python PEP 8 format rules](https://peps.python.org/pep-0008/) as closely"
" as you can."
msgstr ""
"pyOpenSciの査読プロセスでは、標準的な [Python PEP 8 format "
"rules](https://peps.python.org/pep-0008/) にできるだけ忠実に従うことが求められます。"

#: ../../package-structure-code/code-style-linting-format.md:29
msgid ""
"pyOpenSci doesn't require you to use a specific code format tool. "
"However, we do look for consistency and readability in code style. Below "
"you will find a discussion of:"
msgstr ""
"pyOpenSciは特定のコードフォーマットツールを使うことを要求しません。 しかし、コードスタイルに一貫性と読みやすさを求めています。 "
"以下は、その考察です:"

#: ../../package-structure-code/code-style-linting-format.md:33
msgid "The benefits of using linters and code format tools in your workflow"
msgstr "ワークフローでリンターとコードフォーマットツールを使用するメリット"

#: ../../package-structure-code/code-style-linting-format.md:34
msgid "Some commonly used tools in the scientific Python space"
msgstr "科学的なPythonでよく使われるツール"

#: ../../package-structure-code/code-style-linting-format.md:35
msgid ""
"Setting up pre-commit hooks and the pre-commit.ci bot to make using code "
"format tools in daily workflows and in pull requests on GitHub easier."
msgstr ""
"pre-commitフックとpre-"
"commit.ciボットを設定することで、日々のワークフローやGitHubのプルリクエストでコードフォーマットツールを簡単に使えるようになります。"

#: ../../package-structure-code/code-style-linting-format.md:38
msgid "Use a code format tool (or tools) to make your life easier"
msgstr "コードフォーマットツール (または複数のツール) を使って生活を楽にします"

#: ../../package-structure-code/code-style-linting-format.md:40
msgid ""
"We suggest that you use a code format tool, or a set of format tools, "
"because manually applying all of the PEP 8 format specifications is both "
"time consuming for maintainers and can be a road block for potential new "
"contributors. Code formatters will automagically reformat your code for "
"you, adhering to PEP 8 standards and applying consistent style decisions "
"throughout."
msgstr ""
"コードフォーマットツール、あるいはフォーマットツールのセットを使うことをお勧めします。PEP 8 "
"のフォーマット仕様をすべて手作業で適用するのは、メンテナにとって時間がかかるだけでなく、潜在的な新規貢献者にとっては障害になりかねないからです。 "
"コードフォーマッタはあなたのコードを自動的に再フォーマットし、PEP 8の標準を遵守し、一貫したスタイル決定を適用します。"

#: ../../package-structure-code/code-style-linting-format.md:46
msgid "Setting up a code format suite of tools will:"
msgstr "コードフォーマット一式のツールを設定します:"

#: ../../package-structure-code/code-style-linting-format.md:48
msgid "Save you and your maintainer team time in fixing PEP 8 inconsistencies."
msgstr "PEP 8の不整合を修正する時間を、あなたとあなたのメンテナチームに節約させます。"

#: ../../package-structure-code/code-style-linting-format.md:49
msgid "Ensure that format and style is consistent across your entire code-base."
msgstr "フォーマットとスタイルがコードベース全体で一貫していることを確認します。"

#: ../../package-structure-code/code-style-linting-format.md:50
msgid ""
"Avoid lengthy discussions with contributors and other maintainers about "
"personalized code format preferences during reviews."
msgstr "レビューの際に、貢献者や他のメンテナと、個人的なコード形式の好みについて長々と議論するのは避けましょう。"

#: ../../package-structure-code/code-style-linting-format.md:52
msgid ""
"Avoid pure visual edits in the code base so that code reviews focus on "
"added value"
msgstr "コードレビューが付加価値に焦点を当てるように、コードベースにおける純粋な視覚的編集を避けます。"

#: ../../package-structure-code/code-style-linting-format.md:54
msgid ""
"Many packages use a suite of tools to apply code format rules, taking the"
" work out of manually implementing code format requirements."
msgstr "多くのパッケージは、コードフォーマット規則を適用するために一連のツールを使用しており、手作業でコードフォーマット要件を実装する手間を省いています。"

#: ../../package-structure-code/code-style-linting-format.md:57
msgid ""
"Consistent code format across packages within the (scientific) Python "
"ecosystem, will also broadly make code easier to scan, understand and "
"contribute to."
msgstr "（科学的な）Pythonエコシステム内のパッケージ間で統一されたコードフォーマットは、広くコードをスキャンし、理解し、貢献することを容易にします。"

#: ../../package-structure-code/code-style-linting-format.md:60
msgid "Linting vs format and style"
msgstr "リンティング vs フォーマットとスタイル"

#: ../../package-structure-code/code-style-linting-format.md:62
msgid "Before we dive in let's get a few definitions out of the way."
msgstr "その前に、いくつかの定義を整理しておきましょう。"

#: ../../package-structure-code/code-style-linting-format.md:64
msgid "Code Linting"
msgstr "コードリンティング"

#: ../../package-structure-code/code-style-linting-format.md:66
msgid ""
"A code linter is a tool that will review your code and identify errors or"
" issues. A linter typically does not modify your code. It will tell you "
"what the error is and on what line it was discovered. Flake8, discussed "
"below, is an example of a commonly-used code linter."
msgstr ""
"コードリンターは、コードをレビューしてエラーや問題を特定するツールです。 リンターは通常、あなたのコードを修正しません。 "
"エラーが何であり、どの行で発見されたかを教えてくれます。 後述するFlake8は、よく使われるコードリンターの一例です。"

#: ../../package-structure-code/code-style-linting-format.md:71
msgid "Code Formatters (and stylers)"
msgstr "コードフォーマッタ（およびスタイラーズ）"

#: ../../package-structure-code/code-style-linting-format.md:73
msgid ""
"Code formatters will reformat your code for you. Python focused code "
"formatters often follow PEP 8 standards. However, they also make "
"stylistic decisions about code consistency."
msgstr ""
"コードフォーマッタはあなたのコードを再フォーマットしてくれます。 Python に特化したコードフォーマッタは PEP 8 "
"標準に従うことが多いです。 しかし、コードの一貫性に関する文体的な決定も行います。"

#: ../../package-structure-code/code-style-linting-format.md:77
msgid ""
"Black is an example of a commonly-used code formatter. Black both applies"
" PEP 8 standards while also making decisions about things like consistent"
" use of double quotes for strings, and spacing of items in lists."
msgstr ""
"Blackはよく使われるコードフォーマッターの一例です。 BlackはPEP "
"8の標準を適用すると同時に、文字列に対する二重引用符の一貫した使用や、リスト内の項目のスペーシングなどについても決定しています。"

#: ../../package-structure-code/code-style-linting-format.md:81
msgid "You will learn more about Black below."
msgstr "Black については後述します。"

#: ../../package-structure-code/code-style-linting-format.md:83
msgid "Code linting, formatting and styling tools"
msgstr "コードリンティング、フォーマット、スタイリングツール"

#: ../../package-structure-code/code-style-linting-format.md:85
msgid "Black"
msgstr "Black"

#: ../../package-structure-code/code-style-linting-format.md:87
msgid ""
"[Black](https://black.readthedocs.io/en/stable/) is a code formatter. "
"Black will automagically (and _unapologetically_) fix spacing issues and "
"ensure code format is consistent throughout your package. Black also "
"generally adheres to PEP 8 style guidelines with some exceptions. A few "
"examples of those exceptions are below:"
msgstr ""
"[Black](https://black.readthedocs.io/en/stable/) はコードフォーマッタです。 "
"Blackは自動的に(そして _unapologetically_ "
"に)スペーシングの問題を修正し、コードフォーマットがパッケージ全体で一貫していることを保証します。 "
"Blackはまた、いくつかの例外を除き、一般的にPEP 8スタイルガイドラインを遵守します。 以下にその例外の例をいくつか示します:"

#: ../../package-structure-code/code-style-linting-format.md:93
msgid ""
"Black defaults to a line length of 88 (79 + 10%) rather than the 79 "
"character `PEP 8` specification. However, line length is a setting can be"
" manually overwritten in your Black configuration."
msgstr ""
"Blackのデフォルトの行の長さは、79文字の `PEP 8` 仕様ではなく、88 (79 + 10%) です。 しかし、行の長さは Black "
"の設定で手動で上書きすることができます。"

#: ../../package-structure-code/code-style-linting-format.md:94
msgid "Black will not adjust line length in your comments or docstrings."
msgstr "Blackはコメントやdocstringの行の長さを調整しません。"

#: ../../package-structure-code/code-style-linting-format.md:95
msgid ""
"This tool will not review and fix import order (you need `isort` or "
"`ruff` to do that - see below)."
msgstr ""
"このツールはインポートの順番を見直したり修正したりはしません（そのためには `isort` や `ruff` が必要です - "
"下記を参照してください）。"

#: ../../package-structure-code/code-style-linting-format.md:98
msgid ""
"If you are interested in seeing how Black will format your code, you can "
"use the [Black playground](https://black.vercel.app/)"
msgstr ""
"Black があなたのコードをどのようにフォーマットするか興味がある場合は、 [Black "
"playground](https://black.vercel.app/) を使用することができます。"

#: ../../package-structure-code/code-style-linting-format.md:102
msgid ""
"Using a code formatter like Black will leave you more time to work on "
"code function rather than worry about format."
msgstr "Blackのようなコードフォーマッターを使うことで、書式を気にするよりもコードの機能に時間を割くことができます。"

#: ../../package-structure-code/code-style-linting-format.md:105
msgid "Flake8"
msgstr "Flake8"

#: ../../package-structure-code/code-style-linting-format.md:107
msgid ""
"To adhere to Python `pep8` format standards, you might want to add "
"[flake8](https://flake8.pycqa.org/en/latest/) to your code format "
"toolbox."
msgstr ""
"Python の `pep8` "
"フォーマットの標準に準拠するために、[flake8](https://flake8.pycqa.org/en/latest/) "
"をコードフォーマットツールボックスに追加するとよいでしょう。"

#: ../../package-structure-code/code-style-linting-format.md:111
msgid "flake8 will:"
msgstr "flake8 は:"

#: ../../package-structure-code/code-style-linting-format.md:113
msgid ""
"Flag every line in your code that extends beyond 79 characters (including"
" those in docstrings and comments)"
msgstr "コード中の79文字を超えるすべての行にフラグを付ける（docstringやコメント中の行も含む）"

#: ../../package-structure-code/code-style-linting-format.md:114
msgid ""
"Flag spacing issues that conflict with PEP 8 guidelines such as missing "
"spaces after commas"
msgstr "カンマの後にスペースがないなど、PEP 8ガイドラインに抵触するフラグスペースの問題"

#: ../../package-structure-code/code-style-linting-format.md:116
msgid ""
"Flake8 also flags unused imports and unused declared variables in your "
"modules."
msgstr "Flake8はまた、モジュール内の未使用のインポートや未使用の宣言変数にフラグを立てます。"

#: ../../package-structure-code/code-style-linting-format.md:119
msgid ""
"Below you can see the output of running `flake8 filename.py` at the "
"command line for a Python file within a package called `stravalib`."
msgstr ""
"下記は `stravalib` というパッケージ内の Python ファイルに対してコマンドラインで `flake8 filename.py` "
"を実行したときの出力です。"

#: ../../package-structure-code/code-style-linting-format.md:123
msgid "The line length standard for PEP 8 is 79 characters."
msgstr "PEP 8の行の長さの標準は79文字です。"

#: ../../package-structure-code/code-style-linting-format.md:125
msgid ""
"Notice that flake8 returns a list of issues that it found in the model.py"
" module on the command line. The Python file itself is not modified. "
"Using this output, you can fix each issue line by line manually."
msgstr ""
"flake8はコマンドラインでmodel.pyモジュールで見つかった問題のリストを返すことに注意してください。 "
"Pythonファイル自体は変更されません。 この出力を使って、問題を一行ずつ手作業で修正することができます。"

#: ../../package-structure-code/code-style-linting-format.md:140
msgid "Isort"
msgstr "Isort"

#: ../../package-structure-code/code-style-linting-format.md:142
msgid ""
"Python imports refer to the Python packages that a module in your package"
" requires. Imports should always be located at the top of each Python "
"module in your package."
msgstr ""
"Python import は、あなたのパッケージのモジュールが必要とする Python パッケージを指します。 "
"importsは常にパッケージ内の各Pythonモジュールの先頭に配置されるべきです。"

#: ../../package-structure-code/code-style-linting-format.md:146
msgid ""
"[PEP 8 has specific standards for the order of these "
"imports](https://peps.python.org/pep-0008/#imports). These standards are "
"listed below:"
msgstr ""
"[PEP "
"8には、これらのimportの順序に関する具体的な基準があります](https://peps.python.org/pep-0008/#imports)"
" 。これらの基準を以下に示します:"

#: ../../package-structure-code/code-style-linting-format.md:148
msgid "Imports should be grouped in the following order:"
msgstr "import は以下の順序でグループ化します:"

#: ../../package-structure-code/code-style-linting-format.md:150
msgid "Standard library imports."
msgstr "標準ライブラリの import 。"

#: ../../package-structure-code/code-style-linting-format.md:151
msgid "Related third party imports."
msgstr "関連するサードパーティの import 。"

#: ../../package-structure-code/code-style-linting-format.md:152
msgid "Local application/library specific imports."
msgstr "ローカルアプリケーション/ライブラリ固有のインポート。"

#: ../../package-structure-code/code-style-linting-format.md:154
msgid ""
"While `flake8` will identify unused imports in your code, it won't fix or"
" identify issues with the order of package imports."
msgstr ""
"`flake8` "
"はあなたのコードで使用されていないインポートを特定しますが、パッケージのインポートの順序に関する問題を修正したり特定したりすることはできません。"

#: ../../package-structure-code/code-style-linting-format.md:157
msgid ""
"`isort` will identify where imports in your code are out of order. It "
"will then modify your code, automatically reordering all imports. This "
"leaves you with one less thing to think about when cleaning up your code."
msgstr ""
"`isort` は、コードの中でインポートの順番が狂っている箇所を特定します。 "
"そして、あなたのコードを修正し、すべてのインポートの順番を自動的に並べ替えます。 これで、コードを整理するときに考えることが1つ減ります。"

#: ../../package-structure-code/code-style-linting-format.md:162
msgid "Example application of isort"
msgstr "isort の使用例"

#: ../../package-structure-code/code-style-linting-format.md:164
msgid "Code imports before `isort` is run:"
msgstr "`isort` が実行される前にコードがインポートされます:"

#: ../../package-structure-code/code-style-linting-format.md:166
msgid ""
"Below, the `pandas` is a third party package, `typing` is a core `Python`"
" package distributed with `Python`, and `examplePy.temperature` is a "
"first-party module which means it belongs to the same package as the file"
" doing the import. Also notice that there are no spaces in the imports "
"listed below."
msgstr ""
"以下では、`pandas`はサードパーティのパッケージであり、`typing`は `Python` とともに配布されている `Python` "
"のコアパッケージであり、 "
"`examplePy.temperature`はファーストパーティモジュールで、インポートを行うファイルと同じパッケージに属していることを意味します。"
" また、以下のインポートにスペースがないことに注意してください。"

#: ../../package-structure-code/code-style-linting-format.md:176
msgid "From the project root, run:"
msgstr "プロジェクトルートから以下を実行してください:"

#: ../../package-structure-code/code-style-linting-format.md:182
msgid "Python file `temporal.py` imports after `isort` has been run"
msgstr "Python ファイル `temporal.py` は `isort` が実行された後にインポートされます。"

#: ../../package-structure-code/code-style-linting-format.md:189
msgid "Ruff"
msgstr "Ruff"

#: ../../package-structure-code/code-style-linting-format.md:191
msgid ""
"[Ruff](https://docs.astral.sh/ruff/) is a new addition to the code "
"quality ecosystem, gaining some traction since its release. `ruff` is "
"both a linter and a code formatter for Python, aiming to replace several "
"tools behind a single interface. As such, `ruff` can be used at a "
"replacement of all other tools mentioned here, or in complement to some "
"of them."
msgstr ""
"[Ruff](https://docs.astral.sh/ruff/) "
"は、コードクオリティのエコシステムに新しく追加されたもので、リリース以来人気を集めています。 `ruff` "
"はPythonのリンターであり、コード整形ツールでもあります。 そのため、 `ruff` "
"はここで紹介する他のすべてのツールの置き換えとして、あるいはいくつかのツールの補完として使用することができます。"

#: ../../package-structure-code/code-style-linting-format.md:197
msgid ""
"`ruff` has some interesting features that distinguish it from other "
"linters:"
msgstr "`ruff` には他のリンターと異なる興味深い特徴があります:"

#: ../../package-structure-code/code-style-linting-format.md:199
msgid "Linter configuration in `pyproject.toml`"
msgstr "`pyproject.toml` のリンター設定"

#: ../../package-structure-code/code-style-linting-format.md:200
msgid "Several hundred rules included, many of which are automatically fixable"
msgstr "数百のルールが含まれ、その多くは自動的に修正可能です"

#: ../../package-structure-code/code-style-linting-format.md:201
msgid ""
"Rules explanation, see [F403](https://docs.astral.sh/ruff/rules"
"/undefined-local-with-import-star/) for an example"
msgstr ""
"ルールの説明、例については [F403](https://docs.astral.sh/ruff/rules/undefined-local-"
"with-import-star/) を参照してください。"

#: ../../package-structure-code/code-style-linting-format.md:202
msgid ""
"Fast execution time, makes a quick feedback loop possible even on large "
"projects."
msgstr "実行時間が速いので、大規模プロジェクトでも素早いフィードバックループが可能。"

#: ../../package-structure-code/code-style-linting-format.md:204
msgid ""
"Here is a simple configuration to get started with `ruff`. It would go "
"into your `pyproject.toml`:"
msgstr "以下は `ruff` を使い始めるための簡単な設定です。 これは `pyproject.toml` に記述します:"

#: ../../package-structure-code/code-style-linting-format.md:212
msgid ""
"Depending on your project, you might want to add the following to sort "
"imports correctly:"
msgstr "プロジェクトによっては、インポートを正しく並べ替えるために以下を追加するとよいです:"

#: ../../package-structure-code/code-style-linting-format.md:219
msgid "How to use code formatter in your local workflow"
msgstr "ローカルワークフローでコードフォーマッタを使用する方法"

#: ../../package-structure-code/code-style-linting-format.md:221
msgid "Linters, code formatters and your favorite coding tools"
msgstr "リンター、コードフォーマッター、お気に入りのコーディングツール"

#: ../../package-structure-code/code-style-linting-format.md:223
msgid ""
"Linters can be run as a command-line tool as shown above. They also can "
"be run within your favorite coding tool (e.g. VScode, pycharm, etc). For "
"example, you might prefer to have tools like Black and isort run when you"
" save a file. In some editors you can also setup shortcuts that run your "
"favorite code format tools on demand."
msgstr ""
"リンターは上記のようにコマンドラインツールとして実行できます。 "
"また、お気に入りのコーディングツール（VScodeやpycharmなど）の中で実行することもできます。 "
"例えば、ファイルを保存するときにBlackやisortのようなツールを実行させたいかもしれません。 "
"エディタによっては、お気に入りのコード整形ツールをオンデマンドで実行するショートカットを設定することもできる。"

#: ../../package-structure-code/code-style-linting-format.md:229
msgid "Use pre-commit hooks to run code formatters and linters on commits"
msgstr "プレコミットフックを使って、コミット時にコードフォーマッタやリンタを実行"

#: ../../package-structure-code/code-style-linting-format.md:231
msgid "You can also setup a `pre-commit hook` in your Python package repository."
msgstr "Pythonのパッケージリポジトリに `pre-commit hook` をセットアップすることもできます。"

#: ../../package-structure-code/code-style-linting-format.md:233
msgid ""
"A pre-commit hook is a tool that allows an action (or actions) to be "
"triggered when you apply a commit to your git repository."
msgstr "プレコミットフックとは、git リポジトリにコミットを適用するときに (複数の) アクションを実行するためのツールです。"

#: ../../package-structure-code/code-style-linting-format.md:236
msgid "Pre-commit hook example workflow"
msgstr "pre-commit フックのワークフロー例"

#: ../../package-structure-code/code-style-linting-format.md:238
msgid "The precommit workflow looks like this: You type and run:"
msgstr "precommit のワークフローは次のようになる: 次のように入力して実行します:"

#: ../../package-structure-code/code-style-linting-format.md:241
msgid "`git commit -m \"message here\"` at the command line"
msgstr "コマンドラインで `git commit -m \"message here\"` を実行"

#: ../../package-structure-code/code-style-linting-format.md:243
msgid ""
"Once you hit return, pre-commit will run any tools that you have "
"configured in a **.pre-commit-config.yaml** file."
msgstr "returnを押すと、pre-commitは **.pre-commit-config.yaml** ファイルで設定したツールを実行します。"

#: ../../package-structure-code/code-style-linting-format.md:245
msgid ""
"If the tools configured in the pre-commit hook run successfully without "
"making changes or finding errors in your code, the commit will be applied"
" to the repository."
msgstr ""
"pre-"
"commitフックで設定したツールが、コードに変更を加えたりエラーを発見したりすることなく正常に実行されると、コミットがリポジトリに適用されます。"

#: ../../package-structure-code/code-style-linting-format.md:249
msgid ""
"If the tools configured in the hook find errors in your files, the commit"
" will NOT be applied to the repository. Remember from the discussion "
"above that a code formatter like Black will run and reformat your code. A"
" linter like _flake8_ will provide you with some output that details "
"where there are syntax issues in your code. You will then need to fix "
"those issues, manually."
msgstr ""
"フックで設定したツールがファイルにエラーを見つけた場合、コミットはリポジトリに適用されません。 上の説明で、Black "
"のようなコードフォーマッタが実行され、コードを再フォーマットすることを思い出してください。 _flake8_ "
"のようなリンターは、コードのどこにシンタックス上の問題があるかを詳細に出力してくれます。 そして、それらの問題を手動で修正する必要があります。"

#: ../../package-structure-code/code-style-linting-format.md:256
msgid ""
"Once all of the fixes are applied you can re-add (stage) the files to be "
"commit. And re-run your commit."
msgstr "すべての修正が適用されたら、コミットするファイルを再追加 (stage) することができます。 そしてコミットを再実行します。"

#: ../../package-structure-code/code-style-linting-format.md:260
msgid "Diagram showing the steps of a pre-commit workflow from left to right."
msgstr "左から右へ、 pre-commit ワークフローのステップを示す図。"

#: ../../package-structure-code/code-style-linting-format.md:262
#, fuzzy
msgid ""
"The pre-commit workflow begins with you adding files that have changes to"
" be staged in git. Next, you'd run git commit. When you run git commit, "
"the pre-commit hooks will then run. In this example, Black, the code "
"formatter and flake8, a linter both run. If all of the files pass Black "
"and flake8 checks, then your commit will be recorded. If they don't, the "
"commit is canceled. You will have to fix any flake8 issues, and then re-"
"add / stage the files to be committed. [_Image "
"Source_](https://ljvmiranda921.github.io/notebook/2018/06/21/precommits-"
"using-black-and-flake8/*)"
msgstr ""
"pre-commit のワークフローは、まず git にステージすべき変更があるファイルを追加することから始まります。 次に git commit"
" を実行します。git commit を実行すると、pre-commit フックが実行されます。 この例では、コード整形ツールである Black "
"とリンターである flake8 が実行されます。 すべてのファイルがBlackとflake8のチェックをパスすれば、コミットが記録される。 "
"通らなかった場合、コミットはキャンセルされます。 flake8の問題を修正し、コミットするファイルを再度追加/ステージする必要があります。  "
"[_Image Source_](https://ljvmiranda921.github.io/notebook/2018/06/21"
"/precommits-using-black-and-flake8/*)"

#: ../../package-structure-code/code-style-linting-format.md:275
msgid ""
"If have a Python code-base and multiple maintainers actively working on "
"the code, and you intend to run a tool like Black, be sure to coordinate "
"across your team. An initial commit that applies Black to your entire "
"package will likely change a significant amount of your code. This could "
"lead to merge conflicts on open and new PR's before the new changes are "
"merged."
msgstr ""
"Python のコードベースがあり、複数のメンテナがそのコードに積極的に取り組んでいて、Black "
"のようなツールを使うつもりなら、チーム全体で調整するようにしてください。 "
"Blackをパッケージ全体に適用する最初のコミットは、おそらくコードのかなりの部分を変更するでしょう。 "
"これは、新しい変更がマージされる前に、オープンなPRや新しいPRでマージ競合が発生する可能性があります。"

#: ../../package-structure-code/code-style-linting-format.md:282
msgid "General pre commit checks"
msgstr "一般的なコミット前のチェック"

#: ../../package-structure-code/code-style-linting-format.md:284
#, fuzzy
msgid ""
"In addition to calling tools, Pre-commit also has a suite of [built in "
"format hooks](https://github.com/pre-commit/pre-commit-hooks#hooks-"
"available) that you can call. Some, such as `trailing-whitespace` can be "
"also useful to add to your pre-commit workflow to ensure clean, "
"streamlined code files."
msgstr ""
"ツールを呼び出すだけでなく、Pre-commitには [ビルトインフォーマットフック](https://github.com/pre-commit"
"/pre-commit-hooks#hooks-available) が用意されています。また、trailing-"
"whitespaceのように、コミット前のワークフローに追加することで、クリーンで合理的なコードファイルを確保できるものもあります。"

#: ../../package-structure-code/code-style-linting-format.md:289
msgid ""
"An example pre-commit-config.yaml file is below with examples of how this"
" is all setup."
msgstr ""
"以下に、 pre-commit-config.yaml "
"ファイルの例を記載します。このファイルに記載されている内容のセットアップ方法の例も記載されています。"

#: ../../package-structure-code/code-style-linting-format.md:292
msgid "Pre-commit.ci"
msgstr "pre-commit.ci"

#: ../../package-structure-code/code-style-linting-format.md:294
msgid ""
"[Pre-commit.ci](https://pre-commit.ci) is a bot that may become your new "
"best friend. This bot, when setup on a repo can be configured to do the "
"following:"
msgstr ""
"[pre-commit.ci](https://pre-commit.ci) は、あなたの新しい親友になるかもしれないボットです。 "
"このボットをリポジトリにセットアップすると、次のようなことができるようになります:"

#: ../../package-structure-code/code-style-linting-format.md:297
msgid "It will check every pull request using all of the pre-commit hook setting"
msgstr "コミット前のフック設定をすべて使用して、すべてのプルリクエストをチェックします"

#: ../../package-structure-code/code-style-linting-format.md:298
msgid ""
"If you wish, it will also submit a pull request to your repo with pre-"
"commit fixes, saving you, and new contributors the time of reformatting a"
" pr that has format issues."
msgstr ""
"あなたが望むなら、事前にコミットした修正と一緒にあなたのリポジトリにプルリクエストを提出します、あなたや新しい貢献者は、フォーマットの問題がある "
"pr を再フォーマットする時間を節約できます。"

#: ../../package-structure-code/code-style-linting-format.md:301
msgid "You can also call the bot on any pull request to run / and fix the code."
msgstr "また、どのプルリクエストでもボットを呼び出して、実行し / コードを修正することができます。"

#: ../../package-structure-code/code-style-linting-format.md:303
msgid ""
"The pre-commit.ci bot uses the same pre-commit-config.yaml file that you "
"use to setup pre-commit locally."
msgstr ""
"pre-commit.ci ボットは、ローカルで pre-commit をセットアップするのと同じ pre-commit-config.yaml "
"ファイルを使用します。"

#: ../../package-structure-code/code-style-linting-format.md:306
msgid "Setting up a bot like this can be valuable because:"
msgstr "このようなボットを設置することは価値があるなぜなら:"

#: ../../package-structure-code/code-style-linting-format.md:308
msgid ""
"It can make is easier for maintainers as they no longer have to worry at "
"allows about fixing code format. The bot will do the work for them."
msgstr "メンテナにとっては、コードフォーマットの修正に頭を悩ませる必要がなくなり、楽になります。 ボットが代わりにやってくれます。"

#: ../../package-structure-code/code-style-linting-format.md:310
msgid ""
"It can make it easier for new comers as they never have to setup pre-"
"commit locally or worry about linting their code. They can even make "
"small fixes to the code directly on GitHub without worry."
msgstr ""
"ローカルでpre-"
"commitをセットアップしたり、コードのlintを心配したりする必要がないので、新規参入者も楽になります。GitHub上で直接コードを修正することもできます。"

#: ../../package-structure-code/code-style-linting-format.md:312
msgid "Setting up a git pre-commit hook"
msgstr "git pre-commit フックの設定"

#: ../../package-structure-code/code-style-linting-format.md:314
msgid "To setup pre-commit locally, you need to do 3 things:"
msgstr "ローカルで pre-commit をセットアップするには、3つのことをする必要があります:"

#: ../../package-structure-code/code-style-linting-format.md:316
msgid ""
"Install pre-commit (and include it as a development requirement in your "
"repository)"
msgstr "pre-commitをインストールする（そしてリポジトリに開発要件として含める）"

#: ../../package-structure-code/code-style-linting-format.md:326
msgid ""
"Create a .pre-commit-config.yaml file in the root of your package "
"directory."
msgstr "パッケージディレクトリのルートに .pre-commit-config.yaml ファイルを作成します。"

#: ../../package-structure-code/code-style-linting-format.md:328
msgid ""
"Below is an example **.pre-commit-cofig.yaml** file that can be used to "
"setup the pre-commit hook and the pre-commit.ci bot if you chose to "
"implement that too."
msgstr ""
"以下は、 pre-commit とpre-commit.ciボットのセットアップに使用できる **.pre-commit-cofig.yaml**"
" ファイルの例です。"

#: ../../package-structure-code/code-style-linting-format.md:336
msgid ""
"This file specifies a hook that will be triggered automatically before "
"each `git commit`, in this case, it specifies a `flake8` using version "
"`6.0.0`."
msgstr ""
"このファイルでは、各 `git commit` の前に自動的に起動するフックを指定します。この例では、バージョン `6.0.0` を使って "
"`flake8` を指定しています。"

#: ../../package-structure-code/code-style-linting-format.md:339
msgid ""
"Install your pre-commit hook(s) using `pre-commit install`. This will "
"install all of the hooks specified in the pre-commit yaml file into your "
"environment."
msgstr ""
"`pre-commit install` を使用して、(複数の)コミット前フックをインストールします。 これにより、pre-commit yaml"
" ファイルで指定したすべてのフックがあなたの環境にインストールされます。"

#: ../../package-structure-code/code-style-linting-format.md:341
msgid ""
"Once you have done the above, you are ready to start working on your "
"code. Pre-commit will run every time you run `git commit`."
msgstr "上記を実行したら、コードを書き始める準備ができました。 `git commit` を実行するたびに pre-commit が実行されます。"

#: ../../package-structure-code/code-style-linting-format.md:344
msgid "Summary"
msgstr "概要"

#: ../../package-structure-code/code-style-linting-format.md:346
msgid ""
"pyOpenSci suggests setting up a linter and a code styler for your "
"package, regardless of whether you use pre-commit hooks, CI or other "
"infrastructure to manage code format. Setting up these tools will give "
"you automatic feedback about your code's structure as you (or a "
"contributor) write it. And using a tool like black that format code for "
"you, reduce effort that you need to make surrounding decisions around "
"code format and style."
msgstr ""
"pyOpenSciは、プレコミットフック、CI、またはコードフォーマットを管理する他のインフラストラクチャを使用しているかどうかに関係なく、あなたのパッケージにリンターとコードスタイラーをセットアップすることを提案します。"
" "
"これらのツールをセットアップすることで、あなた(または貢献者)がコードを書いたときに、コードの構造に関する自動的なフィードバックを得ることができます。"
" "
"また、コードを整形してくれるblackのようなツールを使うことで、コードのフォーマットやスタイルにまつわる決断に必要な労力を減らすことができます。"

#: ../../package-structure-code/complex-python-package-builds.md:1
msgid "Complex Python package builds"
msgstr "複雑なPythonパッケージのビルド"

#: ../../package-structure-code/complex-python-package-builds.md:3
msgid ""
"This guide is focused on packages that are either pure-python or that "
"have a few simple extensions in another language such as C or C++."
msgstr "このガイドでは、純粋なPythonか、CやC++のような他の言語でいくつかの簡単な拡張を持つパッケージのどちらかに焦点を当てています。"

#: ../../package-structure-code/complex-python-package-builds.md:6
msgid ""
"In the future, we want to provide resources for packaging workflows that "
"require more complex builds. If you have questions about these types of "
"package, please [add a question to our "
"discourse](https://pyopensci.discourse.group/) or open an [issue about "
"this guide specifically in the GitHub repo for this "
"guide](https://github.com/pyOpenSci/python-package-guide/issues). There "
"are many nuances to building and distributing Python packages that have "
"compiled extensions requiring non-Python dependencies at build time. For "
"an overview and thorough discussion of these nuances, please see [this "
"site.](https://pypackaging-native.github.io/)"
msgstr ""
"将来的には、より複雑なビルドを必要とするパッケージングワークフローのためのリソースを提供したいと考えています。 "
"このようなタイプのパッケージについて質問がある場合は、 "
"[私たちのdiscourseに質問を追加する](https://pyopensci.discourse.group/) か、 [このガイドの "
"GitHub リポジトリでこのガイドに関する issue を発行する](https://github.com/pyOpenSci/python-"
"package-guide/issues) してください。 ビルド時に Python 以外の依存関係を必要とするコンパイルされた拡張機能を持つ "
"Python パッケージをビルドして配布するには、多くの微妙な違いがあります。 これらの微妙な違いの概要と徹底的な議論については、 "
"[このサイト](https://pypackaging-native.github.io/) を参照してください。"

#: ../../package-structure-code/complex-python-package-builds.md:8
msgid "Pure Python Packages vs. packages with extensions in other languages"
msgstr "純粋なPythonパッケージと他言語の拡張機能付きパッケージの比較"

#: ../../package-structure-code/complex-python-package-builds.md:10
msgid ""
"You can classify Python package complexity into three general categories."
" These categories can in turn help you select the correct package "
"frontend and backend tools."
msgstr ""
"Pythonパッケージの複雑さを3つの一般的なカテゴリに分類することができます。 "
"これらの分類は、正しいパッケージフロントエンドとバックエンドツールを選択するのに役立ちます。"

#: ../../package-structure-code/complex-python-package-builds.md:14
msgid ""
"**Pure-python packages:** these are packages that only rely on Python to "
"function. Building a pure Python package is simpler. As such, you can "
"chose a tool below that has the features that you want and be done with "
"your decision!"
msgstr ""
"**純粋なPythonパッケージ:** Pythonだけに依存して機能するパッケージです。 純粋なPythonパッケージの構築はよりシンプルです。"
" そのため、以下のツールの中から自分の欲しい機能を持つものを選び、決定しましょう!"

#: ../../package-structure-code/complex-python-package-builds.md:16
msgid ""
"**Python packages with non-Python extensions:** These packages have "
"additional components called extensions written in other languages (such "
"as C or C++). If you have a package with non-Python extensions, then you "
"need to select a build backend tool that allows additional build steps "
"needed to compile your extension code. Further, if you wish to use a "
"frontend tool to support your workflow, you will need to select a tool "
"that supports additional build setups. We suggest that you chose build "
"tool that supports custom build steps like Hatch."
msgstr ""
"**Python以外の拡張を持つPythonパッケージ:** これらのパッケージには、他の言語(CやC++など)で書かれた拡張と呼ばれる "
"追加コンポーネントがあります。 Python "
"以外の拡張を持つパッケージがある場合、拡張コードをコンパイルするために必要な、追加のビルドステップを可能にするビルドバックエンドツールを選択する必要があります。"
" さらに、ワークフローをサポートするフロントエンドツールを使いたい場合は、追加のビルド設定をサポートするツールを選択する必要があります。 "
"Hatchのようなカスタムビルドステップをサポートするビルドツールを選択することをお勧めします。"

#: ../../package-structure-code/complex-python-package-builds.md:18
#, fuzzy
msgid ""
"**Python packages that have extensions written in different languages "
"(e.g. Fortran and C++) or that have non Python dependencies that are "
"difficult to install (e.g. GDAL):** These packages often have complex "
"build steps (more complex than a package with just a few C extensions for"
" instance). As such, these packages require tools such as [scikit-"
"build](https://scikit-build.readthedocs.io/en/latest/) or [meson-"
"python](https://mesonbuild.com/Python-module.html) to build. NOTE: you "
"can use meson-python with PDM."
msgstr ""
"**異なる言語で書かれた拡張(例えばFortranやC++)を持つPythonパッケージや、 "
"インストールが困難なPython以外の依存関係(例えばGDAL)を持つPythonパッケージ ** "
"これらのパッケージは、しばしば複雑なビルド手順を持ちます(例えば、いくつかのC拡張を持つ パッケージよりも複雑です)。 "
"そのため、これらのパッケージのビルドには [scikit-build](https://scikit-"
"build.readthedocs.io/en/latest/) や [meson-python](https://mesonbuild.com"
"/Python-module.html) といったツールが必要になります。 注：meson-pythonはPDMと一緒に使うことができます。"

#: ../../package-structure-code/complex-python-package-builds.md:21
msgid "Mixing frontend and backend projects"
msgstr "フロントエンドとバックエンドの混合プロジェクト"

#: ../../package-structure-code/complex-python-package-builds.md:23
msgid ""
"It is sometimes necessary or desirable to use a build frontend with an "
"alternative build-backend. This is because some frontends do not have a "
"default backend (`build`), and this choice is placed on the maintainer. "
"Other backends (`hatch`) have a preferred backend (`hatchling`) but allow"
" the maintainer to migrate to another, while some backends (`poetry`) "
"only work with a single backend (`poetry-core`). Refer to (#python-"
"package-build-tools) for more information about frontend and backend "
"compatibility."
msgstr ""
"ビルドフロントエンドと別のビルドバックエンドを併用することが必要な場合や望ましい場合があります。これは、フロントエンドの中にはデフォルトのバックエンド（`build`）を持たないものがあり、この選択はメンテナに委ねられているからです。他のバックエンド"
" (`hatch`) には推奨されるバックエンド (`hatchling`) "
"がありますが、メンテナは別のものに移行することができます。一方、一部のバックエンド (`poetry`) は単一のバックエンド (`poetry-"
"core`) でのみ動作します。フロントエンドとバックエンドの互換性に関する詳細は、 (#python-package-build-tools) "
"を参照してください。"

#: ../../package-structure-code/complex-python-package-builds.md:29
msgid ""
"In this packaging guide we recommend using `hatch` along with its "
"preferred backend `hatchling`. While this will be suitable for most "
"packages, an alternate backend may be used with Hatch if needed when "
"creating an extension module. A Python extension module is one that is "
"made up, either in part or entirely, of compiled code. In this case the "
"backend chosen (such as `meson-python`) must know how to compile the "
"extension language and bind it to Python. `hatchling` does not know how "
"to do this all on its own and must either make use of "
"[plugins](https://hatch.pypa.io/1.9/plugins/about/) or be replaced by a "
"backend that is already capable of building extension modules."
msgstr ""
"このパッケージングガイドでは、 `hatch` とそのバックエンドである `hatchling` "
"の使用を推奨します。これはほとんどのパッケージに適していますが、拡張モジュールを作成する際に必要であれば、Hatchで別のバックエンドを使用することもできます。Pythonの拡張モジュールは、一部または全部がコンパイルされたコードで構成されています。この場合、("
" `meson-python` のような)バックエンドは、拡張言語をコンパイルしてPythonにバインドする方法を知っていなければなりません。 "
"[プラグイン](https://hatch.pypa.io/1.9/plugins/about/) "
"を利用するか、すでに拡張モジュールを構築できるバックエンドに置き換えなければなりません。"

#: ../../package-structure-code/complex-python-package-builds.md:37
msgid ""
"In order to use a different backend you will need to edit your project's "
"`pyproject.toml`. If you have a `pyproject.toml` generated by the `hatch`"
" command, or from following the packaging tutorial, you may have to make "
"a change like this"
msgstr ""
"別のバックエンドを使用するには、プロジェクトの `pyproject.toml` を編集する必要があります。 `hatch` コマンドで生成された"
" `pyproject.toml` や、パッケージングチュートリアルに従った `pyproject.toml` "
"がある場合は、次のように変更する必要があるかもしれません。"

#: ../../package-structure-code/declare-dependencies.md:8
#: ../../package-structure-code/declare-dependencies.md:375
#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:22
msgid "Todo"
msgstr "Todo"

#: ../../package-structure-code/declare-dependencies.md:10
#, fuzzy
msgid ""
"keep this comment - https://github.com/pyOpenSci/python-package-"
"guide/pull/106#issuecomment-1844278487 in this file for now - jeremiah "
"did a nice inventory of common shells and whether they need quotes or "
"not. It's really comprehensive. But do we want it in the guide?? it's "
"really useful for more advanced users i think."
msgstr ""
"このコメントを残しておいてください - https://github.com/pyOpenSci/python-package-"
"guide/pull/106#issuecomment-1844278487 - "
"今のところはこのファイルに。jeremiahは一般的なシェルについて、引用符が必要かどうかという点も含めて、素晴らしいリストを作成しました。本当に包括的です。しかし、ガイドに必要でしょうか？上級ユーザーにとっては本当に役立つと思います。"

#: ../../package-structure-code/declare-dependencies.md:12
msgid ""
"Following this comment: https://github.com/pyOpenSci/python-package-"
"guide/pull/106#pullrequestreview-1766663571"
msgstr ""
"このコメントによります: https://github.com/pyOpenSci/python-package-"
"guide/pull/106#pullrequestreview-1766663571"

#: ../../package-structure-code/declare-dependencies.md:15
msgid "Jonny will add a section that talks about:"
msgstr "Jonny はそのセクションを追加する予定です:"

#: ../../package-structure-code/declare-dependencies.md:17
msgid ""
"Why you specify dependencies How to specify dependencies When you use "
"different specifiers"
msgstr "依存関係を指定する理由 依存関係を指定する方法 異なる指定子を使用する場合"

#: ../../package-structure-code/declare-dependencies.md:22
msgid "Python Package Dependencies"
msgstr "Pythonパッケージの依存関係"

#: ../../package-structure-code/declare-dependencies.md:24
msgid "What is a package dependency?"
msgstr "パッケージ依存性とは何か？"

#: ../../package-structure-code/declare-dependencies.md:26
msgid ""
"A Python package dependency refers to an external package or software "
"that your Python project:"
msgstr "Pythonパッケージ依存とは、Pythonプロジェクトが使用する外部パッケージやソフトウェアのことです:"

#: ../../package-structure-code/declare-dependencies.md:29
#, fuzzy
msgid "Needs to function properly."
msgstr "適切に機能する必要があります。"

#: ../../package-structure-code/declare-dependencies.md:30
#, fuzzy
msgid ""
"Requires if someone wants to develop / work on improving your package "
"locally or"
msgstr "もし、あなたのパッケージをローカルで開発したり、改良したりしたい人がいるか"

#: ../../package-structure-code/declare-dependencies.md:31
#, fuzzy
msgid ""
"Requires if a user wants to add additional functionality (that is not "
"core) to your package"
msgstr "ユーザが（コアではない）追加機能をパッケージに追加したい場合に必要です。"

#: ../../package-structure-code/declare-dependencies.md:33
msgid ""
"A dependency is not part of your project's codebase. It is a package or "
"software that is called within the code of your project or during "
"development of your package."
msgstr "依存関係は、プロジェクトのコードベースの一部ではありません。 プロジェクトのコード内やパッケージの開発中に呼び出されるパッケージやソフトウェアです。"

#: ../../package-structure-code/declare-dependencies.md:37
msgid "Understanding optional vs. required dependencies"
msgstr "オプションと必須の依存関係を理解する"

#: ../../package-structure-code/declare-dependencies.md:38
#, fuzzy
msgid ""
"You can think about dependencies as being either optional or required. If"
" they are required, they will be listed in the `dependencies` key in the "
"`project` table of your `pyproject.toml` file. If they are optional, they"
" will be listed in the `[optional.dependencies]` table of your "
"`pyproject.toml`."
msgstr ""
"依存関係はオプションか必須であると考えることができます。 必須であれば、 `pyproject.toml` ファイルの `[dependency]"
" =` テーブルにリストされます。 オプションの場合は、 `pyproject.toml` の `[optional.dependencies]`"
" テーブルにリストされます。"

#: ../../package-structure-code/declare-dependencies.md:40
msgid "You will learn about both below."
msgstr "両者については後述します。"

#: ../../package-structure-code/declare-dependencies.md:46
msgid ""
"There are two broad groups of Python package dependencies: those that are"
" optional and those that are required. Required packages are those that a"
" user needs to use your package. Optional dependencies are packages a "
"user can chose to install to add functionality to your package. Within "
"those 2 groups, there are three use cases that you can think about. 1. "
"Core dependencies are **required** for a user to use your package. 2. "
"Development dependencies are optional and only needed if someone wants to"
" work on your package locally. 3. Finally feature dependencies are "
"optional and add additional functionality to your package. Not all "
"packages will have feature dependencies."
msgstr ""
"Pythonパッケージの依存関係には、オプションのものと必須のものの2つの大きなグループがあります。必須パッケージとは、ユーザがあなたのパッケージを使うために必要なパッケージのことです。オプションの依存関係とは、パッケージの機能を追加するために、ユーザーがインストールを選択できるパッケージのことです。この2つのグループの中で、3つのユースケースを考えることができます。1."
" コアの依存関係は、ユーザがあなたのパッケージを使うために **必須** です。2. "
"開発依存関係はオプションで、誰かがあなたのパッケージをローカルで作業したい場合にのみ必要です。3. "
"最後に、機能依存はオプションであり、パッケージに追加機能を追加します。 すべてのパッケージが機能依存を持つわけではありません。"

#: ../../package-structure-code/declare-dependencies.md:51
msgid "Required (or core) dependencies"
msgstr "必須（またはコア）の依存関係"

#: ../../package-structure-code/declare-dependencies.md:53
#, fuzzy
msgid ""
"Required dependencies are called directly within your package's code. On "
"this page we refer to these dependencies as **core dependencies** as they"
" are needed in order to run your package. You should place your core or "
"required dependencies in the `dependencies` key of the `[project]` table "
"of your `pyproject.toml` file."
msgstr ""
"必要な依存関係は、パッケージのコード内で直接呼び出されます。このページでは、パッケージを実行するために必要なこれらの依存関係を "
"**コア依存関係** と呼びます。 `pyproject.toml` ファイルの `[dependency]=` "
"テーブルに、コアまたは必要な依存関係を置く必要があります。"

#: ../../package-structure-code/declare-dependencies.md:56
#: ../../package-structure-code/declare-dependencies.md:147
msgid "Optional dependencies"
msgstr "オプションの依存関係"

#: ../../package-structure-code/declare-dependencies.md:58
msgid ""
"Optional dependencies dependencies can be optionally installed by users "
"depending upon their needs. There are two broad groups of optional "
"dependencies:"
msgstr ""
"オプションの依存関係依存関係は、ユーザーが必要に応じてオプションでインストールすることができます。 "
"オプションの依存関係には、大きく分けて2つのグループがあります:"

#: ../../package-structure-code/declare-dependencies.md:61
msgid ""
"**Development dependencies**: These are dependencies that are required to"
" support development of your package. They include tools to run tests "
"such as `pytest`, linters (like `flake8` and `ruff`) and code formatters "
"such as `black` and even automation tools such as `nox` or `tox` that run"
" tasks."
msgstr ""
"**開発依存** :これらは、あなたのパッケージの開発をサポートするために必要な依存関係です。pytest` のようなテストを実行するツールや、 "
"( `flake8` や `ruff` のような) リンター、`black` のようなコードフォーマッター、さらにはタスクを実行する `nox` "
"や `tox` のような自動化ツールも含まれます。"

#: ../../package-structure-code/declare-dependencies.md:63
msgid ""
"**Feature dependencies:** These are dependencies that a user can chose to"
" install to add functionality to your package."
msgstr "**Feature dependencies:** これらは、パッケージに機能を追加するために、ユーザーが インストールを選択できる依存関係です。"

#: ../../package-structure-code/declare-dependencies.md:65
msgid ""
"When a Python project is installed, the Python package manager (either "
"`pip` or `conda`) installs your package's dependencies automatically. "
"This ensures that when you call a function in a specific dependency, it "
"is available in your user's environment."
msgstr ""
"Python プロジェクトがインストールされると、Python パッケージマネージャ (`pip` または `conda`) "
"はパッケージの依存関係を自動的にインストールします。これにより、特定の依存関係にある関数を呼び出すと、ユーザーの環境でその関数が利用できるようになります。"

#: ../../package-structure-code/declare-dependencies.md:70
msgid "Dependencies can be added to your pyproject.toml file"
msgstr "依存関係はpyproject.tomlファイルに追加できます"

#: ../../package-structure-code/declare-dependencies.md:72
msgid ""
"In the [pyproject.toml overview page](pyproject-toml-python-package-"
"metadata), you learned how to set up a **pyproject.toml** file with basic"
" metadata for your package. On this page, you will learn how to specify "
"different types of dependencies in your `pyproject.toml`."
msgstr ""
"[pyproject.tomlの概要ページ](pyproject-toml-python-package-metadata) "
"では、パッケージの基本的なメタデータを持つ **pyproject.toml** ファイルをセットアップする方法を学びました。 このページでは、 "
"`pyproject.toml` で異なるタイプの依存関係を指定する方法を学びます。"

#: ../../package-structure-code/declare-dependencies.md:79
msgid "How do you declare dependencies?"
msgstr "依存関係はどのように宣言するのか？"

#: ../../package-structure-code/declare-dependencies.md:81
msgid ""
"We recommend that you declare your dependencies using your "
"`pyproject.toml` file. This ensures that all of the metadata associated "
"with your package is declared in a single place, making it simpler for "
"users and contributors to understand your package infrastructure."
msgstr ""
"依存関係は `pyproject.toml` ファイルを使って宣言することを推奨します。 "
"こうすることで、パッケージに関連するすべてのメタデータが一箇所で宣言され、ユーザや貢献者がパッケージのインフラストラクチャを理解するのがより簡単になります。"

#: ../../package-structure-code/declare-dependencies.md:86
msgid ""
"Previously, it was common to use a `requirements.txt` file to declare "
"package dependencies. However in recent years, the ecosystem has moved to"
" storing this information in your **pyproject.toml** file. You may notice"
" however that some projects still maintain a `requirements.txt` file for "
"specific local development needs."
msgstr ""
"以前は `requirements.txt` ファイルを使ってパッケージの依存関係を宣言するのが一般的でした。しかし近年、エコシステムはこの情報を"
" **pyproject.toml** ファイルに保存するようになりました。しかし、プロジェクトによっては、特定のローカルな開発ニーズのために "
"`requirements.txt` ファイルを保持していることに気づくかもしれません。"

#: ../../package-structure-code/declare-dependencies.md:92
msgid "Other ways you may see packages storing dependencies"
msgstr "パッケージが依存関係を保存する他の方法"

#: ../../package-structure-code/declare-dependencies.md:95
msgid ""
"If a project contains extensions written in other languages, you may need"
" a `setup.py` file. Or you may contribute to a package that us using "
"`setup.cfg` for dependency declaration. [Learn more about this in the "
"setuptools "
"documentation](https://setuptools.pypa.io/en/latest/userguide/dependency_management.html"
"#declaring-required-dependency)"
msgstr ""
"プロジェクトが他の言語で書かれた拡張機能を含んでいる場合、 `setup.py` ファイルが必要になるかもしれません。あるいは、依存関係の宣言に "
"`setup.cfg` を使っているパッケージに貢献することもできます。 [これについては setuptools "
"のドキュメントを参照してください](https://setuptools.pypa.io/en/latest/userguide/dependency_management.html"
"#declaring-required-dependency)"

#: ../../package-structure-code/declare-dependencies.md:100
msgid "Add required dependencies to your pyproject.toml file"
msgstr "必要な依存関係をpyproject.tomlファイルに追加"

#: ../../package-structure-code/declare-dependencies.md:102
msgid ""
"Your core project dependencies need to be installed by a package manager "
"such as `pip` or `conda` when a user installs your package. You can add "
"those dependencies to the `dependencies` array located within the "
"`[project]` table of your **pyproject.toml** file. This looks something "
"like this:"
msgstr ""
"コアプロジェクトの依存関係は、ユーザがパッケージをインストールするときに `pip` や `conda` "
"のようなパッケージマネージャによってインストールされる必要があります。 これらの依存関係は、**pyproject.toml** ファイルの "
"`[project]` テーブルにある `dependencies` 配列に追加することができます。 これは次のようになります:"

#: ../../package-structure-code/declare-dependencies.md:121
#, fuzzy
msgid ""
"Ideally, you should only list the packages that are necessary to install "
"and use your package in the `dependencies` key in the `[project]` table. "
"This minimizes the number of additional packages that your users must "
"install as well as the number of packages that depend upon your package "
"must also install."
msgstr ""
"理想的には、 `[dependencies]` セクションに、あなたのパッケージをインス "
"トールして使用するために必要なパッケージだけをリストするようにしま す。 "
"こうすることで、ユーザがインストールしなければならない追加パッケージの数や "
"あなたのパッケージに依存するパッケージの数を最小限に抑えることができます。"

#: ../../package-structure-code/declare-dependencies.md:128
msgid ""
"Remember that fewer dependencies to install reduces the likelihood of "
"version mismatches in user environments."
msgstr "インストールする依存関係を少なくすることで、ユーザー環境でのバージョン不一致の可能性が低くなることを覚えておいてください。"

#: ../../package-structure-code/declare-dependencies.md:131
msgid "A dependency example"
msgstr "依存関係の例"

#: ../../package-structure-code/declare-dependencies.md:133
msgid ""
"Let's pretend you have a package called `plotMe` that creates beautiful "
"plots of data stored in `numpy` arrays. To create your plots in the "
"`plotMe` package, you use the `seaborn` package to stylize our plots and "
"also `numpy` to process array formatted data."
msgstr ""
"`numpy` 配列に格納されたデータの美しいプロットを作成する `plotMe` というパッケージがあるとしましょう。 `plotMe` "
"パッケージでプロットを作成するには、 `seaborn` パッケージを使用してプロットをスタイリングし、 `numpy` "
"パッケージを使用して配列フォーマットのデータを処理します。"

#: ../../package-structure-code/declare-dependencies.md:135
msgid "In the example above, the plotMe package, depends upon two packages:"
msgstr "上の例では、plotMeパッケージは2つのパッケージに依存しています:"

#: ../../package-structure-code/declare-dependencies.md:137
msgid "seaborn"
msgstr "seaborn"

#: ../../package-structure-code/declare-dependencies.md:138
msgid "numpy"
msgstr "numpy"

#: ../../package-structure-code/declare-dependencies.md:140
msgid ""
"This means that in order for plotMe to work in a user's `environment` "
"when installed, you also need to ensure that they have both of those "
"required `dependencies` installed in their environment too."
msgstr ""
"つまり、plotMeをインストールしたユーザーの `環境` で動作させるためには、そのユーザーの環境にも必要な `依存関係` "
"の両方がインストールされていることを確認する必要があります。"

#: ../../package-structure-code/declare-dependencies.md:142
msgid ""
"Declaring a dependency in your `pyproject.toml` file will ensure that it "
"is listed as a required dependency when your package is published to PyPI"
" and that a package manager (`pip` or `conda`) will automatically install"
" it into a user's environment alongside your package:"
msgstr ""
"依存関係を `pyproject.toml` ファイルで宣言することで、あなたのパッケージが PyPI "
"に公開されるときに必須の依存関係としてリストされ、パッケージマネージャ ( `pip` や `conda` ) "
"があなたのパッケージと一緒にユーザーの環境に自動的にインストールするようになります:"

#: ../../package-structure-code/declare-dependencies.md:144
msgid "`python -m pip install plotMe`"
msgstr "`python -m pip install plotMe`"

#: ../../package-structure-code/declare-dependencies.md:149
msgid ""
"Optional dependencies for building your documentation, running your tests"
" and building your package's distribution files are often referred to as "
"development dependencies. These are the dependencies that a user needs to"
" work on your package locally and perform tasks such as:"
msgstr ""
"ドキュメントの構築、テストの実行、パッケージの配布ファイルの構築のための オプションの依存関係は、しばしば開発依存関係と呼ばれます。 "
"これらは、ユーザがあなたのパッケージをローカルで作業し、以下のようなタスクを実行するために必要な依存関係です:"

#: ../../package-structure-code/declare-dependencies.md:151
msgid "running your test suite"
msgstr "テストスイートの実行"

#: ../../package-structure-code/declare-dependencies.md:152
msgid "building your documentation"
msgstr "ドキュメントの作成"

#: ../../package-structure-code/declare-dependencies.md:153
msgid "linting and other code cleanup tools"
msgstr "リンティングとその他のコードクリーンナップツール"

#: ../../package-structure-code/declare-dependencies.md:155
#, fuzzy
msgid ""
"These dependencies are considered optional, because they are not required"
" to install and use your package. Feature dependencies are considered "
"optional and should also be placed in the `[project.optional-"
"dependencies]` table."
msgstr ""
"これらの依存関係はオプションとみなされます。なぜなら、あなたのパッケ ージをインストールして使用するのに必要ではないからです。 "
"機能の依存関係はオプションとみなされ、 `[optional.dependencies]` テーブルに置く必要があります。"

#: ../../package-structure-code/declare-dependencies.md:158
#, fuzzy
msgid ""
"Optional dependencies can be stored in an `[project.optional-"
"dependencies]` table in your **pyproject.toml** file."
msgstr ""
"オプションの依存関係は **pyproject.toml** ファイルの `[optional.dependencies]` "
"テーブルに格納することができます。"

#: ../../package-structure-code/declare-dependencies.md:161
#, fuzzy
msgid ""
"It's important to note that within the `[project.optional-dependencies]` "
"table, you can store additional, optional dependencies within named sub-"
"groups. This is a different table than the dependencies array located "
"within the `[project]` table discussed above which contains a single "
"array with a single list of required packages."
msgstr ""
"ここで重要なのは、 `[optional.dependencies]` "
"テーブルの中で、名前付きサブグループの中に追加のオプションの依存関係を格納できることです。これは、上で説明した `[project]` "
"テーブル内の依存関係配列とは異なるテーブルであり、必要なパッケージのリストを1つだけ含む配列が1つ格納されています。"

#: ../../package-structure-code/declare-dependencies.md:163
msgid "Create optional dependency groups"
msgstr "オプションの依存グループを作成する"

#: ../../package-structure-code/declare-dependencies.md:165
msgid "To declare optional dependencies in your **pyproject.toml** file:"
msgstr "**pyproject.toml** ファイルでオプションの依存関係を宣言します:"

#: ../../package-structure-code/declare-dependencies.md:167
#, fuzzy
msgid ""
"Add a `[project.optional-dependencies]` table to your **pyproject.toml** "
"file."
msgstr "**pyproject.toml** ファイルに `[optional.dependencies]` テーブルを追加します。"

#: ../../package-structure-code/declare-dependencies.md:168
msgid "Create named groups of dependencies using the syntax:"
msgstr "構文を使って、依存関係の名前付きグループを作成します:"

#: ../../package-structure-code/declare-dependencies.md:170
msgid "`group-name = [\"dep1\", \"dep2\"]`"
msgstr "`group-name = [\"dep1\", \"dep2\"]`"

#: ../../package-structure-code/declare-dependencies.md:172
msgid "Installing packages from GitHub / Gitlab"
msgstr "GitHub / Gitlab からパッケージをインストールする"

#: ../../package-structure-code/declare-dependencies.md:175
msgid ""
"If you have dependencies that need to be installed directly from GitHub "
"using a `git+https` installation approach, you can do so using the "
"pyproject.toml file like so:"
msgstr ""
"GitHubから直接インストールする必要がある依存関係がある場合は、`git+https`というインストール方法を使います、以下のように "
"`pyproject.toml` ファイルを使用します:"

#: ../../package-structure-code/declare-dependencies.md:185
msgid ""
"IMPORTANT: For security reasons, if your library depends on a GitHub-"
"hosted project, you will need to point to a specific commit/tag/hash of "
"that repository in order to upload your project to PyPI"
msgstr "重要:セキュリティ上の理由から、あなたのライブラリがGitHubでホストされているプロジェクトに依存している場合、あなたのプロジェクトをPyPIにアップロードするには、そのリポジトリの特定のコミット/タグ/ハッシュを指す必要があります。"

#: ../../package-structure-code/declare-dependencies.md:190
msgid ""
"Below we've created three sets of optional development dependencies "
"named: tests, docs and lint. We've also added a set of feature "
"dependencies."
msgstr "以下では、tests、docs、lintという3つのオプションの開発依存関係を作成しました。また、機能依存のセットも追加しました。"

#: ../../package-structure-code/declare-dependencies.md:213
msgid "Additional dependency resources"
msgstr "その他の依存リソース"

#: ../../package-structure-code/declare-dependencies.md:215
msgid ""
"[Learn more: View PyPA's overview of declaring optional "
"dependencies](https://packaging.python.org/en/latest/specifications"
"/declaring-project-metadata/#dependencies-optional-dependencies)"
msgstr ""
"[詳細はこちら: "
"PyPAのオプション依存関係の宣言の概要を見る](https://packaging.python.org/en/latest/specifications"
"/declaring-project-metadata/#dependencies-optional-dependencies)"

#: ../../package-structure-code/declare-dependencies.md:217
msgid ""
"[Dependency "
"specifiers](https://packaging.python.org/en/latest/specifications"
"/dependency-specifiers/)"
msgstr ""
"[Dependency "
"specifiers](https://packaging.python.org/en/latest/specifications"
"/dependency-specifiers/)"

#: ../../package-structure-code/declare-dependencies.md:221
msgid "Install dependency groups"
msgstr "依存グループをインストールする"

#: ../../package-structure-code/declare-dependencies.md:226
#, fuzzy
msgid ""
"Diagram showing a Venn diagram with three sections representing the "
"dependency groups listed above - docs feature and tests. In the center it"
" says your-package and lists the core dependencies of that package "
"seaborn and numpy. To the right are two arrows. The first shows the "
"command python - m pip install your-package. It them shows how installing"
" your package that way installs only the package and the two core "
"dependencies into a users environment. Below is a second arrow with "
"python -m pip install youPackage[tests]. This leads to an environment "
"with both the package dependencies - your-package, seaborn and numpy and "
"also the tests dependencies including pytest and pytest-cov"
msgstr ""
"上記の依存グループを表す3つのセクションを持つven図を示す図 - ドキュメント機能とテスト。中央には your-package "
"と表示され、そのパッケージの主要な依存関係であるseabornとnumpyがリストされています。 "
"右側に2つの矢印があります。最初のものは、コマンド python - m pip install your-package "
"を示しています。それらをインストールすると、パッケージと2つのコア依存関係のみがユーザー環境にインストールされることを示しています。以下は、2つ目の矢印で、"
" python -m pip install youPackage[tests] とあります。これにより、パッケージ依存関係 - your-"
"package、seaborn、numpy とテスト依存関係 pytest、pytest-cov の両方を含む環境が構築されます。"

#: ../../package-structure-code/declare-dependencies.md:228
#, fuzzy
msgid ""
"When a user installs your package locally using `python -m pip install "
"your-package` only your package and it's core dependencies get installed."
" When they install your package `python -m pip install your-"
"package[tests]` pip will install both your package and its core "
"dependencies plus any of the dependencies listed within the tests array "
"of your `[project.optional-dependencies]` table."
msgstr ""
"ユーザがローカルで python -m pip install your-package "
"を使ってあなたのパッケージをインストールすると、あなたのパッケージとそのコア依存関係のみがインストールされます。ユーザがあなたのパッケージ "
"`[tests]` をインストールすると、pip はあなたのパッケージとそのコア依存パッケージの両方をインストールし、さらに "
"`[optional.dependencies]` テーブルの tests 配列にリストされている依存パッケージをインストールします。"

#: ../../package-structure-code/declare-dependencies.md:231
msgid "Using `python -m pip install` vs. `pip install`"
msgstr "`python -m pip install` と `pip install` の比較"

#: ../../package-structure-code/declare-dependencies.md:233
msgid ""
"In all of the examples in this guide, you will notice we are calling "
"`pip` using the syntax:"
msgstr "このガイドのすべての例で、構文を使って `pip` を呼び出していることに気づくでしょう:"

#: ../../package-structure-code/declare-dependencies.md:236
msgid "`python -m pip`"
msgstr "`python -m pip`"

#: ../../package-structure-code/declare-dependencies.md:238
msgid ""
"Calling pip using `python -m` ensures that the `pip` that you are using "
"to install your package comes from your current active Python "
"environment. We strongly suggest that you use this approach whenever you "
"call `pip` to avoid installation conflicts."
msgstr ""
"`python -m` を使用して pip を呼び出すと、パッケージをインストールするために使用する `pip` が、現在アクティブな "
"Python 環境のものであることが保証されます。インストールの衝突を避けるために、 `pip` "
"を呼び出すときは常にこの方法を使うことを強く推奨します。"

#: ../../package-structure-code/declare-dependencies.md:242
msgid ""
"To ensure this works as you want it to, activate your package's "
"development environment prior to installing anything using `pip`."
msgstr "これが思い通りに動くようにするには、 `pip` を使って何かをインストールする前に、パッケージの開発環境を有効にしてください。"

#: ../../package-structure-code/declare-dependencies.md:246
msgid ""
"You can install development dependencies using the groups that you "
"defined above using the syntax:"
msgstr "上記で定義したグループを使用して、構文を使って開発依存ファイルをインストールすることができます:"

#: ../../package-structure-code/declare-dependencies.md:249
msgid "`python -m pip install \".[docs]\"`"
msgstr "`python -m pip install \".[docs]\"`"

#: ../../package-structure-code/declare-dependencies.md:251
msgid "Above you install:"
msgstr "上記でインストールするのは:"

#: ../../package-structure-code/declare-dependencies.md:252
msgid "dependencies needed for your documentation (`docs`),"
msgstr "ドキュメント (`docs`) に必要な依存関係、"

#: ../../package-structure-code/declare-dependencies.md:253
#, fuzzy
msgid "required package dependencies in the `dependencies` array and"
msgstr "必要なパッケージの依存関係を `dependency` 配列で指定し"

#: ../../package-structure-code/declare-dependencies.md:254
msgid "your package"
msgstr "あなたのパッケージ"

#: ../../package-structure-code/declare-dependencies.md:256
msgid ""
"using pip. Below you install your package, required dependencies and "
"optional test dependencies."
msgstr "pipを使います。 以下では、パッケージ、必要な依存関係、オプションのテスト依存関係をインストールします。"

#: ../../package-structure-code/declare-dependencies.md:259
#: ../../package-structure-code/declare-dependencies.md:277
msgid "`python -m pip install \".[tests]\"`"
msgstr "`python -m pip install \".[tests]\"`"

#: ../../package-structure-code/declare-dependencies.md:261
#, fuzzy
msgid ""
"You can install multiple dependency groups in the `[project.optional-"
"dependencies]` table using:"
msgstr "`[optional.dependencies]` テーブルに複数の依存グループをインストールすることができます:"

#: ../../package-structure-code/declare-dependencies.md:263
msgid "`python -m pip install \".[docs, tests, lint]\"`"
msgstr "`python -m pip install \".[docs, tests, lint]\"`"

#: ../../package-structure-code/declare-dependencies.md:266
msgid "For zsh shell users"
msgstr "zshシェルユーザーの場合"

#: ../../package-structure-code/declare-dependencies.md:270
msgid ""
"There are different shell applications that you and your package "
"contributors might use."
msgstr "あなたやパッケージの貢献者が使うかもしれません、さまざまなシェルアプリケーションがあります。"

#: ../../package-structure-code/declare-dependencies.md:271
msgid "zsh is the shell that comes by default on newer Mac OS computers"
msgstr "zsh は、新しい Mac OS コンピュータにデフォルトで搭載されているシェルです"

#: ../../package-structure-code/declare-dependencies.md:272
msgid "Windows users may use a tool such as git bash"
msgstr "Windowsユーザーは、git bashのようなツールを使うことができます"

#: ../../package-structure-code/declare-dependencies.md:274
msgid ""
"Some shells don't support unquoted brackets (`[tests]`) which is why we "
"add quotes to the command in this guide like this:"
msgstr ""
"シェルによっては、引用符で囲まれていない括弧 (`[tests]`) "
"をサポートしていないものもあるので、このガイドではこのようにコマンドに引用符を追加しています:"

#: ../../package-structure-code/declare-dependencies.md:279
msgid ""
"In some cases you may see commands without the quotes in guidebooks or "
"contributing guides like the example below:"
msgstr "ガイドブックやコントリビューションガイドでは、以下の例のように引用符を使わないコマンドを見かけることがあります:"

#: ../../package-structure-code/declare-dependencies.md:282
msgid "`python -m pip install your-package[tests]`"
msgstr "`python -m pip install your-package[tests]`"

#: ../../package-structure-code/declare-dependencies.md:284
msgid ""
"Calling your-package[tests] without the double quotes will work on some "
"shells *but not all*."
msgstr "二重引用符を付けずに your-package[tests] を呼び出すと、一部のシェルでは動作しますが、 *すべてではありません* 。"

#: ../../package-structure-code/declare-dependencies.md:287
msgid "Combining sets of dependencies"
msgstr "依存関係のセットを組み合わせる"

#: ../../package-structure-code/declare-dependencies.md:289
msgid ""
"Above we reviewed how to install dependencies from your `pyproject.toml`."
" In some cases you may want to group sets of dependencies like so:"
msgstr ""
"上記では、 `pyproject.toml` から依存関係をインストールする方法を説明しました。 "
"場合によっては、依存関係のセットをこのようにグループ化したいこともあるでしょう:"

#: ../../package-structure-code/declare-dependencies.md:302
msgid ""
"The above allows you to install both the tests and docs dependency lists "
"using the command:"
msgstr "上記のコマンドを使えば、testsとdocsの両方の依存リストをインストールできます:"

#: ../../package-structure-code/declare-dependencies.md:305
msgid "`python -m pip install \".[dev]\"`"
msgstr "`python -m pip install \".[dev]\"`"

#: ../../package-structure-code/declare-dependencies.md:308
msgid "When you install dependencies using the above syntax:"
msgstr "上記の構文を使って依存関係をインストールする場合:"

#: ../../package-structure-code/declare-dependencies.md:310
msgid "`python -m pip install \".[tests, docs]\"`"
msgstr "`python -m pip install \".[tests, docs]\"`"

#: ../../package-structure-code/declare-dependencies.md:312
msgid "`pip` will also install your package and its core dependencies."
msgstr "`pip` はあなたのパッケージとそのコアの依存関係もインストールします。"

#: ../../package-structure-code/declare-dependencies.md:316
msgid "Where does conda fit in?"
msgstr "condaはどこに入りますか？"

#: ../../package-structure-code/declare-dependencies.md:319
msgid ""
"The `pyproject.toml` file allows you to list any Python package published"
" on PyPI (or on GitHub/ GitLab) as a dependency. Once you create this "
"file, declare dependencies, [build your package](python-package-"
"distribution-files-sdist-wheel.md) and [publish your package to PyPI"
"](publish-python-package-pypi-conda.md), people can install both your "
"package and all of it's dependencies with one command."
msgstr ""
"`pyproject.toml` ファイルを使うと、PyPI(またはGitHub/ "
"GitLab)で公開されているPythonパッケージを依存関係として列挙することができます。 このファイルを作成し、依存関係を宣言し、 "
"[パッケージをビルドする](python-package-distribution-files-sdist-wheel.md) 、 "
"[パッケージをPyPIに公開する](publish-python-package-pypi-conda.md) "
"とすると、1つのコマンドであなたのパッケージと依存関係のあるパッケージの両方をインストールすることができます。"

#: ../../package-structure-code/declare-dependencies.md:322
msgid "`python -m pip install your-package`"
msgstr "`python -m pip install your-package`"

#: ../../package-structure-code/declare-dependencies.md:324
msgid "This works great if your package is pure-python (no other languages used)."
msgstr "これは、パッケージが純粋なpython (他の言語が使われていない) のであれば、とてもうまくいきます。"

#: ../../package-structure-code/declare-dependencies.md:326
msgid ""
"Some packages, particularly in the scientific Python ecosystem, require "
"dependencies that are not written in Python. Conda was created to support"
" distribution of tools that have code written in both Python and "
"languages other than Python."
msgstr ""
"いくつかのパッケージ、特に科学的なPythonエコシステムでは、Pythonで書かれていない依存関係を必要とします。 "
"Condaは、PythonとPython以外の言語の両方で書かれたコードを持つツールの配布をサポートするために作られました。"

#: ../../package-structure-code/declare-dependencies.md:329
msgid "Support conda users with environment.yml files"
msgstr "environment.yml ファイルで conda ユーザーをサポートする"

#: ../../package-structure-code/declare-dependencies.md:331
msgid ""
"The above workflow assumes that you want to publish your package on PyPI."
" And then you plan to publish to conda-forge (optionally), [by submitting"
" a recipe using grayskull](https://www.pyopensci.org/python-package-guide"
"/package-structure-code/publish-python-package-pypi-conda.html)."
msgstr ""
"上記のワークフローは、PyPIでパッケージを公開することを想定しています。そして、 "
"[grayskullを使ってレシピを投稿する](https://www.pyopensci.org/python-package-guide"
"/package-structure-code/publish-python-package-pypi-conda.html) ことで"
"、conda-forgeに(オプションで)公開する予定です。"

#: ../../package-structure-code/declare-dependencies.md:333
msgid ""
"If you want to support conda users, you may want to also maintain a conda"
" environment that they can use to install your package. Maintaining a "
"conda environment will also help you test that your package installs as "
"you expect into a conda environment."
msgstr ""
"conda ユーザーをサポートしたいのであれば、彼らがあなたのパッケージをインス トールするのに使える conda "
"環境も管理した方が良いでしょう。 conda 環境を維持することは、あなたのパッケージが conda "
"環境に期待通りにインストールされるかをテストするのにも役立ちます。"

#: ../../package-structure-code/declare-dependencies.md:336
msgid "A note for conda users"
msgstr "condaユーザーへのメモ"

#: ../../package-structure-code/declare-dependencies.md:339
msgid ""
"If you use a conda environment for developing your tool, keep in mind "
"that when you install your package using `python -m pip install -e .` (or"
" using pip in general), dependencies will be installed from PyPI rather "
"than conda."
msgstr ""
"ツールの開発にconda環境を使用している場合、 `python -m pip install -e .` "
"を使用してパッケージをインストールするとき（または一般的にpipを使用するとき）、依存関係はcondaではなくPyPIからインストールされることに注意してください。"

#: ../../package-structure-code/declare-dependencies.md:341
msgid ""
"Thus, if you are running a conda environment, installing your package in "
"\"editable\" mode risks dependency conflicts. This is particularly "
"important if you have a spatial package that requires geospatial system "
"libraries like GDAL or another system-level dependency."
msgstr ""
"したがって、conda環境を実行している場合、パッケージを \"editable \"モードでインス "
"トールすると、依存関係が衝突する危険性があります。 "
"これは、GDALのような地理空間システムライブラリや他のシステムレベルの依存関係を必要とする空間パッケージがある場合、特に重要です。"

#: ../../package-structure-code/declare-dependencies.md:343
msgid ""
"Alternatively, you can install your package using `python -m pip install "
"-e . --no-deps` to only install the package. And install the rest of your"
" dependencies using a conda environment file."
msgstr ""
"あるいは、 `python -m pip install -e . --no-deps` "
"を使ってパッケージだけをインストールすることもできます。そして、conda環境ファイルを使って残りの依存関係をインストールします。"

#: ../../package-structure-code/declare-dependencies.md:346
msgid "Dependencies in Read the Docs"
msgstr "Read the Docs の依存関係"

#: ../../package-structure-code/declare-dependencies.md:348
msgid ""
"Now that you have your dependencies specified in your project, you can "
"use them to support other workflows such as publishing to Read the Docs."
msgstr "プロジェクトで依存関係を指定できたので、Read the Docsへのパブリッシュなど、他のワークフローをサポートするためにそれらを使用できます。"

#: ../../package-structure-code/declare-dependencies.md:350
msgid ""
"[Read the Docs](https://readthedocs.org) is a documentation platform with"
" a continuous integration / continuous deployment service that "
"automatically builds and publishes your documentation."
msgstr ""
"[Read the Docs](https://readthedocs.org) "
"は、継続的インテグレーション/継続的デプロイメントサービスを備えたドキュメントプラットフォームで、あなたのドキュメントを自動的にビルドして公開します。"

#: ../../package-structure-code/declare-dependencies.md:352
msgid ""
"If you are using Read the Docs to build your documentation, then you may "
"need to install your dependencies using a **readthedocs.yaml** file."
msgstr ""
"Read the Docsを使用してドキュメントを構築している場合、 **readthedocs.yaml** "
"ファイルを使用して依存関係をインストールする必要があるかもしれません。"

#: ../../package-structure-code/declare-dependencies.md:354
msgid ""
"Below is an example of installing the **docs** section of your dependency"
" table in the pyproject.toml file within a readthedocs.yaml file."
msgstr ""
"以下は、readthedocs.yamlファイル内のpyproject.tomlファイルに依存関係テーブルの **docs** "
"セクションをインストールする例です。"

#: ../../package-structure-code/declare-dependencies.md:366
msgid "Read the Docs and Python packages"
msgstr "Read the DocsとPythonパッケージ"

#: ../../package-structure-code/declare-dependencies.md:370
msgid ""
"[Learn more about creating a `readthedocs.yaml` file here. "
"](https://docs.readthedocs.io/en/stable/config-file/index.html)"
msgstr ""
"[ `readthedocs.yaml` "
"ファイルの作成方法についてはこちらをご覧ください。](https://docs.readthedocs.io/en/stable/config-"
"file/index.html)"

#: ../../package-structure-code/declare-dependencies.md:371
msgid ""
"If you want to install dependencies using Poetry in Read the Docs, [you "
"can learn more here.](https://docs.readthedocs.io/en/stable/build-"
"customization.html#install-dependencies-with-poetry)"
msgstr ""
"Read the DocsのPoetryを使って依存関係をインストールしたい場合は、 "
"[こちらで詳しく説明されています。](https://docs.readthedocs.io/en/stable/build-"
"customization.html#install-dependencies-with-poetry)"

#: ../../package-structure-code/declare-dependencies.md:376
msgid "This is hidden. TO"
msgstr "これは隠されています。TO"

#: ../../package-structure-code/intro.md:179
msgid "Intro"
msgstr "イントロ"

#: ../../package-structure-code/intro.md:179
msgid "Python package structure"
msgstr "Pythonパッケージ構造"

#: ../../package-structure-code/intro.md:179
msgid "pyproject.toml Package Metadata"
msgstr "pyproject.toml パッケージのメタデータ"

#: ../../package-structure-code/intro.md:179
msgid "Build Your Package"
msgstr "パッケージをビルドする"

#: ../../package-structure-code/intro.md:179
msgid "Declare dependencies"
msgstr "依存関係の宣言"

#: ../../package-structure-code/intro.md:179
msgid "Package Build Tools"
msgstr "パッケージビルドツール"

#: ../../package-structure-code/intro.md:179
msgid "Complex Builds"
msgstr "複雑なビルド"

#: ../../package-structure-code/intro.md:179
#, fuzzy
msgid "Create & Build Your Package"
msgstr "パッケージをビルドする"

#: ../../package-structure-code/intro.md:193
msgid "Publish with Conda / PyPI"
msgstr "Conda / PyPIで公開する"

#: ../../package-structure-code/intro.md:193
msgid "Package versions"
msgstr "パッケージバージョン"

#: ../../package-structure-code/intro.md:193
msgid "Code style"
msgstr "コードスタイル"

#: ../../package-structure-code/intro.md:193
#, fuzzy
msgid "Publish your package"
msgstr "パッケージの公開"

#: ../../package-structure-code/intro.md:1
#, fuzzy
msgid "Python Package Structure"
msgstr "Pythonパッケージ構造"

#: ../../package-structure-code/intro.md:3
#, fuzzy
msgid ""
"This section provides guidance on your Python package's structure, code "
"format, and style. It also reviews the various [packaging tools](python-"
"package-build-tools) you can use to [build](python-package-distribution-"
"files-sdist-wheel) and [publish](publish-python-package-pypi-conda) your "
"Python package."
msgstr ""
"このセクションでは Python パッケージの構造、コードフォーマット、スタイルに関するガイダンスを提供します。 "
"また、パッケージのビルドと公開をサポートするために使用できる様々なパッケージングツールについても説明します。"

#: ../../package-structure-code/intro.md:7
msgid ""
"If you want end-to-end tutorials, check out our tutorial series that "
"starts by introducing [what a Python package is](what-is-a-package)."
msgstr ""

#: ../../package-structure-code/intro.md:9
#, fuzzy
msgid ""
"If you are confused by Python packaging, you are not alone! The good news"
" is that some great modern packaging tools ensure you follow best "
"practices. Here, we review tool features and suggest tools you can use "
"for your Python packaging workflow."
msgstr ""
"Python のパッケージングに戸惑っているのはあなただけではありません！ "
"良いニュースは、あなたがベストプラクティスに従っていることを保証する、いくつかの素晴らしい最新のパッケージングツールがあるということです。 "
"ここでは、ツールの機能をレビューし、あなたのワークフローに最適なツールを提案します。"

#: ../../package-structure-code/intro.md:14
msgid "Checkout our beginning-to-end create a Python package tutorials"
msgstr ""

#: ../../package-structure-code/intro.md:23
msgid "How this content is developed"
msgstr ""

#: ../../package-structure-code/intro.md:24
msgid ""
"All of the content in this guide has been vetted by community members, "
"including maintainers and developers of the core packaging tools."
msgstr ""

#: ../../package-structure-code/intro.md:35
msgid "✨ 1. Package file structure ✨"
msgstr "✨ 1. パッケージのファイル構成 ✨"

#: ../../package-structure-code/intro.md:39
msgid ""
"src layout, flat layout and where should tests folders live? No matter "
"what your level of packaging knowledge is, this page will help you decide"
" upon a package structure that follows modern python best practices."
msgstr ""
"src レイアウト、フラットレイアウト、テストフォルダはどこに置くべきか？ "
"あなたのパッケージング知識のレベルに関係なく、このページは最新のpythonのベストプラクティスに従ったパッケージ構造を決める助けになるでしょう。"

#: ../../package-structure-code/intro.md:44
msgid "✨ 2. Learn about building your package ✨"
msgstr "✨ 2. パッケージの構築について学ぶ✨ "

#: ../../package-structure-code/intro.md:48
msgid ""
"To publish your Python package on PyPI, you will need to first build it. "
"The act of \"building\" refers to the process of placing your package "
"code and metadata into a format that can be published on PyPI. Learn more"
" about building your Python package."
msgstr ""
"PythonパッケージをPyPIで公開するには、まずビルドする必要があります。 \"ビルド\" "
"とは、パッケージのコードとメタデータをPyPIで公開できるような形式にすることです。 "
"Pythonパッケージのビルドについての詳細はこちらをご覧ください。"

#: ../../package-structure-code/intro.md:57
msgid "✨ 4. Add metadata ✨"
msgstr "✨ 4. メタデータを追加する ✨"

#: ../../package-structure-code/intro.md:61
msgid ""
"Learn how to add project metadata to your Python package to support both "
"filtering on PyPI and also the metadata that a package installer needs to"
" build and install your package."
msgstr ""
"Python パッケージにプロジェクトのメタデータを追加して、PyPI "
"でのフィルタリングと、パッケージインストーラがパッケージをビルドしてインストールするために必要なメタデータの両方をサポートする方法を学びましょう。"

#: ../../package-structure-code/intro.md:68
msgid "✨ 3. What Python package tool should you use? ✨"
msgstr "✨ 3. どのPythonパッケージツールを使うべきですか？ ✨"

#: ../../package-structure-code/intro.md:72
msgid ""
"Learn more about the suite of packaging tools out there. And learn which "
"tool might be best for you."
msgstr "パッケージングツール群についてもっと知りましょう。そして、どのツールがあなたに最適かを学びましょう。"

#: ../../package-structure-code/intro.md:78
msgid "✨ 4. Publish to PyPI and Conda ✨"
msgstr "✨ 4. PyPIとCondaに公開する ✨"

#: ../../package-structure-code/intro.md:82
msgid ""
"If you have a pure Python package, it's a straight forward process to "
"publish to both PyPI and then a Conda channel such as conda-forge. Learn "
"more here."
msgstr "純粋なPythonパッケージであれば、PyPIとconda-forgeのようなCondaチャネルの両方に公開するのは簡単です。 詳しくはこちら。"

#: ../../package-structure-code/intro.md:89
msgid "✨ 5. Setup package versioning ✨"
msgstr "✨ 5. パッケージのバージョニングを設定する ✨"

#: ../../package-structure-code/intro.md:93
msgid ""
"Semver (numeric versioning) and Calver (versioning using the date) are 2 "
"common ways to version a package. Which one should you pick? Learn more "
"here."
msgstr ""
"Semver (数値によるバージョン管理) と Calver (日付によるバージョン管理) "
"は、パッケージをバージョン管理する2つの一般的な方法です。 どちらを選ぶべきでしょうか？ 詳しくはこちら。"

#: ../../package-structure-code/intro.md:99
msgid "✨ 6. Code style & linters ✨"
msgstr "✨6. コードスタイルとリンター✨"

#: ../../package-structure-code/intro.md:103
msgid ""
"Black, blue, flake8, Ruff - which tools can help you ensure your package "
"follows best practices for code format? Learn more about the options and "
"why this is important here."
msgstr ""
"Black、blue、flake8、Ruff - "
"あなたのパッケージがコードフォーマットのベストプラクティスに従っていることを確認するのに役立つツールはどれですか？ "
"オプションの詳細と、なぜこれが重要なのかについては、こちらをご覧ください。"

#: ../../package-structure-code/intro.md:111
msgid ""
"Figure showing a decision tree with the various packaging tool front-end "
"and back-end options."
msgstr "様々なパッケージングツールのフロントエンドとバックエンドのオプションの決定ツリーを示す図。"

#: ../../package-structure-code/intro.md:113
msgid ""
"Diagram showing the various front-end build tools that you can select "
"from. See the packaging tools page to learn more about each tool."
msgstr "選択可能な様々なフロントエンドビルドツールを示す図。 各ツールの詳細については、パッケージングツールのページを参照してください。"

#: ../../package-structure-code/intro.md:118
msgid ""
"If you are considering submitting a package for peer review, have a look "
"at the bare-minimum [editor checks](https://www.pyopensci.org/software-"
"peer-review/how-to/editor-in-chief-guide.html#editor-checklist-template) "
"that pyOpenSci performs before a review begins. These checks are useful "
"to explore for both authors planning to submit a package to us for review"
" and for anyone who is just getting started with creating a Python "
"package."
msgstr ""
"査読にパッケージを投稿しようと考えているなら、査読が始まる前にpyOpenSciが行う最低限の [editor "
"checks](https://www.pyopensci.org/software-peer-review/how-to/editor-in-"
"chief-guide.html#editor-checklist-template) "
"を見てください。これらのチェックは、私たちにパッケージをレビューのために提出しようと計画している作者と、Pythonパッケージを作成し始めたばかりの人の両方にとって、調べるのに便利です。"

#: ../../package-structure-code/intro.md:125
msgid "What you will learn here"
msgstr "ここで学べること"

#: ../../package-structure-code/intro.md:127
msgid "In this section of our Python packaging guide, we:"
msgstr "Pythonパッケージングガイドのこのセクションでは、以下のことを説明します:"

#: ../../package-structure-code/intro.md:129
#, fuzzy
msgid ""
"Provide an overview of the options available to you when packaging your "
"code."
msgstr "ツールをパッケージングする際に利用可能なオプションの概要を説明する。"

#: ../../package-structure-code/intro.md:131
msgid ""
"Suggest tools and approaches that both meet your needs and also support "
"existing standards."
msgstr "ニーズを満たし、かつ既存の基準をサポートするツールやアプローチを提案します。"

#: ../../package-structure-code/intro.md:133
#, fuzzy
msgid ""
"Suggest tools and approaches that will allow you to expand upon a "
"workflow that may begin as a pure Python code and evolve into code that "
"requires addition layers of complexity in the packaging build."
msgstr "純粋なPythonツールから始まり、パッケージングビルドに複雑なレイヤーを追加する必要のあるツールへと進化するワークフローを拡張することを可能にするツールやアプローチを提案します。"

#: ../../package-structure-code/intro.md:136
msgid ""
"Align our suggestions with the most current, accepted [PEPs (Python "
"Enhancement Protocols)](https://peps.python.org/pep-0000/) and the "
"[Scientific Python community SPECs](https://scientific-"
"python.org/specs/)."
msgstr ""
"私たちの提案を、現在受け入れられている [PEPs (Python Enhancement "
"Protocols)](https://peps.python.org/pep-0000/) と [Scientific Python "
"community SPECs](https://scientific-python.org/specs/) に合わせます。"

#: ../../package-structure-code/intro.md:139
msgid ""
"In an effort to maintain consistency within our community, we also align "
"with existing best practices being implemented by developers of core "
"Scientific Python packages such as Numpy, SciPy and others."
msgstr ""
"私たちのコミュニティ内での一貫性を維持するために、NumpyやSciPyなどのScientific "
"Pythonのコアパッケージの開発者によって実装されている既存のベストプラクティスとも連携しています。"

#: ../../package-structure-code/intro.md:143
msgid "Guidelines for pyOpenSci's packaging recommendations"
msgstr "pyOpenSciのパッケージング推奨のガイドライン"

#: ../../package-structure-code/intro.md:145
msgid ""
"The flexibility of the Python programming language lends itself to a "
"diverse range of tool options for creating a Python package. Python is so"
" flexible that it is one of the few languages that can be used to wrap "
"around other languages. The ability of Python to wrap other languages is "
"one the reasons you will often hear Python described as a [\"glue\" "
"language](https://numpy.org/doc/stable/user/c-info.python-as-glue.html)\""
msgstr ""
"Pythonプログラミング言語の柔軟性は、Pythonパッケージを作成するための多様なツールオプションに適しています。Pythonはとても柔軟で、他の言語を包み込むように使える数少ない言語のひとつです。Pythonが他の言語をラッピングする能力は、Pythonが"
" [\"glue\" language](https://numpy.org/doc/stable/user/c-info.python-as-"
"glue.html)\" と表現されるのをよく耳にする理由の1つです。"

#: ../../package-structure-code/intro.md:151
msgid ""
"If you are building a pure Python package, then your packaging setup can "
"be simple. However, some scientific packages have complex requirements as"
" they may need to support extensions or tools written in other languages "
"such as C or C++."
msgstr "純粋なPythonパッケージを構築するのであれば、パッケージングのセットアップは単純でよいです。しかし、科学的なパッケージの中には、CやC++のような他の言語で書かれた拡張機能やツールをサポートする必要があり、複雑な要件を持つものがあります。"

#: ../../package-structure-code/intro.md:155
msgid ""
"To support the many different uses of Python, there are many ways to "
"create a Python package. In this guide, we suggest packaging approaches "
"and tools based on:"
msgstr ""
"Python の様々な使い方をサポートするために、Python パッケージを作成する方法はたくさんあります。 "
"このガイドでは、パッケージングのアプローチとツールを提案します:"

#: ../../package-structure-code/intro.md:158
msgid ""
"What we think will be best and easiest to adopt for those who are newer "
"to packaging."
msgstr "パッケージングに慣れていない人たちにとって、私たちが最善で最も採用しやすいと考えるもの。"

#: ../../package-structure-code/intro.md:160
msgid "Tools that we think are well maintained and documented."
msgstr "よく整備され、文書化されていると思われるツール。"

#: ../../package-structure-code/intro.md:161
msgid ""
"A shared goal of standardizing packaging approaches across this "
"(scientific) Python ecosystem."
msgstr "この (科学的な) Pythonエコシステム全体でパッケージングアプローチを標準化するという共通の目標。"

#: ../../package-structure-code/intro.md:164
msgid ""
"Here, we also try to align our suggestions with the most current, "
"accepted [Python community](https://packaging.python.org/en/latest/) and "
"[scientific community](https://scientific-python.org/specs/)."
msgstr ""
"ここでは、私たちの提案を、最新の、受け入れられている "
"[Pythonコミュニティ](https://packaging.python.org/en/latest/) と "
"[科学コミュニティ](https://scientific-python.org/specs/) に合わせることも試みています。"

#: ../../package-structure-code/intro.md:167
msgid "Suggestions in this guide are not pyOpenSci review requirements"
msgstr "このガイドの提案はpyOpenSciのレビュー要件ではありません"

#: ../../package-structure-code/intro.md:170
msgid ""
"The suggestions for package layout in this section are made with the "
"intent of being helpful; they are not specific requirements for your "
"package to be reviewed and accepted into our pyOpenSci open source "
"ecosystem."
msgstr ""
"このセクションのパッケージレイアウトの提案は、参考になることを意図しています。 "
"これらは、あなたのパッケージがpyOpenSciオープンソースエコシステムにレビューされ、受け入れられるための特定の要件ではありません。"

#: ../../package-structure-code/intro.md:174
msgid ""
"Please check out our [package scope page](https://www.pyopensci.org"
"/software-peer-review/about/package-scope.html) and [review requirements "
"in our author guide](https://www.pyopensci.org/software-peer-review/how-"
"to/author-guide.html#) if you are looking for pyOpenSci's Python package "
"review requirements!"
msgstr ""
"pyOpenSciのPythonパッケージ審査要件をお探しの方は、 [package scope "
"page](https://www.pyopensci.org/software-peer-review/about/package-"
"scope.html) と [review requirements in our author "
"guide](https://www.pyopensci.org/software-peer-review/how-to/author-"
"guide.html#) をご覧ください！"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:1
msgid "Publishing Your Package In A Community Repository: PyPI or Anaconda.org"
msgstr "コミュニティリポジトリでパッケージを公開する: PyPI または Anaconda.org"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:5
msgid ""
"pyOpenSci requires that your package has an distribution that can be "
"installed from a public community repository such as PyPI or a conda "
"channel such as `bioconda` or `conda-forge` on Anaconda.org."
msgstr ""
"pyOpenSci は、あなたのパッケージが PyPI のようなパブリックコミュニティリポジトリや Anaconda.org の "
"`bioconda` や `conda-forge` のような conda "
"チャンネルからインストールできるディストリビューションを持っていることを要求します。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:9
msgid ""
"Below you will learn more about the various publishing options for your "
"Python package."
msgstr "以下では、Pythonパッケージの様々な公開オプションについて詳しく説明します。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:14
msgid ""
"Installing packages in the same environment using both pip and conda can "
"lead to package conflicts."
msgstr "pipとcondaの両方を使って同じ環境にパッケージをインストールすると、パッケージが競合する可能性があります。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:16
msgid ""
"To minimize conflicts for users who may be using conda (or pip) to manage"
" local environments, consider publishing your package to both PyPI and "
"the conda-forge channel on Anaconda.org."
msgstr ""
"ローカル環境を管理するために conda (または pip) を使用しているかもしれないユーザーの競合を最小にするために、Anaconda.org"
" の PyPI と conda-forge チャンネルの両方にパッケージを公開することを検討してください。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:18
msgid ""
"Below you will learn more specifics about the differences between PyPI "
"and conda publishing of your Python package."
msgstr "以下では、PythonパッケージのPyPI公開とconda公開の違いについて詳しく説明します。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:24
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:6
#, fuzzy
msgid ""
"Image showing the progression of creating a Python package, building it "
"and then publishing to PyPI and conda-forge. You take your code and turn "
"it into distribution files (sdist and wheel) that PyPI accepts. Then "
"there is an arrow towards the PyPI repository where ou publish both "
"distributions. From PyPI if you create a conda-forge recipe you can then "
"publish to conda-forge."
msgstr ""
"Pythonパッケージの作成、ビルド、そしてPyPIとconda-"
"forgeへの公開の流れを示す画像です。あなたのコードをPyPIが受け付ける配布ファイル(sdistとwheel)に変換します。そして、両方のディストリビューションを公開しているPyPIリポジトリへの矢印があります"
"。PyPIからconda-forgeのレシピを作成し、conda-forgeに公開することができます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:26
#, fuzzy
msgid ""
"Once you have published both package distributions (the source "
"distribution and the wheel) to PyPI, you can then publish to conda-forge."
" The conda-forge requires a source distribution on PyPI in order to build"
" your package on conda-forge. You do not need to rebuild your package to "
"publish to conda-forge."
msgstr ""
"両方のパッケージ配布(ソース配布とホイール)をPyPIに公開したら、次にconda-forgeに公開します。conda-"
"forgeでパッケージをビルドするには、PyPIでのソース配布が必要です。conda-"
"forgeに公開するためにパッケージをリビルドする必要はありません。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:29
msgid "What is PyPI"
msgstr "PyPIとは"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:31
msgid ""
"[PyPI](https://pypi.org/) is an online Python package repository that you"
" can use to both find and install and publish your Python package. There "
"is also a test PyPI repository where you can test publishing your package"
" prior to the final publication on PyPI."
msgstr ""
"[PyPI](https://pypi.org/) "
"はオンラインのPythonパッケージリポジトリで、Pythonパッケージの検索やインストール、公開に利用できます。テスト用のPyPIリポジトリもあり、最終的にPyPIで公開する前に、パッケージの公開をテストすることができます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:36
msgid ""
"Many if not most Python packages can be found on PyPI and are thus "
"installable using `pip`."
msgstr "ほとんどのPythonパッケージはPyPIで見つけることができ、 `pip` を使ってインストールすることができます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:38
msgid ""
"The biggest different between using pip and conda to install a package is"
" that conda can install any package regardless of the language(s) that it"
" is written in. Whereas `pip` can only install Python packages."
msgstr ""
"パッケージのインストールにpipを使う場合とcondaを使う場合の最大の違いは、condaは(複数の)言語に関係なくどんなパッケージでもインストールできるということです。"
" 一方、 `pip` は Python パッケージしかインストールできません。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:43
msgid "Click here for a tutorial on publishing your package to PyPI."
msgstr "PyPIへのパッケージ公開のチュートリアルはこちら。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:52
msgid ""
"On the package build page, we discussed the [two package distribution "
"types that you will create when making a Python package](python-package-"
"distribution-files-sdist-wheel): SDist (packaged as a .tar.gz or .zip) "
"and Wheel (.whl) which is really a zip file. Both of those file "
"\"bundles\" will be published on PyPI when you use [a standard build tool"
"](python-package-build-tools) to build your package."
msgstr ""
"パッケージビルドのページで、 [Pythonパッケージを作るときに作成する2つのパッケージ配布タイプ](python-package-"
"distribution-files-sdist-wheel) について説明しました: SDist "
"(.tar.gzまたは.zipとしてパッケージ化) とWheel (.whl) は、実際にはzipファイルです。 [標準ビルドツール"
"](python-package-build-tools) を使ってパッケージをビルドすると、これらのファイル \"バンドル\" "
"は両方ともPyPIで公開されます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:60
msgid "What is conda and Anaconda.org?"
msgstr "condaとAnaconda.orgとは？"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:62
msgid ""
"conda is an open source package and environment management tool. conda "
"can be used to install tools from the [Anaconda "
"repository](https://repo.anaconda.com/)."
msgstr ""
"condaはオープンソースのパッケージと環境管理ツールです。condaは "
"[Anacondaリポジトリ](https://repo.anaconda.com/) からツールをインストールするために使用できます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:66
msgid ""
"Anaconda.org contains public and private repositories for packages. These"
" repositories are known as channels (discussed below)."
msgstr ""
"Anaconda.org にはパッケージのためのパブリックとプライベートのリポジトリがあります。 "
"これらのリポジトリはチャンネルとして知られています（後述）。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:69
msgid "A brief history of conda's evolution"
msgstr "condaの進化の簡単な歴史"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:72
msgid ""
"The conda ecosystem evolved years ago to provide support for, and "
"simplify the process of, managing software dependencies in scientific "
"Python projects."
msgstr "condaエコシステムは、科学的なPythonプロジェクトにおけるソフトウェアの依存関係を管理するためのサポートを提供し、そのプロセスを簡素化するために数年前に発展しました。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:76
msgid ""
"Many of the core scientific Python projects depend upon or wrap around "
"tools and extensions that are written in other languages, such as C++. In"
" the early stages of the scientific ecosystem's development, these non-"
"Python extensions and tools were not well supported on PyPI, making "
"publication difficult. In recent years there is more support for complex "
"builds that allow developers to bundle non-Python code into a Python "
"distribution using the [wheel distribution format](python-wheel)."
msgstr ""
"科学的なPythonプロジェクトのコアの多くは、C++などの他の言語で書かれたツールや拡張機能に依存したり、その周りを取り巻いたりしています。科学エコシステムの開発の初期段階では、これらのPython以外の拡張機能やツールはPyPIで十分にサポートされておらず、公開が困難でした。近年、開発者が"
" [wheel distribution format](python-wheel) "
"を使ってPython以外のコードをPythonディストリビューションにバンドルできるような、複雑なビルドのサポートが増えました。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:78
msgid ""
"Conda provides a mechanism to manage these dependencies and ensure that "
"the required packages are installed correctly."
msgstr "Condaは、これらの依存関係を管理し、必要なパッケージが正しくインストールされるようにするメカニズムを提供します。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:82
msgid ""
"While conda was originally created to support Python packages, it is now "
"used across all languages. This cross-language support makes it easier "
"for some packages to include and have access to tools written in other "
"languages, such as C/C++ (gdal), Julia, or R. Creating an environment "
"that mixes all of these packages is usually easier and more consistent "
"with full-fledged package managers like conda."
msgstr ""
"condaはもともとPythonのパッケージをサポートするために作られたが、今ではあらゆる言語で使われています。この言語間サポートにより、C/C++"
" (gdal) "
"、Julia、Rなど、他の言語で書かれたツールを簡単に取り込んだり、利用したりできるパッケージもあります。これらのパッケージをすべてミックスした環境を作るのは、通常、condaのような本格的なパッケージマネージャを使った方が簡単で、一貫性があります。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:90
msgid "conda channels"
msgstr "condaチャンネル"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:92
msgid ""
"conda built packages are housed within repositories that are called "
"channels. The conda package manager can install packages from different "
"channels."
msgstr ""
"condaでビルドされたパッケージは、チャンネルと呼ばれるリポジトリに格納されます。 "
"condaパッケージマネージャは異なるチャンネルからパッケージをインストールすることができます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:95
msgid ""
"There are several core public channels that most people use to install "
"packages using conda, including:"
msgstr "多くの人がcondaを使ってパッケージをインストールする際に使う、いくつかのコアなパブリックチャンネルがあります:"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:98
msgid ""
"**defaults:** this is a channel managed by Anaconda. It is the version of"
" the Python packages that you will install if you install the Anaconda "
"Distribution. Anaconda (the company) decides what packages live on the "
"`defaults` channel."
msgstr ""
"**defaults:** これは Anaconda が管理するチャンネルです。 Anaconda "
"ディストリビューションをインストールするとインストールされる Python パッケージのバージョンです。 どのパッケージが `defaults` "
"チャンネルにあるかは Anaconda (会社) が決定します。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:99
#, fuzzy
msgid ""
"[**conda-forge:**](https://conda-forge.org/) this is a community-driven "
"channel that focuses on scientific packages. This channel is ideal for "
"tools that support geospatial data. Anyone can publish a package to this "
"channel."
msgstr ""
"[**conda-forge:**](https://anaconda.org/conda-forge) "
"このチャンネルは科学的なパッケージに焦点を当てたコミュニティ主導のチャンネルです。 このチャンネルは地理空間データをサポートするツールに最適です。"
" 誰でもこのチャンネルにパッケージを公開できます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:100
#, fuzzy
msgid ""
"[**bioconda**](https://bioconda.github.io/): this channel focuses on "
"biomedical tools."
msgstr "[**bioconda**](https://anaconda.org/bioconda): このチャンネルは生物医学ツールに焦点を当てています。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:102
msgid ""
"**conda-forge** emerged as many of the scientific packages did not exist "
"in the `defaults` Anaconda channel."
msgstr "科学的パッケージの多くが `defaults` Anaconda チャンネルに存在しなかったため、**conda-forge** が出現しました。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:107
#, fuzzy
msgid ""
"Graphic with the title Python package repositories. Below it says "
"Anything hosted on PyPI can be installed using pip install. Packaging "
"hosted on a conda channel can be installed using conda install. Below "
"that there are two rows. The top row says conda channels. Next to it are "
"three boxes one with conda-forge, community maintained; bioconda and then"
" default - managed by the anaconda team. Below that there is a row that "
"says PyPI servers. PyPI - anyone can publish to PyPI. And test PyPI. A "
"testbed server for you to practice."
msgstr ""
"Python package repositoriesというタイトルのグラフィック。 PyPI でホストされているものは pip install "
"でインストールできます。 condaチャンネルでホストされているパッケージはconda installを使ってインストールできます。 "
"その下に2つの行があり、一番上の行には conda channels と書かれています。その隣には3つのボックスがあり、1つは conda-"
"forge、コミュニティによって管理されているもの、bioconda、そして default - anaconda "
"チームによって管理されているものです。 その下にPyPIサーバーという行があります。 PyPI - "
"誰でもPyPIに公開することができます、とPyPIをテストするためのテストベッドサーバ。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:109
msgid ""
"Conda channels represent various repositories that you can install "
"packages from. Because conda-forge is community maintained, anyone can "
"submit a recipe there. PyPI is also a community maintained repository. "
"Anyone can submit a package to PyPI and test PyPI. Unlike conda-forge "
"there are no manual checks of packages submitted to PyPI."
msgstr ""
"Condaチャンネルは、パッケージをインストールできる様々なリポジトリです。 conda-forge "
"はコミュニティによって管理されているため、誰でもレシピを投稿することができます。 PyPIもコミュニティによって管理されているリポジトリです。 "
"誰でもPyPIにパッケージを投稿し、PyPIをテストすることができます。 conda-forge とは異なり、PyPI "
"に投稿されたパッケージを手動でチェックすることはありません。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:113
msgid "conda channels, PyPI, conda, pip - Where to publish your package"
msgstr "conda channels, PyPI, conda, pip - パッケージを公開する場所"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:115
msgid ""
"You might be wondering why there are different package repositories that "
"can be used to install Python packages."
msgstr "なぜPythonパッケージをインストールするのに様々なパッケージリポジトリがあるのか不思議に思うかもしれません。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:118
msgid ""
"And more importantly you are likely wondering how to pick the right "
"repository to publish your Python package."
msgstr "さらに重要なことは、Pythonパッケージを公開するのに適切なリポジトリをどのように選べばいいのか悩んでいることでしょう。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:121
msgid "The answer to both questions relates dependency conflicts."
msgstr "どちらの質問に対する答えも、依存関係のコンフリクトに関係しています。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:125
msgid ""
"Image showing an XKCD comic that shows a web of Python environments and "
"tools and installations. At the bottom is says -  My python environment "
"has become so degraded that my laptop has been declared a superfund site."
msgstr ""
"画像はXKCDのコミックで、Pythonの環境とツール、インストールの網を描いています。一番下にはこう書いてあります - "
"私のパイソン環境は劣化しすぎて、私のラップトップはスーパーファンドサイトに指定された。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:127
msgid ""
"Installing Python and Python packages from different repositories can "
"lead to environment conflicts where a version of on package doesn't work "
"with a version of another package. To keep your environments clean and "
"working, it's best to install packages from the same repository. So use "
"pip to install everything. Or use conda. If you can, try to avoid "
"installing package from both pip and conda into the same environment."
msgstr ""
"Python と Python "
"パッケージを異なるリポジトリからインストールすると、あるバージョンのパッケージが別のパッケージのバージョンと動作しないといった環境の衝突につながる可能性があります。"
" 環境をクリーンに保ち、動作させるためには、同じリポジトリからパッケージをインストールするのがベストです。 "
"そのため、pipを使ってすべてをインストールする。 あるいはcondaを使う。 "
"できることなら、pipとcondaの両方のパッケージを同じ環境にインストールしないようにしましょう。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:135
msgid "Managing Python package dependency conflicts"
msgstr "Pythonパッケージの依存関係の競合を管理する"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:137
msgid ""
"Python environments can encounter conflicts because Python tools can be "
"installed from different repositories. Broadly speaking, Python "
"environments have a smaller chance of dependency conflicts when the tools"
" are installed from the same package repository. Thus environments that "
"contain packages installed from both pip and conda are more likely to "
"yield dependency conflicts."
msgstr ""
"Python環境は、Pythonツールが異なるリポジトリからインストールされることがあるため、競合に遭遇する可能性があります。 "
"大まかに言えば、Python環境は、ツールが同じパッケージリポジトリからインストールされるとき、依存関係の衝突の可能性が小さくなります。 "
"そのため、pip と conda の両方からインストールされたパッケージを含む環境は、依存関係の衝突が起こりやすくなります。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:144
#, fuzzy
msgid ""
"Similarly installing packages from the default anaconda channel mixed "
"with the conda-forge channel can also lead to dependency conflicts."
msgstr ""
"同様に、デフォルトの anaconda パッケージと conda-forge "
"チャンネルを混ぜてパッケージをインストールすることも依存関係の衝突につながります。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:146
msgid ""
"Many install packages directly from conda `defaults` channel. However, "
"because this channel is managed by Anaconda, the packages available on it"
" are limited to those that Anaconda decides should be core to a stable "
"installation. The conda-forge channel was created to complement the "
"`defaults` channel. It allows anyone to submit a package to be published "
"in the channel . Thus, `conda-forge` channel ensures that a broad suite "
"of user-developed community packages can be installed from conda."
msgstr ""
"多くのパッケージは conda `defaults` チャンネルから直接インストールします。 しかし、このチャンネルは Anaconda "
"によって管理されているため、このチャンネルで利用可能なパッケージは、Anaconda "
"が安定したインストールの中核となるべきと判断したものに限定されます。 conda-forge チャンネルは `defaults` "
"チャンネルを補完するために作成されました。 誰でもこのチャンネルで公開するパッケージを投稿することができます。 このように、 `conda-"
"forge` チャネルは、ユーザが開発したコミュニティパッケージの広範なスイートを conda からインストールできるようにします。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:150
msgid ""
"Take-aways: If you can, publish on both PyPI and conda-forge to "
"accommodate more users of your package"
msgstr "教訓: 可能であれば、PyPI と conda-forge の両方で公開し、より多くのユーザがあなたのパッケージを利用できるようにしましょう。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:152
msgid ""
"The take-away here for maintainers is that if you anticipate users "
"wanting to use conda to manage their local environments (which many do), "
"you should consider publishing to both PyPI and the conda-forge channel "
"(_more on that below_)."
msgstr ""
"メンテナにとって重要なことは、もしユーザがローカル環境の管理にcondaを使いたいと考えているのであれば（多くのユーザがそうしている"
"）、PyPIとconda-forge channelの両方に公開することを検討すべきだということです (_詳しくは後述します) 。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:157
msgid "Additional resources"
msgstr "その他のリソース"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:158
msgid ""
"[learn more about why conda-forge was created, here](https://conda-"
"forge.org/docs/user/introduction.html)"
msgstr ""
"[conda-forgeがなぜ作られたのか、詳しくはこちら](https://conda-"
"forge.org/docs/user/introduction.html)"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:160
msgid ""
"[To learn more about conda terminology, check out their "
"glossary.](https://docs.conda.io/projects/conda/en/latest/glossary.html )"
msgstr ""
"[condaの用語についてもっと知りたい方は、用語集をご覧ください。](https://docs.conda.io/projects/conda/en/latest/glossary.html"
" )"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:165
msgid "How to submit to conda-forge"
msgstr "conda-forgeへの投稿方法"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:167
msgid ""
"While pyOpenSci doesn't require you to add your package to conda-forge, "
"we encourage you to consider doing so!"
msgstr "pyOpenSciはあなたのパッケージをconda-forgeに追加する必要はありませんが、追加することを検討することを推奨します！"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:170
msgid ""
"Once your package is on PyPI, the process to add your package to conda-"
"forge is straight forward to do. [You can follow the detailed steps "
"provided by the conda-forge maintainer team.](https://conda-"
"forge.org/docs/maintainer/adding_pkgs.html)."
msgstr ""
"パッケージが PyPI に登録されたら、conda-forge にパッケージを追加する手順は簡単です。 [conda-forge "
"メンテナチームが提供している詳細な手順に従うことができます](https://conda-"
"forge.org/docs/maintainer/adding_pkgs.html) 。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:175
msgid "Click here for a tutorial on adding your package to conda-forge."
msgstr "conda-forgeにパッケージを追加するチュートリアルはこちらをご覧ください。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:182
msgid "If you want a step by step tutorial, click here."
msgstr "ステップバイステップのチュートリアルをご覧になりたい方は、こちらをクリックしてください。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:185
msgid ""
"Once your package is added, you will have a feedstock repository on "
"GitHub with your packages name"
msgstr "パッケージが追加されると、GitHub の feedstock リポジトリにパッケージ名が追加されます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:188
msgid ""
"[Here is an example conda-forge feedstock for the pyOpenSci approved "
"package - movingpandas](https://github.com/conda-forge/movingpandas-"
"feedstock)"
msgstr ""
"[pyOpenSci承認パッケージ - movingpandas のconda-"
"forgeフィードストックの例です](https://github.com/conda-forge/movingpandas-feedstock)"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:191
msgid "Maintaining your conda-forge package repository"
msgstr "conda-forge パッケージリポジトリの管理"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:193
msgid ""
"Once your package is on the conda-forge channel, maintaining it is "
"simple. Every time that you push a new version of your package to PyPI, "
"it will kick off a continuous integration build that updates your package"
" in the conda-forge repository. Once that build is complete, you will get"
" a notification to review the update."
msgstr ""
"いったんあなたのパッケージが conda-forge チャンネルに登録されれば、それを維持するのは簡単です。 新しいバージョンのパッケージを "
"PyPI にプッシュするたびに、conda-forge リポジトリのパッケージを更新する継続的インテグレーションビルドが開始されます。 "
"ビルドが完了すると、更新を確認するための通知が届きます。"

#: ../../package-structure-code/publish-python-package-pypi-conda.md:199
msgid ""
"You can merge the pull request for that update once you are happy with "
"it. A ready-to-merge PR usually means ensuring that your project's "
"dependencies (known as runtime requirements) listed in the updated YAML "
"file found in the pull request match the PyPI metadata of the new "
"release."
msgstr ""
"プルリクエストの内容に満足したら、プルリクエストをマージすることができます。 "
"すぐにマージできるPRとは、通常、プルリクエストにある更新されたYAMLファイルに記載されているあなたのプロジェクトの依存関係（実行時要件として知られています）が、新しいリリースのPyPIメタデータと一致していることを確認することです。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:1
msgid "Use a pyproject.toml file for your package configuration & metadata"
msgstr "パッケージの設定とメタデータにはpyproject.tomlファイルを使用します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:10
msgid "Important pyproject.toml take aways"
msgstr "pyproject.tomlから得られる重要なこと"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:14
msgid ""
"There are only two tables that are required for an installable Python "
"package: **[build-system]** and **[project]**. The **[project]** table "
"stores your package's metadata."
msgstr ""
"インストール可能なPythonパッケージに必要なテーブルは2つだけです: **[build-system]** と **[project]** "
"です。 **[project]** テーブルにはパッケージのメタデータが格納されます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:15
msgid ""
"There are only two _required_ fields in the **[project]** table: "
"**name=** and **version=**."
msgstr "**[project]** テーブルの必須フィールドは2つだけです: **name=**と **version=** です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:16
msgid ""
"We suggest you add additional metadata to your `pyproject.toml` file as "
"it will make it easier for users to find your project on PyPI."
msgstr ""
"`pyproject.toml` ファイルにメタデータを追加することをお勧めします。 "
"そうすることで、ユーザがPyPIであなたのプロジェクトを見つけやすくなります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:17
msgid ""
"When you are adding classifiers to the [project] table, only use valid "
"values from [PyPI’s classifier page](https://PyPI.org/classifiers/). An "
"invalid value here will raise an error when you build your package or "
"publish to PyPI."
msgstr ""
"[project] テーブルに分類を追加するときは、 [PyPIの分類ページ](https://PyPI.org/classifiers/) "
"にある有効な値のみを使用してください。 ここで無効な値を指定すると、パッケージをビルドするときやPyPIに公開するときにエラーが発生します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:18
msgid ""
"There is no specific order for tables in the `pyproject.toml` file. "
"However fields need to be placed within the correct table sections. For "
"example `requires =` always need to be associated with the **[build-"
"system]** table."
msgstr ""
"`pyproject.toml` ファイル内のテーブルには特定の順番はありません。 "
"しかし、フィールドは正しいテーブルセクションに配置する必要があります。 例えば `requires =` は常に **[build-"
"system]** テーブルと関連付ける必要があります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:19
msgid ""
"**python-requires**: is important to have in your `pyproject.toml` file "
"as it helps pip install your package."
msgstr ""
"**python-requires**: `pyproject.toml`ファイルに記述することが重要です。 "
"これはpipがパッケージをインストールするのに役立つからです。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:24
msgid "when these are published, remove this todo"
msgstr "これらが公開されたら、このtodoを削除します"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:33
msgid ""
"Need help creating your pyproject.toml file?  This tutorial will walk you"
" through the process."
msgstr "pyproject.tomlファイルの作成にヘルプが必要ですか？ このチュートリアルはそのプロセスを説明します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:47
msgid ""
"Click here if need help migrating from setup.py/setup.cfg to "
"pyproject.toml"
msgstr "setup.py/setup.cfg から pyproject.toml への移行にヘルプが必要な場合はここをクリックしてください。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:57
msgid "About the pyproject.toml file"
msgstr "pyproject.tomlファイルについて"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:59
msgid ""
"Every modern Python package should include a `pyproject.toml` file. If "
"your project is pure Python and you're using a `setup.py` or `setup.cfg` "
"file to describe its metadata, you should consider migrating your "
"metadata and build information to a `pyproject.toml` file."
msgstr ""
"最近の Python パッケージには `pyproject.toml` ファイルが含まれているはずです。 もしあなたのプロジェクトが純粋な "
"Python で、メタデータを記述するために `setup.py` や `setup.cfg` ファイルを使っているなら、メタデータとビルド情報を"
" `pyproject.toml` ファイルに移行することを検討するべきです。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:61
msgid ""
"If your project isn’t pure-python, you might still require a `setup.py` "
"file to build the non Python extensions. However, a `pyproject.toml` file"
" should still be used to store your project’s metadata."
msgstr ""
"あなたのプロジェクトが純粋な Python でない場合、Python 以外の拡張機能をビルドするために `setup.py` "
"ファイルが必要になるかもしれません。 しかし、プロジェクトのメタデータを保存するために `pyproject.toml` "
"ファイルを使用する必要があります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:63
msgid "What happened to setup.py & how do i migrate to pyproject.toml?"
msgstr "setup.pyに何が起こったのか、そしてどのようにpyproject.tomlに移行するのか？"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:65
msgid ""
"Prior to August 2017, Python package metadata was stored either in the "
"`setup.py` file or a `setup.cfg` file. In recent years, there has been a "
"shift to storing Python package metadata in a much more user-readable "
"`pyproject.toml` format. Having all metadata in a single file:"
msgstr ""
"2017年8月以前は、Pythonパッケージのメタデータは `setup.py` ファイルか `setup.cfg` "
"ファイルに保存されていました。 近年、Python パッケージのメタデータは、よりユーザが読みやすい `pyproject.toml` "
"フォーマットで保存されるようになりました。 すべてのメタデータを1つのファイルに持つことです:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:67
msgid "simplifies package management,"
msgstr "パッケージ管理を簡素化します、"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:68
msgid ""
"allows you to use a suite of different [build "
"backends](https://www.pyopensci.org/python-package-guide/package-"
"structure-code/python-package-build-tools.html#build-back-ends) such as "
"(flit-core, hatchling, pdm-build), and"
msgstr ""
"(flit-core, hatchling, pdm-build)のような一連の異なる "
"[ビルドバックエンド](https://www.pyopensci.org/python-package-guide/package-"
"structure-code/python-package-build-tools.html#build-back-ends) "
"を使うことができます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:69
msgid "aligns with modern best practices."
msgstr "現代のベストプラクティスに合致しています。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:76
msgid ""
"The standard file that Python packages use to [specify build requirements"
" and metadata is called a "
"**pyproject.toml**](https://packaging.python.org/en/latest/specifications"
"/declaring-project-metadata/). Adding metadata, build requirements and "
"package dependencies to a **pyproject.toml** file replaces storing that "
"information in a setup.py or setup.cfg file."
msgstr ""
"Python パッケージが [ビルド要件とメタデータを指定するために使う標準のファイルは **pyproject.toml** "
"と呼ばれます](https://packaging.python.org/en/latest/specifications/declaring-"
"project-metadata/) 。メタデータ、ビルド要件、パッケージの依存関係を **pyproject.toml** "
"ファイルに追加することは、 setup.py や setup.cfg ファイルに情報を格納することに取って代わります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:81
msgid "About the .toml format"
msgstr ".toml フォーマットについて"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:83
msgid ""
"The **pyproject.toml** file is written in [TOML (Tom's Obvious, Minimal "
"Language) format](https://toml.io/en/). TOML is an easy-to-read structure"
" that is founded on key/value pairs. Each section in the "
"**pyproject.toml** file contains a `[table identifier]`. Below that table"
" identifier are key/value pairs that support configuration for that "
"particular table."
msgstr ""
"**pyproject.toml**ファイルは [TOML(Tom's Obvious, Minimal "
"Language)フォーマット](https://toml.io/en/) で書かれています。 "
"TOMLは読みやすい構造で、キーと値のペアで成り立っています。 **pyproject.toml** ファイルの各セクションは "
"`[テーブル識別子]` を含んでいます。 そのテーブル識別子の下には、その特定のテーブルの設定をサポートするキーと値のペアがあります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:87
msgid "Below `[build-system]` is considered a table in the toml language."
msgstr "`[build-system]` 以下はtoml言語ではテーブルとみなされます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:88
msgid "Within the `build-system` table below `requires =` is a key."
msgstr "以下の `build-system` テーブルの中で `requires =` がキーです。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:89
msgid ""
"The associated value for `requires` is an array containing the value "
"`\"hatchling\"`."
msgstr "`requires` に関連する値は、値 `\"hatchling\"` を含む配列です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:97
msgid "How the pyproject.toml is used when you build a package"
msgstr "パッケージのビルド時にpyproject.tomlがどのように使用されるか"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:101
msgid ""
"When you publish to PyPI, you will notice that each package has metadata "
"listed. Let’s have a look at [xclim](https://pypi.org/project/xclim/), "
"one of our [pyOpenSci packages](https://www.pyopensci.org/python-"
"packages.html). Notice that on the PyPI landing page you see some "
"metadata about the package including python, maintainer information and "
"more. PyPI is able to populate this metadata because it was defined using"
" correct syntax and classifiers by Xclim's maintainers, [pyproject.toml "
"file](https://github.com/Ouranosinc/xclim/blob/master/pyproject.toml). "
"This metadata when the xclim package is built, is translated into a "
"distribution file that allows PyPI to read the metadata and print it out "
"on their website."
msgstr ""
"PyPIに公開すると、各パッケージにメタデータがリストされていることに気づくでしょう。[pyOpenSciパッケージ](https://www.pyopensci.org"
"/python-packages.html) の一つである [xclim](https://pypi.org/project/xclim/) "
"を見てみましょう。PyPIのランディングページには、pythonやメンテナ情報など、パッケージに関するメタデータが表示されていることに注目してください。PyPIは、Xclimのメンテナ"
" [pyproject.toml "
"file](https://github.com/Ouranosinc/xclim/blob/master/pyproject.toml) "
"によって正しい構文と分類子を用いて定義されたメタデータを入力することができます。xclimパッケージがビルドされるとき、このメタデータは配布ファイルに変換され、PyPIがメタデータを読み込んでウェブサイトに出力できるようになります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:103
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:83
msgid ""
"Image showing the left side bar of PyPI for the package xclim. The "
"section at the top says Classifier. Below there is a list of items "
"including Development status, intended audience, License, natural "
"language, operating system, programming language and topic. Below each of"
" those sections are various classifier options.\" width=\"300px\">"
msgstr ""
"xclimパッケージのPyPI左サイドバーの画像です。一番上のセクションにはClassifierとあります。その下に、開発状況、対象読者、ライセンス、自然言語、オペレーティングシステム、プログラミング言語、トピックなどの項目があります。"
" これらの各セクションの下には、さまざまな分類オプションがあります。 \" width=\"300px\">"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:108
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:88
msgid ""
"When you add the classifier section to your pyproject.toml and your "
"package is built, the build tool organizes the metadata into a format "
"that PyPI can understand and represent on your PyPI landing page. These "
"classifiers also allow users to sort through packages by version of "
"python they support, categories and more."
msgstr ""
"pyproject.tomlにclassifierセクションを追加してパッケージがビルドされると、ビルドツールはメタデータをPyPIが理解できる形式に整理し、PyPIのランディングページに表示します。"
" これらの分類子により、ユーザはサポートするpythonのバージョンやカテゴリなどでパッケージをソートすることもできます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:113
msgid "Benefits of using a pyproject.toml file"
msgstr "pyproject.tomlファイルを使用する利点"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:115
msgid ""
"Including your package's metadata in a separate human-readable "
"**pyproject.toml** format also allows someone to view the project's "
"metadata in a GitHub repository."
msgstr ""
"パッケージのメタデータを人間が読める **pyproject.toml** "
"形式で含めると、GitHubのリポジトリでプロジェクトのメタデータを見ることができます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:123
msgid "Setup.py is still useful for complex package builds"
msgstr "Setup.py は、複雑なパッケージのビルドに便利です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:127
msgid ""
"Using **setup.py** to manage package builds and metadata [can cause "
"problems with package "
"development](https://blog.ganssle.io/articles/2021/10/setup-py-"
"deprecated.html). In some cases where a Python package build is complex, "
"a **setup.py** file may be required. While this guide will not cover "
"complex builds, we will provide resources working with complex builds in "
"the future."
msgstr ""
"パッケージのビルドとメタデータを管理するために **setup.py** を使うことは  "
"[パッケージ開発に問題を引き起こす可能性があります](https://blog.ganssle.io/articles/2021/10"
"/setup-py-deprecated.html) 。 Python パッケージのビルドが複雑な場合、**setup.py** "
"ファイルが必要になるかもしれません。 このガイドでは複雑なビルドは扱いませんが、将来的には複雑なビルドを扱うリソースを提供する予定です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:133
msgid "Optional vs. Required pyproject.toml file fields"
msgstr "pyproject.toml ファイルのフィールドの任意と必須"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:135
msgid ""
"When you create your `pyproject.toml` file, there are numerous metadata "
"fields that you can use. Below we suggest specific fields to get you "
"started that support publication on PyPI and users finding your package."
msgstr ""
"`pyproject.toml` ファイルを作成するとき、使用できるメタデータフィールドがたくさんあります。 以下では、PyPI "
"での公開とユーザがあなたのパッケージを見つけることをサポートする、特定のフィールドを提案します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:137
msgid ""
"[An overview of all of the project metadata elements can be found "
"here.](https://packaging.python.org/en/latest/specifications/core-"
"metadata/#project-url-multiple-use)"
msgstr ""
"[プロジェクトの全メタデータ要素の概要は、こちらをご覧ください。](https://packaging.python.org/en/latest/specifications"
"/core-metadata/#project-url-multiple-use)"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:139
#, fuzzy
msgid "Required fields for the `[project]` table"
msgstr "[project] テーブルの必須フィールド"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:141
#, fuzzy
msgid ""
"As mentioned above, your `pyproject.toml` file needs to have a **`name`**"
" and **`version`** field in order to properly build your package:"
msgstr ""
"上述したように、 pyproject.toml ファイルはパッケージを適切にビルドするために **name** と **version** "
"フィールドを持つ必要があります:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:143
#, fuzzy
msgid "`name`: This is the name of your project provided as a string"
msgstr "Name: プロジェクトの名前を文字列で指定します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:144
#, fuzzy
msgid ""
"`version`: This is the version of your project. If you are using a SCM "
"tool for versioning (using git tags to determine versions), then the "
"version may be dynamic (more on that below)."
msgstr ""
"Version: プロジェクトのバージョンです。 バージョン管理に scm ツール (git タグを使用してバージョンを決定する) "
"を使用している場合は、このバージョンは動的なものになります (詳細は後述します)。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:146
msgid "Optional fields to include in the `[project]` table"
msgstr "`[project]` テーブルに含めるオプションフィールド"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:148
msgid ""
"We strongly suggest that you also add the metadata keys below as they "
"will help users finding your package on PyPI. These fields will make it "
"clear how your package is structured, what platforms you support and what"
" dependencies your package requires."
msgstr ""
"以下のメタデータキーも追加することを強くお勧めします。 "
"これらのフィールドを追加することで、あなたのパッケージがどのような構造になっているのか、どのプラットフォームをサポートしているのか、どのような依存関係が必要なのかを明確にすることができます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:153
msgid "**Description:** this is a short one-line description of your package."
msgstr "**Description:** これはあなたのパッケージの短い一行説明です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:154
msgid ""
"**Readme:** A link to your README.md file is used for the long long-"
"description. This information will be published on your packages PyPI "
"landing page."
msgstr ""
"**Readme:** 長い長い説明には README.md ファイルへのリンクが使われます。 "
"この情報はあなたのパッケージのPyPIランディングページで公開されます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:155
msgid ""
"**Requires-python** (used by pip): this is a field that is used by pip. "
"Here you tell the installer whether you are using Python 2.x or 3.x. Most"
" projects will be using 3.x."
msgstr ""
"**Requires-python** (pipで使用): これはpipが使用するフィールドです。 ここでは、Python "
"2.xと3.xのどちらを使っているかをインストーラに伝えます。 ほとんどのプロジェクトは3.xを使うでしょう。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:156
msgid "**License:** the license you are using"
msgstr "**ライセンス:** 使用しているライセンス"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:157
msgid ""
"**Authors:** these are the original authors of the package. Sometimes the"
" authors are different from the maintainers. Other times they might be "
"the same."
msgstr "**Authors:** パッケージの原作者です。 作者がメンテナと異なることもあります。 また、同じ場合もあります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:158
msgid ""
"**Maintainers:** you can choose to populate this or not. You can populate"
" this using a list with a sub element for each author or maintainer name,"
" email"
msgstr ""
"**Maintainers:** これを入力するかどうかを選択できます。 "
"各作者やメンテナーの名前、Eメール、メールアドレスなどのサブ要素を持つリストを使って、この情報を入力することができます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:166
msgid ""
"**dependencies:** dependencies are optional but we strongly suggest you "
"include them in your pyproject.toml. Dependencies will be installed by "
"pip when your project is installed creating a better user-experience."
msgstr ""
"**dependencies:** 依存関係はオプションですが、pyproject.tomlに含めることを強く推奨します。 "
"依存関係はプロジェクトがインストールされるときにpipによってインストールされ、より良いユーザーエクスペリエンスを提供します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:168
msgid ""
"**`[project.optional-dependencies]`:** the optional or development "
"dependencies will be installed if someone runs `python -m pip install "
"projectname[dev]`. This is a nice way to include your development "
"dependencies for users who may wish to contribute to your project."
msgstr ""
"**`[project.optional-dependencies]`:** 誰かが `python -m pip install "
"projectname[dev]` を実行したときに、オプションまたは開発用の依存パッケージがインストールされます。 "
"これは、あなたのプロジェクトに貢献したいユーザのために、開発用の依存関係を含める良い方法です。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:170
msgid ""
"**keywords:** These are the keywords that will appear on your PyPI "
"landing page. Think of them as words that people might use to search for "
"your package."
msgstr ""
"**keywords:** これらはPyPIのランディングページに表示されるキーワードです。 "
"人々があなたのパッケージを検索するときに使う言葉だと考えてください。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:171
msgid ""
"**classifiers:** The classifiers section of your metadata is also "
"important for the landing page of your package in PyPI and for filtering "
"of packages in PyPI. A list of [all options for classifiers can be found "
"her](https://PyPI.org/classifiers/)e. Some of the classifiers that you "
"should consider including"
msgstr ""
"**classifiers:** "
"メタデータのclassifiersセクションは、PyPIでのパッケージのランディングページや、PyPIでのパッケージのフィルタリングにも重要です。"
" [分類子の全オプションはこちらです](https://PyPI.org/classifiers/) 。 "
"以下のようなクラシファイアを検討する必要があります。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:172
msgid "Development Status"
msgstr "開発状況"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:173
msgid "Intended Audience"
msgstr "対象読者"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:174
msgid "Topic"
msgstr "トピック"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:175
#, fuzzy
msgid "License"
msgstr "LIcense"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:176
msgid "Programming language"
msgstr "プログラミング言語"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:178
msgid "Advanced options in the pyproject.toml file"
msgstr "pyproject.tomlファイルの高度なオプション"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:180
msgid "The examples at the bottom of this page contain ..."
msgstr "このページの下にある例には ..."

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:182
msgid ""
"**`[project.scripts]` (Entry points):** Entry points are optional. If you"
" have a command line tool that runs a specific script hosted in your "
"package, you may include an entry point to call that script directly at "
"the command line (rather than at the Python shell)."
msgstr ""
"**`[project.scripts]` (Entry points):** エントリーポイントは任意です。 "
"パッケージでホストされている特定のスクリプトを実行するコマンドラインツールがある場合、そのスクリプトを(Pythonシェルではなく)コマンドラインで直接呼び出すためのエントリポイントを含めることができます"
" 。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:184
#, fuzzy
msgid ""
"Here is an example of[a package that has entry point "
"script](https://github.com/pyOpenSci/pyosMeta/blob/main/pyproject.toml#L60)s."
" Notice that there are several core scripts defined in that package that "
"perform sets of tasks. The pyOpenSci is using those scripts to process "
"their metadata."
msgstr ""
"以下は、[エントリーポイントスクリプトを持つパッケージ](https://github.com/pyOpenSci/update-web-"
"metadata/blob/main/pyproject.toml#L60) の例である。 "
"そのパッケージには、一連のタスクを実行するいくつかのコアスクリプトが定義されていることに注目してほしい。 "
"pyOpenSciはこれらのスクリプトを使ってメタデータを処理しています。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:185
#, fuzzy
msgid ""
"**Dynamic Fields:** if you have fields that are dynamically populated. "
"One example of this is if you are using scm / version control based "
"version with tools like `setuptooms_scm`, then you might use the dynamic "
"field, such as version (using scm) **dynamic = [\"version\"]**"
msgstr ""
"**ダイナミックフィールド:** 動的に入力されるフィールドがある場合。 "
"`setuptooms_scm`のようなツールでscm/バージョン管理ベースのバージョンを使用している場合、ダイナミックフィールドを使用することができます。"
" (scmを使用した)バージョンなど **dynamic = [\"version\"]**"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:187
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Add dependencies to your pyproject.toml file"
msgstr "pyproject.tomlファイルに依存関係を追加"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:189
msgid ""
"The pyproject.toml file can also be used as a replacement for the "
"requirements.txt file which has been traditionally used to store "
"development dependencies such as pytest, code formatters such as Black "
"and documentation tools such as sphinx."
msgstr "pyproject.tomlファイルは、従来pytestのような開発依存ファイル、Blackのようなコードフォーマッタ、sphinxのようなドキュメントツールを保存するために使われてきたrequirements.txtファイルの代わりとして使うこともできます。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:191
msgid ""
"To add dependencies to your build, add a `[project.optional-"
"dependencies]` table to your pyproject.toml file."
msgstr ""
"ビルドに依存関係を追加するには、 `[project.optional-dependencies]` "
"テーブルをpyproject.tomlファイルに追加します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:193
msgid "Then specify dependency groups as follows:"
msgstr "次に、依存グループを以下のように指定する:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:200
msgid "Following the above example, you install dependencies like this:"
msgstr "上記の例に従って、依存関係を次のようにインストールします:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:202
msgid "`python -m pip install -e .[tests]`"
msgstr "`python -m pip install -e .[tests]`"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:204
msgid ""
"The above will install both your package in editable mode and all of the "
"dependencies declared in the tests section of your `[project.optional-"
"dependencies]` table."
msgstr ""
"上記は、編集可能モードのパッケージと、 `[project.optional-dependencies]` "
"テーブルのtestsセクションで宣言されたすべての依存関係の両方をインストールします。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:206
msgid "To install all dependencies and also your package, you'd use:"
msgstr "すべての依存関係をインストールし、あなたのパッケージもインストールするには、次のようにします:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:208
msgid "`python -m pip install -e .[tests,lint,docs]`"
msgstr "`python -m pip install -e .[tests,lint,docs]`"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:210
msgid "Recursive dependencies"
msgstr "再帰的依存関係"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:214
msgid ""
"You can also setup sets of recursive dependencies. [See this blog post "
"for more.](https://hynek.me/articles/python-recursive-optional-"
"dependencies/)"
msgstr ""
"再帰的依存関係のセットをセットアップすることもできます。 [詳しくはこのブログ記事を参照。](https://hynek.me/articles"
"/python-recursive-optional-dependencies/)"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:217
msgid "Example pyproject.toml for building using hatchling"
msgstr "hatchlingを使用してビルドするpyproject.tomlの例"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:219
msgid ""
"Below is an example build configuration for a Python project. This "
"example package setup uses **hatchling** to build the [package's sdist "
"and wheels](python-package-distribution-files-sdist-wheel)."
msgstr ""
"以下は Python プロジェクトのビルド設定の例です。 このパッケージの設定例では、 [パッケージの sdist と wheel"
"](python-package-distribution-files-sdist-wheel) をビルドするのに **hatchling** "
"を使っています。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:227
msgid "Notice that dependencies are specified in this file."
msgstr "このファイルには依存関係が指定されています。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:229
msgid "Example pyproject.toml for building using setuptools"
msgstr "setuptoolsを使ってビルドするpyproject.tomlの例"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:231
msgid ""
"The package metadata including authors, keywords, etc is also easy to "
"read. Below you can see the same TOML file that uses a different build "
"system (setuptools). Notice how simple it is to swap out the tools needed"
" to build this package!"
msgstr ""
"作者やキーワードなどを含むパッケージのメタデータも読みやすいです。 "
"下の図は、異なるビルドシステム(setuptools)を使った同じTOMLファイルです。 "
"このパッケージのビルドに必要なツールを入れ替えるのがいかに簡単かに注目してください！"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:235
msgid "In this example package setup you use:"
msgstr "このパッケージのセットアップ例では:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:237
msgid ""
"**setuptools** to build the [package's sdist and wheels](python-package-"
"distribution-files-sdist-wheel)"
msgstr ""
"[パッケージのsdistとwheel](python-package-distribution-files-sdist-wheel) "
"をビルドするための **setuptools** 。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:238
msgid ""
"**setuptools_scm** to manage package version updates using version "
"control tags"
msgstr "**setuptools_scm** は、バージョン管理タグを使ってパッケージのバージョン更新を管理します。"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:240
msgid ""
"In the example below `[build-system]` is the first table of values. It "
"has two keys that specify the build backend API and containing package:"
msgstr ""
"以下の例では、`[build-system]` が最初の値のテーブルです。 "
"このテーブルには2つのキーがあり、ビルドバックエンドAPIとそれを含むパッケージを指定します:"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:243
msgid "`requires =`"
msgstr "`requires =`"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:244
msgid "`build-back-end =`"
msgstr "`build-back-end =`"

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:251
msgid ""
"[Click here to read about our packaging build tools including PDM, "
"setuptools, Poetry and Hatch.](/package-structure-code/python-package-"
"build-tools)"
msgstr ""
"[PDM、setuptools、Poetry、Hatch などのパッケージビルドツールについてはこちらをご覧ください。](/package-"
"structure-code/python-package-build-tools)"

#: ../../package-structure-code/python-package-build-tools.md:1
msgid "Python Packaging Tools"
msgstr "Pythonパッケージングツール"

#: ../../package-structure-code/python-package-build-tools.md:3
msgid "Tools for building your package"
msgstr "パッケージ構築のためのツール"

#: ../../package-structure-code/python-package-build-tools.md:5
msgid ""
"There are a several different build tools that you can use to [create "
"your Python package's _sdist_ and _wheel_ distributions](python-package-"
"distribution-files-sdist-wheel). Below, we discuss the features, benefits"
" and limitations of the most commonly used Python packaging tools. We "
"focus on pure-python packages in this guide. However, we also highlight "
"tools that currently support packages with C/C++ and other language "
"extensions."
msgstr ""
"[Python パッケージの _sdist_ ディストリビューションと _wheel_ ディストリビューションを作成する](python-"
"package-distribution-files-sdist-wheel) ために使えるビルドツールはいくつかあります。 "
"以下では、最もよく使われる Python パッケージングツールの機能、利点、制限について説明します。 このガイドでは純粋な Python "
"パッケージに焦点を当てます。 しかし、現在C/C++やその他の言語拡張を含むパッケージをサポートしているツールも紹介します。"

#: ../../package-structure-code/python-package-build-tools.md:13
msgid ""
"Decision tree diagram showing the various front and back end packaging "
"tools. You can decide what packaging tool to use by thinking about what "
"features you need. PDM and Hatch are  currently the most flexible tools "
"as they also using different build back-ends. As such currently PDM and "
"Hatch are the tools we think beginners might appreciate most with Poetry "
"being a close second. Poetry is nice for pure Python projects."
msgstr ""
"さまざまなフロントエンドとバックエンドのパッケージングツールを示すデシジョンツリー図。 "
"どのパッケージングツールを使うかは、どんな機能が必要かを考えることで決めることができます。 "
"PDMとHatchは、異なるビルドバックエンドを使用しているため、現在のところ最も柔軟なツールです。 "
"PDMとHatchは初心者に最も喜ばれるツールで、Poetryはその次です。 Poetryは純粋なPythonプロジェクトに適しています。"

#: ../../package-structure-code/python-package-build-tools.md:15
msgid ""
"Diagram showing the different front end build tools available to use in "
"the Python package ecosystem that you can select from. We selected tools "
"to include in this diagram based upon the PyPI survey which helped us "
"understand the most populate tools in the ecosystem. Each tool has "
"different features as highlighted below."
msgstr "Pythonパッケージのエコシステムで利用可能な、さまざまなフロントエンドビルドツールを示す図です。この図に含めるツールは、エコシステムで最も利用されているツールを理解するのに役立ったPyPI調査に基づいて選択しました。各ツールには、以下のように異なる特徴があります。"

#: ../../package-structure-code/python-package-build-tools.md:18
msgid ""
"If you want to know more about Python packages that have extensions "
"written in other languages, [check out the page on complex package builds"
".](complex-python-package-builds)"
msgstr ""
"他の言語で書かれた拡張機能を持つPythonパッケージについてもっと知りたい場合は、 [複雑なパッケージのビルドのページをチェックしてください"
"](complex-python-package-builds)"

#: ../../package-structure-code/python-package-build-tools.md:21
msgid "Tools that we review here"
msgstr "ここでレビューするツール"

#: ../../package-structure-code/python-package-build-tools.md:23
msgid ""
"In this section we have selected tools that were returned as the most "
"popular packaging tools in the PyPA survey. You will learn more about the"
" following tools on this page:"
msgstr "このセクションでは、PyPAのアンケートで最も人気のあったパッケージングツールを紹介します。 このページでは以下のツールについて詳しく説明します:"

#: ../../package-structure-code/python-package-build-tools.md:27
msgid ""
"[Twine](https://twine.readthedocs.io/en/stable/), [Build](https://pypa-"
"build.readthedocs.io/en/stable/) + "
"[setuptools](https://setuptools.pypa.io/en/latest/)"
msgstr ""
"[Twine](https://twine.readthedocs.io/en/stable/), [Build](https://pypa-"
"build.readthedocs.io/en/stable/) + "
"[setuptools](https://setuptools.pypa.io/en/latest/)"

#: ../../package-structure-code/python-package-build-tools.md:28
msgid "[Flit](https://flit.pypa.io/en/stable/)"
msgstr "[Flit](https://flit.pypa.io/en/stable/)"

#: ../../package-structure-code/python-package-build-tools.md:29
msgid "[Hatch](https://hatch.pypa.io/latest/)"
msgstr "[Hatch](https://hatch.pypa.io/latest/)"

#: ../../package-structure-code/python-package-build-tools.md:30
msgid "[PDM](https://pdm.fming.dev/latest/)"
msgstr "[PDM](https://pdm.fming.dev/latest/)"

#: ../../package-structure-code/python-package-build-tools.md:31
msgid "[Poetry](https://python-poetry.org/docs/)"
msgstr "[Poetry](https://python-poetry.org/docs/)"

#: ../../package-structure-code/python-package-build-tools.md:33
msgid "Summary of tools Hatch vs. PDM vs. Poetry (and setuptools)"
msgstr "ツールまとめ Hatch vs PDM vs Poetry (と setuptools)"

#: ../../package-structure-code/python-package-build-tools.md:35
msgid "If you are looking for a quick summary, read below."
msgstr "簡単な要約をお探しの方は、以下をお読みください。"

#: ../../package-structure-code/python-package-build-tools.md:37
msgid ""
"In general, any modern tool that you select from this page will be great "
"to build your package. Selecting a tool comes down to the features that "
"you are looking for in your workflow."
msgstr "一般的に、このページから選択した最新のツールは、パッケージを構築するのに適しています。 ツールの選択は、ワークフローに求める機能によって決まります。"

#: ../../package-structure-code/python-package-build-tools.md:38
msgid ""
"We suggest that beginners start with a modern workflow tool like PDM as "
"opposed to navigating the complexities of setuptools."
msgstr "初心者の方は、 setuptools の複雑な操作ではなく、PDMのような最新のワークフローツールから始めることをお勧めします。"

#: ../../package-structure-code/python-package-build-tools.md:39
msgid ""
"If you are going to use Poetry (it is the most popular tool and does have"
" the best documentation) beware of the upper bounds dependency additions "
"and consider overriding dependencies when you add them. If you do that "
"Poetry will work well for pure-python builds! Poetry also has an active "
"discord where you can ask questions."
msgstr ""
"Poetryを使うのであれば (最も人気のあるツールであり、最高のドキュメントを持っています) "
"、依存関係の追加上限値に注意し、依存関係を追加する際にオーバーライドすることを検討してください。 "
"そうすれば、Poetryは純粋なPythonビルドでもうまく動くでしょう！ また、Poetryには活発な discord "
"があり、質問をすることができます。"

#: ../../package-structure-code/python-package-build-tools.md:41
msgid "Below are some features that Hatch and PDM offer that Poetry does not."
msgstr "以下は、ハッチとPDMが提供し、Poetryが提供しない機能です。"

#: ../../package-structure-code/python-package-build-tools.md:43
msgid "PDM:"
msgstr "PDM:"

#: ../../package-structure-code/python-package-build-tools.md:45
msgid ""
"Supports other back-ends making it ideal for builds that are not pure "
"Python. This means PDM is a great option for both pure python and more "
"complex Python builds as it supports meson-python and other build "
"backends."
msgstr ""
"他のバックエンドをサポートしているので、純粋な Python ではないビルドに最適です。 つまり、PDMはmeson-"
"pythonや他のビルドバックエンドをサポートしているので、純粋なPythonにも、より複雑なPythonビルドにも最適なオプションです。"

#: ../../package-structure-code/python-package-build-tools.md:46
msgid "Offers flexibility in dependency management which we like"
msgstr "依存関係の管理に柔軟性があります"

#: ../../package-structure-code/python-package-build-tools.md:47
msgid "Offers lock files if you need them"
msgstr "必要に応じてファイルをロックすることも可能です"

#: ../../package-structure-code/python-package-build-tools.md:49
msgid "Hatch:"
msgstr "Hatch:"

#: ../../package-structure-code/python-package-build-tools.md:51
msgid ""
"Offers matrix environment management that allows you to run tests across "
"Python versions. If this feature is important to you, then Hatch is a "
"clear winner."
msgstr ""
"Pythonのバージョンにまたがってテストを実行できるマトリックス環境管理を提供します。 もしこの機能があなたにとって重要なら、Hatch "
"が明らかに勝者です。"

#: ../../package-structure-code/python-package-build-tools.md:52
msgid ""
"Offers a Nox / Make file like tool to streamline your build workflow. If "
"you are looking to reduce the number of tools in your workflow, Hatch "
"might be for you."
msgstr ""
"ビルドワークフローを効率化するNox/Makeファイルのようなツールを提供します。 "
"ワークフローにおけるツールの数を減らしたいのであれば、Hatchはうってつけかもしれません。"

#: ../../package-structure-code/python-package-build-tools.md:55
msgid "Build front-end vs. build back-end tools"
msgstr "フロントエンド構築ツールとバックエンド構築ツール"

#: ../../package-structure-code/python-package-build-tools.md:57
msgid ""
"To better understand your options, when it comes to building a Python "
"package, it's important to first understand the difference between a "
"build tool front-end and build back-end."
msgstr "Pythonパッケージのビルドに関して、あなたの選択肢をよりよく理解するためには、まずビルドツールのフロントエンドとビルドのバックエンドの違いを理解することが重要です。"

#: ../../package-structure-code/python-package-build-tools.md:62
msgid "Build back-ends"
msgstr "バックエンドのビルド"

#: ../../package-structure-code/python-package-build-tools.md:64
msgid ""
"Most packaging tools have a back-end build tool that builds you package "
"and creates associated [(sdist and wheel) distribution files](python-"
"package-distribution-files-sdist-wheel). Some tools, such as **Flit**, "
"only support pure-Python package builds. A pure-Python build refers to a "
"package build that does not have extensions that are written in another "
"programming language (such as `C` or `C++`)."
msgstr ""
"ほとんどのパッケージングツールには、パッケージをビルドし、関連する [(sdistとwheel)配布ファイル](python-package-"
"distribution-files-sdist-wheel) を作成するバックエンドビルドツールがあります。  **Flit** "
"のようないくつかのツールは、純粋なPythonパッケージのビルドのみをサポートしています。 純粋な Python "
"のビルドとは、他のプログラミング言語 (`C` や `C++` など) で書かれた拡張機能を持たないパッケージのビルドを指します。"

#: ../../package-structure-code/python-package-build-tools.md:71
msgid ""
"Other packages that have C and C++ extensions (or that wrap other "
"languages such as fortran) require additional code compilation steps when"
" built. Back-ends such as **setuptools.build**, **meson.build** and "
"**scikit-build** support complex builds with custom steps. If your build "
"is particularly complex (i.e. you have more than a few `C`/`C++` "
"extensions), then we suggest you use **meson.build** or **scikit-build**."
msgstr ""
"C や C++の拡張を持つ他のパッケージ(あるいは fortran "
"のような他の言語を包含するパッケージ)は、ビルド時に追加のコードコンパイルステップを必要とします。  **setuptools.build** 、"
" **meson.build** 、 **scikit-build** "
"などのバックエンドは、カスタムステップによる複雑なビルドをサポートしています。ビルドが特に複雑な場合（つまり `C`/`C++` "
"拡張モジュールが数個以上ある場合）は、 **meson.build** または **scikit-build** を使用することをお勧めします。"

#: ../../package-structure-code/python-package-build-tools.md:77
msgid "Python package build front-ends"
msgstr "Pythonパッケージビルドフロントエンド"

#: ../../package-structure-code/python-package-build-tools.md:79
msgid ""
"A packaging front-end tool refers to a tool that makes it easier for you "
"to perform common packaging tasks using similar commands. These tasks "
"include:"
msgstr ""
"パッケージングフロントエンドツールとは、同様のコマンドを使用して一般的なパッケージングタスクを簡単に実行できるようにするツールのことです。 "
"これらのタスクには以下のようなものがあります:"

#: ../../package-structure-code/python-package-build-tools.md:82
msgid ""
"[Build your packages (create the sdist and wheel distributions)](python-"
"package-distribution-files-sdist-wheel)"
msgstr ""
"[パッケージのビルド (sdist と wheel ディストリビューションの作成)](python-package-distribution-"
"files-sdist-wheel)"

#: ../../package-structure-code/python-package-build-tools.md:83
msgid ""
"Installing your package in a development mode (so it updates when you "
"update your code)"
msgstr "開発モードでパッケージをインストールします (コードを更新したときに更新されるようにします)"

#: ../../package-structure-code/python-package-build-tools.md:84
msgid "Publishing to PyPI"
msgstr "PyPIへの公開"

#: ../../package-structure-code/python-package-build-tools.md:85
msgid "Running tests"
msgstr "テストの実行"

#: ../../package-structure-code/python-package-build-tools.md:86
msgid "Building documentation"
msgstr "ドキュメントの作成"

#: ../../package-structure-code/python-package-build-tools.md:87
msgid ""
"Managing an environment or multiple environments in which you need to run"
" tests and develop your package"
msgstr "テストの実行やパッケージの開発が必要な環境、または複数の環境の管理"

#: ../../package-structure-code/python-package-build-tools.md:89
msgid ""
"There are several Python packaging tools that you can use for pure Python"
" builds. Each front-end tool discussed below supports a slightly "
"different set of Python packaging tasks."
msgstr ""
"純粋な Python のビルドに使える Python パッケージングツールがいくつかあります。 "
"以下で説明する各フロントエンドツールは、少しずつ異なる Python パッケージングタスクをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:93
msgid ""
"For instance, you can use the packaging tools **Flit**, **Hatch** or "
"**PDM** to both build and publish your package to PyPI. However while "
"**Hatch** and **PDM** support versioning and environment management, "
"**Flit** does not. If you want a tool that supports dependency locking, "
"you can use **PDM** or **Poetry** but not **Hatch**. If you only need to "
"build your package's sdist and wheel distribution files, then you can "
"stick with PyPA's Build. You'd then use Twine to publish to PyPI."
msgstr ""
"例えば、パッケージングツールの **Flit**、**Hatch**、**PDM** を使って、パッケージのビルドと PyPI "
"への公開の両方を行うことができます。 しかし、**Hatch**と**PDM**はバージョン管理と環境管理をサポートしていますが、 "
"**Flit** はサポートしていません。 "
"依存性ロックをサポートするツールが欲しい場合は、**PDM**や**Poetry**を使うことができますが、 **Hatch** は使えません。 "
"パッケージのsdistとwheelの配布ファイルをビルドするだけなら、PyPAのBuildで十分です。 "
"その後、Twineを使ってPyPIに公開します。"

#: ../../package-structure-code/python-package-build-tools.md:100
msgid ""
"If you are using **Setuptools**, there is no default user-friendly build "
"front-end that performs multiple tasks. You will need to use **build** to"
" build your package and **twine** to publish to PyPI."
msgstr ""
"**Setuptools** を使用している場合、複数のタスクを実行するデフォルトのユーザーフレンドリーなビルドフロントエンドはありません。 "
"パッケージをビルドするには **build** を、PyPI に公開するには **twine** を使う必要があります。"

#: ../../package-structure-code/python-package-build-tools.md:103
msgid "Example build steps that can be simplified using a front-end tool"
msgstr "フロントエンドツールを使って簡略化できるビルド手順の例"

#: ../../package-structure-code/python-package-build-tools.md:105
msgid ""
"Below, you can see how a build tool streamlines your packaging "
"experience. Example to build your package with **Hatch**:"
msgstr "以下に、ビルドツールがパッケージングをどのように効率化するかを示します。  **Hatch** でパッケージをビルドする例です:"

#: ../../package-structure-code/python-package-build-tools.md:115
msgid "Example build steps using the **setuptools** back-end and **build**:"
msgstr "**setuptools** バックエンドと **build** を使用したビルド手順の例:"

#: ../../package-structure-code/python-package-build-tools.md:125
msgid "Choosing a build back-end"
msgstr "ビルドバックエンドの選択"

#: ../../package-structure-code/python-package-build-tools.md:127
msgid ""
"Most front-end packaging tools have their own back-end build tool. The "
"build tool creates your package's (sdist and wheel) distribution files. "
"For pure Python packages, the main difference between the different build"
" back-ends discussed below is:"
msgstr ""
"ほとんどのフロントエンドパッケージングツールは、独自のバックエンドビルドツールを持っています。 ビルドツールはパッケージの "
"(sdistやwheelの) 配布ファイルを作成します。 "
"純粋なPythonパッケージの場合、以下で説明するビルドバックエンド間の主な違いは以下の通りです:"

#: ../../package-structure-code/python-package-build-tools.md:132
msgid ""
"How configurable they are - for example, do they allow you to add build "
"steps that support non python extensions?"
msgstr "設定可能性 - 例えば、Python以外の拡張機能をサポートするビルドステップを追加することはできますか？"

#: ../../package-structure-code/python-package-build-tools.md:133
msgid ""
"How much you need to configure them to ensure the correct files are "
"included in your sdist and wheel distributions."
msgstr "正しいファイルがsdistとwheelディストリビューションに含まれていることを確認するために、どの程度設定する必要があるか。"

#: ../../package-structure-code/python-package-build-tools.md:135
msgid "Build back-end support for non pure-python packages"
msgstr "純粋なPythonパッケージ以外のバックエンドサポートの構築"

#: ../../package-structure-code/python-package-build-tools.md:137
msgid ""
"It is important to note that some build back-ends, such as **Flit-core**,"
" only support pure Python builds. Other back-ends support C and C++ "
"extensions as follows:"
msgstr ""
"**Flit-core** "
"のようないくつかのビルドバックエンドは、純粋なPythonビルドしかサポートしていないことに注意することが重要です。その他のバックエンドは、以下のようにCとC++の拡張をサポートしています:"

#: ../../package-structure-code/python-package-build-tools.md:140
msgid "setuptools supports builds using C / C++ extensions"
msgstr "setuptools は、C / C++ 拡張モジュールを使用したビルドをサポートします。"

#: ../../package-structure-code/python-package-build-tools.md:141
msgid ""
"Hatchling (hatch's back-end) supports C / C++ extensions via plugins that"
" the developer creates to customize a build"
msgstr ""
"Hatchling (hatchのバックエンド) "
"は、開発者がビルドをカスタマイズするために作成するプラグインによって、C/C++の拡張機能をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:142
msgid "PDM's back-end supports C / C++ extensions by using setuptools"
msgstr "PDMのバックエンドは、setuptoolsを使用してC / C++拡張をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:143
msgid ""
"Poetry's back-end supports C/C++ extensions however this functionality is"
" currently undocumented. As such we don't recommend using Poetry for "
"complex or non pure Python builds until it is documented."
msgstr ""
"PoetryのバックエンドはC/C++拡張をサポートしていますが、この機能は現在ドキュメント化されていません。 "
"そのため、ドキュメント化されるまでは、複雑なビルドや純粋なPython以外のビルドにPoetryを使うことはお勧めしません。"

#: ../../package-structure-code/python-package-build-tools.md:145
msgid ""
"While we won't discuss more complex builds below, we will identify which "
"tools have documented support for C / C++ extensions."
msgstr "以下では、より複雑なビルドについては説明しませんが、どのツールがC / C++の拡張機能を文書でサポートしているかを確認します。"

#: ../../package-structure-code/python-package-build-tools.md:148
msgid "An ecosystem of Python build tools"
msgstr "Pythonビルドツールのエコシステム"

#: ../../package-structure-code/python-package-build-tools.md:150
msgid ""
"Below we introduce several of the most commonly used Python packaging "
"build front-end tools. We highlight the features that each tool offers as"
" a way to help you decide what tool might be best for your workflow."
msgstr ""
"以下では、最もよく使われる Python パッケージングビルドフロントエンドツールをいくつか紹介します。 "
"どのツールがあなたのワークフローに最適かを決める手助けとして、各ツールが提供する機能を強調します。"

#: ../../package-structure-code/python-package-build-tools.md:154
msgid "We do not suggest using setuptools"
msgstr "setuptools の使用はお勧めしません"

#: ../../package-structure-code/python-package-build-tools.md:157
msgid ""
"We suggest that you pick one of the modern tools listed above rather than"
" setuptools because setuptools will require some additional knowledge to "
"set up correctly."
msgstr "setuptoolsは、正しくセットアップするためにいくつかの追加知識を必要とするため、setuptoolsではなく、上記の近代的なツールのいずれかを選択することをお勧めします。"

#: ../../package-structure-code/python-package-build-tools.md:161
msgid ""
"We review setuptools as a back-end because it is still popular. However "
"it is not the most user friendly option."
msgstr ""
"バックエンドとしてsetuptoolsをレビューするのは、今でも人気があるからです。 "
"しかし、それは最もユーザーフレンドリーなオプションではありません。"

#: ../../package-structure-code/python-package-build-tools.md:165
msgid ""
"The most commonly used tools in the ecosystem are setuptools back-end "
"(with build) and Poetry (a front end tool with numerous features and "
"excellent documentation)."
msgstr "エコシステムで最もよく使われるツールは、setuptoolsのバックエンド（ビルド機能付き）とPoetry（多数の機能と優れたドキュメントを備えたフロントエンドツール）です。"

#: ../../package-structure-code/python-package-build-tools.md:171
msgid ""
"Graph showing the results of the 2022 PyPA survey of Python packaging "
"tools. On the x axis is percent response and on the y axis are the tools."
msgstr "2022年のPyPAによるPythonパッケージングツールの調査結果を示すグラフです。 X軸は回答率、Y軸はツールです。"

#: ../../package-structure-code/python-package-build-tools.md:173
msgid ""
"The Python developers survey results (n=>8,000 PyPI users) show "
"setuptools and poetry as the most commonly used Python packaging tools. "
"The core tools that we've seen being used in the scientific community are"
" included here. [You can view the full survey results by clicking "
"here.](https://drive.google.com/file/d/1U5d5SiXLVkzDpS0i1dJIA4Hu5Qg704T9/view)"
" NOTE: this data represent maintainers across domains and is likely "
"heavily represented by those in web development. So this represents a "
"snapshot across the broader Python ecosystem."
msgstr ""
"Python developers survey results (n=>8,000 PyPI "
"users)では、最もよく使われているPythonパッケージングツールとしてsetuptoolsとpoetryが挙げられています。 "
"科学コミュニティで使用されているコアツールはここに含まれています。 "
"[ここをクリックすると、調査結果の全文を見ることができます。](https://drive.google.com/file/d/1U5d5SiXLVkzDpS0i1dJIA4Hu5Qg704T9/view)"
" 注意: このデータはドメイン全体のメンテナを表しており、ウェブ開発関係者が多く含まれているようです。 これはより広い Python "
"エコシステム全体のスナップショットを表しています。"

#: ../../package-structure-code/python-package-build-tools.md:176
msgid "Chose a build workflow tool"
msgstr "ビルドワークフローツールの選択"

#: ../../package-structure-code/python-package-build-tools.md:178
msgid "The tools that we review below include:"
msgstr "以下にレビューするツールは以下の通り:"

#: ../../package-structure-code/python-package-build-tools.md:180
msgid "Twine, Build + setuptools"
msgstr "Twine, Build + setuptools"

#: ../../package-structure-code/python-package-build-tools.md:181
#: ../../package-structure-code/python-package-build-tools.md:291
msgid "Flit"
msgstr "Flit"

#: ../../package-structure-code/python-package-build-tools.md:182
#: ../../package-structure-code/python-package-build-tools.md:331
msgid "Hatch"
msgstr "Hatch"

#: ../../package-structure-code/python-package-build-tools.md:183
#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:230
msgid "PDM"
msgstr "PDM"

#: ../../package-structure-code/python-package-build-tools.md:184
#: ../../package-structure-code/python-package-build-tools.md:374
msgid "Poetry"
msgstr "Poetry"

#: ../../package-structure-code/python-package-build-tools.md:186
msgid ""
"When you are selecting a tool, you might consider this general workflow "
"of questions:"
msgstr "ツールを選ぶ際には、このような一般的な質問の流れを考慮するとよいでしょう:"

#: ../../package-structure-code/python-package-build-tools.md:189
msgid ""
"**Is your tool pure python? Yes?** You can use any tool that you wish! "
"Pick the tool that has the features that you want to use in your build "
"workflow. We suggest:"
msgstr ""
"**あなたのツールは純粋なパイソンですか？はい？** お好きなツールをお使いください！ "
"あなたのビルドワークフローで使いたい機能を持つツールを選んでください。 お勧めは:"

#: ../../package-structure-code/python-package-build-tools.md:191
msgid "Flit, Hatch, PDM or Poetry (read below for more)"
msgstr "Flit、Hatch、PDM、またはPoetry (詳しくは以下をお読みください)"

#: ../../package-structure-code/python-package-build-tools.md:193
msgid ""
"**Does your tool have a few C or C++ extensions?** Great, we suggest "
"using **PDM** for the time being. It is the only tool in the list below "
"that has both documented workflow to support such extensions and support "
"for other back-ends in the case that build hooks are not enough for your "
"workflow. PDM supports other back-ends such as scikit-build and meson-"
"python that will allow you to fully customize your package's build."
msgstr ""
"**あなたのツールはCやC++の拡張機能をいくつか持っていますか？** 当面は **PDM** を使うことをお勧めします。 "
"以下のリストの中で、このような拡張をサポートするワークフローが文書化されており、ビルドフックだけではワークフローが不十分な場合に他のバックエンドをサポートする唯一のツールです。"
" PDMは、scikit-buildやmeson-"
"pythonなどの他のバックエンドをサポートしており、パッケージのビルドを完全にカスタマイズすることができます。"

#: ../../package-structure-code/python-package-build-tools.md:197
msgid ""
"NOTE: You can also use Hatch for non pure python builds. Hatch, similar "
"to PDM, allows you to write your own build hooks or plugins to support "
"custom build steps. But currently, hatch does not support other build "
"back ends. Many of the core scientific packages are moving to meson-"
"python to build their packages. Thus, we appreciate that PDM can work "
"with meson-python specifically."
msgstr ""
"注: 純粋なpython以外のビルドにもHatchを使うことができます。 Hatch は PDM "
"と同様に、独自のビルドフックやプラグインを書くことができます。 "
"しかし現在、hatchは他のビルドバックエンドをサポートしていない。コアな科学パッケージの多くは、パッケージをビルドするために meson-"
"pythonに移行しています。したがって、PDMが特にmeson-pythonと連携できることはありがたいです。"

#: ../../package-structure-code/python-package-build-tools.md:199
msgid "Python packaging tools summary"
msgstr "Pythonパッケージングツールまとめ"

#: ../../package-structure-code/python-package-build-tools.md:201
msgid ""
"Below, we summarize features offered by the most popular build front end "
"tools. It is important to keep in mind that these front-end tools remove "
"the need to use other core tools in your workflow. For example if you use"
" setuptools, you will need to also use Build and Twine to build your "
"package and publish to PyPI. But if you use Poetry, Hatch or PDM you can "
"do all of those things using the same tool (e.g. `hatch build`, `hatch "
"publish` or `pdm build`, `pdm publish`)."
msgstr ""
"以下に、最も人気のあるビルドフロントエンドツールが提供する機能を要約します。これらのフロントエンドツールは、あなたのワークフローにおいて他のコアツールを使う必要性をなくすということを覚えておくことが重要です。"
" 例えばsetuptoolsを使う場合、パッケージをビルドしてPyPIに公開するためにBuildとTwineも使う必要があります。 "
"しかし、PoetryやHatch、PDMを使う場合は、同じツールを使ってこれらすべてを行うことができます (例：`hatch "
"build`、`hatch publish`、`pdm build`、`pdm publish`) 。"

#: ../../package-structure-code/python-package-build-tools.md:204
msgid ""
"Note that because setuptools does not offer a front-end interface, it is "
"not included in the table."
msgstr "setuptoolsはフロントエンドインターフェースを提供していないので、この表には含まれていないことに注意してください。"

#: ../../package-structure-code/python-package-build-tools.md:208
msgid "Package tool features table"
msgstr "パッケージツール機能一覧表"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Feature, Flit, Hatch, PDM, Poetry"
msgstr "Flit, Hatch, PDM, Poetry の特徴"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Default Build Back-end"
msgstr "デフォルトのビルドバックエンド"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Flit-core"
msgstr "Flit-core"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "hatchling"
msgstr "hatchling"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Poetry-core"
msgstr "Poetry-core"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Use Other Build Backends"
msgstr "他のビルドバックエンドを使う"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "✖"
msgstr "✖"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "✅"
msgstr "✅"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Dependency management"
msgstr "依存関係の管理"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Publish to PyPI"
msgstr "PyPIに公開する"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Version Control based versioning (using `git tags`)"
msgstr "バージョン管理ベースのバージョニング ( `git tags` を使用)"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Version bumping"
msgstr "バージョンバンプ"

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Environment Management"
msgstr "環境マネジメント"

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "More than one maintainer? (bus factor)"
msgstr "メンテナンス担当者が複数いるか？ (バスファクター)"

#: ../../package-structure-code/python-package-build-tools.md:225
msgid "Notes:"
msgstr "注釈:"

#: ../../package-structure-code/python-package-build-tools.md:227
msgid "_Hatch plans to support dependency management in the future_"
msgstr "_Hatch は将来的に従属性管理をサポートする予定です_"

#: ../../package-structure-code/python-package-build-tools.md:228
msgid ""
"Poetry supports semantic versioning. Thus, it will support version "
"bumping following commit messages if you use a tool such as Python "
"Semantic Release"
msgstr ""
"Poetry はセマンティックバージョニングをサポートしています。 したがって、Python Semantic "
"Releaseのようなツールを使えば、コミットメッセージに続くバージョンバンプをサポートします。"

#: ../../package-structure-code/python-package-build-tools.md:232
msgid ""
"[PDM is a Python packaging and dependency management "
"tool](https://pdm.fming.dev/latest/). PDM supports builds for pure Python"
" projects. It also provides multiple layers of support for projects that "
"have C and C++ extensions."
msgstr ""
"[PDMはPythonのパッケージングと依存関係の管理ツールです](https://pdm.fming.dev/latest/) 。 "
"PDMは純粋なPythonプロジェクトのビルドをサポートします。また、CやC++の拡張を持つプロジェクトに対しても、多層的なサポートを提供します。"

#: ../../package-structure-code/python-package-build-tools.md:236
msgid "PDM support for C and C++ extensions"
msgstr "CおよびC++拡張のPDMサポート"

#: ../../package-structure-code/python-package-build-tools.md:238
msgid ""
"PDM supports using the PDM-back-end and setuptools at the same time. This"
" means that you can run setuptools to compile and build C extensions. "
"PDM's build back-end receives the compiled extension files (.so, .pyd) "
"and packages them with the pure Python files."
msgstr ""
"PDMはPDM-back-endとsetuptoolsの同時使用をサポートしています。 つまり、setuptools を実行して C "
"拡張モジュールをコンパイルビルドすることができます。 PDMのビルドバックエンドはコンパイルされた拡張ファイル(.so, "
".pyd)を受け取り、純粋なPythonファイルと一緒にパッケージ化します。"

#: ../../package-structure-code/python-package-build-tools.md:244
msgid "PDM Features"
msgstr "PDMの特徴"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Feature, PDM, Notes"
msgstr "特徴, PDM, ノート"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"When you setup PDM it allows you to select one of several build back ends"
" including: PDM-core, flit-core and hatchling. PDM also can work with "
"Meson-Python which supports move complex python builds."
msgstr ""
"PDMをセットアップする際、いくつかのビルドバックエンドから1つを選択することができます: PDM-core、flit-"
"core、hatchlingなどです。 PDMはまた、複雑なPythonビルドをサポートするMeson-Pythonとも連携できます。"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Dependency specifications"
msgstr "依存仕様"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM has flexible support for  managing dependencies. PDM defaults to "
"using an open bound (e.g. `requests >=1.2`) approach to dependencies. "
"However you can  [customize how you want to add dependencies in case you "
"prefer another approach such as that of Poetry which uses an upper bound "
"limit](https://pdm.fming.dev/latest/usage/dependency/#about-update-"
"strategy).**"
msgstr ""
"PDMは依存関係の管理を柔軟にサポートしています。 PDMはデフォルトで依存関係に対してオープンバウンド(例えば `requests >=1.2`"
" )アプローチを使用します。 しかし、 "
"[Poetryのような上限を使用する別のアプローチを好む場合、依存関係を追加する方法をカスタマイズする](https://pdm.fming.dev/latest/usage/dependency"
"/#about-update-strategy) ことができます。"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Environment lock files"
msgstr "環境ロックファイル"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM and Poetry are currently the only tools that create environment lock "
"files. Lock files are often most useful to developers creating web apps "
"where locking the environment is critical for consistent user experience."
" For community-used packages, you will likely never want to use a lock "
"file."
msgstr ""
"PDMとPoetryは現在、環境ロックファイルを作成する唯一のツールです。 "
"ロックファイルは、一貫したユーザーエクスペリエンスのために環境をロックすることが重要なウェブアプリを作成する開発者にとって、しばしば最も有用です。"
" コミュニティで使われるパッケージでは、ロックファイルを使うことはないでしょう。"

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Environment management"
msgstr "環境マネジメント"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM provides environment management support. It supports Python virtual "
"environments, conda and a local `__pypackages__` environment which is a "
"newer option in the Python ecosystem. No extensions are needed for this "
"support."
msgstr ""
"PDMは環境管理のサポートを提供します。 Python仮想環境、conda、そしてPythonエコシステムの新しいオプションであるローカルの "
"`__pypackages__` 環境をサポートしています。 このサポートに拡張は必要ありません。"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Select your environment type on install"
msgstr "インストール時に環境タイプを選択"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"When you run `PDM init`, PDM will discover environments that are already "
"on your system and allow you to select one to use for your project."
msgstr "`PDM init` を実行すると、PDMがあなたのシステム上にある環境を検出し、プロジェクトに使用する環境を選択できるようになります。"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "PDM supports publishing to both test PyPI and PyPI"
msgstr "PDM は test PyPI と PyPI の両方への公開をサポートしています"

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Version Control based versioning"
msgstr "バージョン管理ベースのバージョニング"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM has a setuptools_scm like tool built into it which allows you to use "
"dynamic versioning that rely on git tags."
msgstr "PDMには setuptools_scm のようなツールが組み込まれており、gitタグに依存したダイナミックバージョニングを使うことができます。"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""
"PDMは、標準的なセマンティックバージョニングである patch; minor; major "
"を使って、パッケージのバージョンをバンプすることをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Follows current packaging standards"
msgstr "現行のパッケージング基準に従う"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr "PDMは **pyproject.toml** ファイルにメタデータを追加するための現在のパッケージング標準をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Install your package in editable mode"
msgstr "編集可能モードでパッケージをインストールする"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "PDM supports installing your package in editable mode."
msgstr "PDMは編集可能モードでのパッケージのインストールをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Build your sdist and wheel distributions"
msgstr "sdistとwheelディストリビューションの構築"

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"Similar to all of the other tools PDM builds your packages sdist and "
"wheel files for you."
msgstr "他のツール同様、PDMはパッケージのsdistとwheelファイルをビルドしてくれます。"

#: ../../package-structure-code/python-package-build-tools.md:264
msgid "PDM vs. Poetry"
msgstr "PDM vs. Poetry"

#: ../../package-structure-code/python-package-build-tools.md:265
msgid ""
"The functionality of PDM is similar to Poetry. However, PDM also offers "
"additional, documented support for C extensions and version control based"
" versioning. As such, PDM is preferred for those working on non pure-"
"Python packages."
msgstr ""
"PDMの機能はPoetryに似ています。 しかし、PDMはC拡張やバージョン管理ベースのバージョニングを文書でサポートしています。 "
"そのため、純粋なPython以外のパッケージで作業する場合は、PDMを使うことをお勧めします。"

#: ../../package-structure-code/python-package-build-tools.md:269
msgid ""
"If you are deciding between the Poetry and PDM, a smaller  difference is "
"the default way that dependencies are added to your pyproject.toml file."
msgstr "もしあなたがPoetryとPDMのどちらを選ぶか決めているのであれば、より小さな違いは依存関係をpyproject.tomlファイルに追加するデフォルトの方法です。"

#: ../../package-structure-code/python-package-build-tools.md:271
msgid ""
"Poetry by default follows strict semantic versioning adding dependencies "
"to your pyproject.toml file [using an upper bounds constraint "
"(`^`)](https://python-poetry.org/docs/dependency-specification/#version-"
"constraints). Upper bounds lock means that Poetry will never bump a "
"dependency to the next major version (i.e. from 1.2 to 2.0). However, you"
" can tell Poetry to use an open bound approach by explicitly adding the "
"package like this: `poetry add requests >= 1.2` rather than just using "
"`poetry add requests` which will result in a upper bound locked (ie Upper"
" bound locks means that requests 2.0 could never be installed even if it "
"came out and your package could benefit from it)."
msgstr ""
"Poetryはデフォルトで、pyproject.tomlファイルに [上界制約(`^`)を使って](https://python-"
"poetry.org/docs/dependency-specification/#version-constraints) "
"依存関係を追加する、厳密なセマンティックバージョニングに従っています。 "
"アッパーバウンズロックとは、ポエトリーが依存関係を次のメジャーバージョン（1.2から2.0など）にバンプさせないことを意味します。 "
"しかし、次のように明示的にパッケージを追加することで、Poetryにオープンバウンドのアプローチを使うように指示することができる： poetry "
"add requests >= 1.2` のように明示的にパッケージを追加することで、Poetry "
"にオープンバウンドのアプローチを使うように指示することができます "
"(すなわち、アッパーバウンドロックとは、リクエスト2.0が出たとしてもインストールされることはなく、あなたのパッケージはその恩恵を受けることができるということです)"
" 。"

#: ../../package-structure-code/python-package-build-tools.md:272
msgid ""
"PDM defaults to open-bounds (`>=`) dependency additions which is the "
"preferred approach in the scientific python ecosystem. However, PDM also "
"allows you to specify the way dependencies are added by default. As such,"
" you can also specify upper-bounds (`^`) using PDM if require that "
"approach."
msgstr ""
"PDMのデフォルトはオープンバウンド(`>=`)依存性の追加で、これは科学的なpythonのエコシステムでは好ましいアプローチです。 "
"しかし、PDMではデフォルトで依存関係を追加する方法を指定することもできます。 そのため、その方法が必要であれば、PDMを使用して上限 (`^`)"
" を指定することもできます。"

#: ../../package-structure-code/python-package-build-tools.md:274
msgid ""
"Finally there are some nuanced differences in how both tools create lock "
"files which we will not go into detail about here."
msgstr "最後に、両ツールのロックファイルの作成方法には微妙な違いがありますが、ここでは詳しく説明しません。"

#: ../../package-structure-code/python-package-build-tools.md:277
msgid "Challenges with PDM"
msgstr "PDMの課題"

#: ../../package-structure-code/python-package-build-tools.md:279
msgid ""
"PDM is a full-featured packaging tool. However it is not without "
"challenges:"
msgstr "PDMはフル機能のパッケージングツールです。しかし、課題がないわけではありません:"

#: ../../package-structure-code/python-package-build-tools.md:281
msgid ""
"Its documentation can be confusing, especially if you are new to "
"packaging. For example, PDM doesn't provide an end to end beginning "
"workflow in its documentation."
msgstr ""
"PDMのドキュメントは、特に初めてパッケージングを行う場合、混乱する可能性があります。 "
"例えば、PDMのドキュメントには、最初から最後までのワークフローが記載されていません。"

#: ../../package-structure-code/python-package-build-tools.md:283
msgid ""
"PDM also only has one maintainer currently. We consider individual "
"maintainer teams to be a potential risk. If the maintainer finds they no "
"longer have time to work on the project, it leaves users with a gap in "
"support. Hatch and Flit also have single maintainer teams."
msgstr ""
"また、PDMには現在1人のメンテナしかいません。 私たちは、個々のメンテナチームは潜在的なリスクであると考えています。 "
"もしメンテナがプロジェクトに取り組む時間がなくなったら、ユーザーにはサポートのギャップが残ります。 "
"HatchとFlitにも、一人のメンテナチームがあります。"

#: ../../package-structure-code/python-package-build-tools.md:288
msgid ""
"[You can view an example of a package that uses PDM "
"here](https://github.com/pyOpenSci/examplePy/tree/main/example4_pdm). The"
" README file for this directly provides you with an overview of what the "
"PDM command line interface looks like when you use it."
msgstr ""
"[PDMを使用したパッケージの例はこちらからご覧いただけます](https://github.com/pyOpenSci/examplePy/tree/main/example4_pdm)"
" 。 このREADMEファイルでは、PDMコマンドラインインターフェイスを使用する際にどのように見えるかの概要を直接説明しています。"

#: ../../package-structure-code/python-package-build-tools.md:293
msgid ""
"[Flit is a no-frills, streamlined packaging "
"tool](https://flit.pypa.io/en/stable/) that supports modern Python "
"packaging standards. Flit is a great choice if you are building a basic "
"package to use in a local workflow that doesn't require any advanced "
"features. And if your package structure is already created. More on that "
"below."
msgstr ""
"[Flitは、最新のPythonパッケージング標準をサポートする、飾り気のない、合理的なパッケージングツール](https://flit.pypa.io/en/stable/)"
" です。 Flitは、ローカル・ワークフローで使用する基本的なパッケージを構築し、高度な機能を必要としない場合に最適な選択です。 "
"また、パッケージ構造がすでに作成されている場合。 詳しくは後述します。"

#: ../../package-structure-code/python-package-build-tools.md:297
msgid "Flit Features"
msgstr "Flitの特徴"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Feature, Flit, Notes"
msgstr "特徴, Flit, ノート"

#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Publish to PyPI and test PyPI"
msgstr "PyPIとtest PyPIに公開する"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit supports publishing to both test PyPI and PyPI"
msgstr "Flit は test PyPI と PyPI の両方への公開をサポートしています"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Helps you add metadata to your **pyproject.toml** file"
msgstr "**pyproject.toml** ファイルにメタデータを追加するのに役立ちます。"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid ""
"Flit does support adding metadata to your **pyproject.toml** file "
"following modern packaging standards."
msgstr "Flitは **pyproject.toml** ファイルにメタデータを追加することをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid ""
"Flit supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr "Flitは、 **pyproject.toml** ファイルにメタデータを追加する現在のパッケージング標準をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit supports installing your package in editable mode.**"
msgstr "Flitは編集可能モードでのパッケージのインストールをサポートしています。**"

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit can be used to build your packages sdist and wheel distributions."
msgstr "Flitはsdistとwheelのディストリビューションパッケージのビルドに使用できます。"

#: ../../package-structure-code/python-package-build-tools.md:311
msgid ""
"NOTE: _If you are using the most current version of pip, it supports both"
" a symlink approach `flit install -s` and `python -m pip install -e .`_"
msgstr ""
"注: _最新バージョンのpipを使用している場合、シンボリックリンクを使った `flit install -s` と `python -m pip"
" install -e .`_ の両方をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:313
msgid "Learn more about flit"
msgstr "flitについてもっと知る"

#: ../../package-structure-code/python-package-build-tools.md:314
msgid "[Why use flit?](https://flit.pypa.io/en/stable/rationale.html)"
msgstr "[なぜflitを使うのか？](https://flit.pypa.io/en/stable/rationale.html)"

#: ../../package-structure-code/python-package-build-tools.md:317
msgid "Why you might not want to use Flit"
msgstr "Flitを使いたくない理由"

#: ../../package-structure-code/python-package-build-tools.md:319
msgid ""
"Because Flit is no frills, it is best for basic, quick builds. If you are"
" a beginner you may want to select Hatch or PDM which will offer you more"
" support in common operations."
msgstr ""
"Flitは飾り気がないので、基本的で素早いビルドに最適です。 "
"初心者の方は、一般的な操作をよりサポートしてくれるHatchやPDMを選ぶとよいでしょう。"

#: ../../package-structure-code/python-package-build-tools.md:323
msgid "You may NOT want to use flit if:"
msgstr "次のような場合は、flitを使用しない方がよいです:"

#: ../../package-structure-code/python-package-build-tools.md:325
msgid ""
"You want to setup more advanced version tracking and management (using "
"version control for version bumping)"
msgstr "より高度なバージョン追跡と管理をセットアップしたい場合 (バージョン管理を使ってバージョンバンプを行う)"

#: ../../package-structure-code/python-package-build-tools.md:326
msgid ""
"You want a tool that handles dependency versions (use PDM or Poetry "
"instead)"
msgstr "依存性のあるバージョンを処理するツールが必要（代わりにPDMやPoetryを使用する）"

#: ../../package-structure-code/python-package-build-tools.md:327
msgid "You have a project that is not pure Python (Use Hatch, PDM or setuptools)"
msgstr "純粋なPythonではないプロジェクトを持っている（Hatch、PDM、またはsetuptoolsを使用する）"

#: ../../package-structure-code/python-package-build-tools.md:328
msgid "You want environment management (use PDM, Hatch or Poetry)"
msgstr "環境を管理したい（PDM、Hatch、またはPoetryを使用する）"

#: ../../package-structure-code/python-package-build-tools.md:333
msgid ""
"[**Hatch**](https://hatch.pypa.io/latest/), similar to Poetry and PDM, "
"provides a unified command line interface. To separate Hatch from Poetry "
"and PDM, it also provides an environment manager for testing that will "
"make it easier for you to run tests locally across different versions of "
"Python. It also offers a nox / makefile like feature that allows you to "
"create custom build workflows such as building your documentation "
"locally. This means that you could potentially drop a tool like **Make** "
"or **Nox** from your workflow and use Hatch instead."
msgstr ""
"[**Hatch**](https://hatch.pypa.io/latest/) "
"は、ポエトリーやPDMと同様、統一されたコマンドラインインターフェイスを提供する。HatchをPoetryやPDMから切り離すために、Pythonの異なるバージョン間でローカルにテストを実行しやすくするテスト用の環境マネージャーも提供しています。"
" また、nox / makefileのような機能もあり、ドキュメントをローカルでビルドするようなカスタムビルドワークフローを作成することができる。"
" つまり、ワークフローから **Make** や **Nox** "
"のようなツールを削除して、代わりにHatchを使うことができる可能性があるということだ。"

#: ../../package-structure-code/python-package-build-tools.md:340
msgid "Hatch features"
msgstr "Hatchの特徴"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Feature, Hatch, Notes"
msgstr "特徴, Hatch, ノート"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch is used with the backend Hatchling by default, but allows you to "
"use another backend by switching the declaration in pyproject.toml."
msgstr "HatchはデフォルトでHatchlingバックエンドと一緒に使われますが、pyproject.tomlの宣言を切り替えることで別のバックエンドを使うことができます。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Currently you have to add dependencies manually with Hatch. However a "
"feature to support dependencies management may be added in a future "
"release."
msgstr ""
"現在のところ、Hatchを使って手動で依存関係を追加する必要があります。 "
"しかし、依存関係の管理をサポートする機能が将来のリリースで追加されるかもしれません。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports Python virtual environments. If you wish to use other "
"types of environments such as Conda, you will need to [install a plugin "
"such as hatch-conda for conda support](https://github.com/OldGrumpyViking"
"/hatch-conda)."
msgstr ""
"HatchはPython仮想環境をサポートしています。 Condaのような他の環境を使いたい場合は、 [condaをサポートするhatch-"
"condaのようなプラグインをインストールする](https://github.com/OldGrumpyViking/hatch-conda) "
"必要があります。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Hatch supports publishing to both test PyPI and PyPI"
msgstr "Hatch は test PyPI と PyPI の両方への公開をサポートしています"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch offers `hatch_vcs` which is a plugin that uses setuptools_scm to "
"support versioning using git tags. The workflow with `hatch_vcs` is the "
"same as that with `setuptools_scm`."
msgstr ""
"Hatch が提供する `hatch_vcs` は setuptools_scm を使って git "
"タグを使ったバージョン管理をサポートするプラグインです。 hatch_vcs` を使ったワークフローは `setuptools_scm` "
"を使ったワークフローと同じです。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""
"Hatchは、標準的なセマンティックバージョニングである patch; minor; major "
"を使って、パッケージのバージョンをバンプすることをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr "Hatchは、 **pyproject.toml** ファイルにメタデータを追加する現在のパッケージング標準をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch will install your package into any of its environments by default "
"in editable mode. You can install your package in editable mode manually "
"using `python -m pip install -e .` Hatch mentions [editable "
"installs](https://hatch.pypa.io/latest/config/build/#dev-mode) but refers"
" to pip in its documentation."
msgstr ""
"Hatchはデフォルトで編集可能なモードで、あなたのパッケージをどの環境にもインストールします。 `python -m pip install "
"-e .` を使って、編集可能モードでパッケージを手動でインストールできます。Hatchは [editable "
"installs](https://hatch.pypa.io/latest/config/build/#dev-mode) "
"に言及していますが、ドキュメントではpipを参照しています。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Hatch will build the sdist and wheel distributions"
msgstr "Hatchはsdistとホイールのディストリビューションを構築します"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "✨Matrix environment creation to support testing across Python versions✨"
msgstr "✨Pythonのバージョンをまたいだテストをサポートするためのマトリックス環境の構築✨"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"The matrix environment creation is a feature that is unique to Hatch in "
"the packaging ecosystem. This feature is useful if you wish to test your "
"package locally across Python versions (instead of using a tool such as "
"tox)."
msgstr ""
"マトリックス環境の作成は、パッケージングエコシステムにおける Hatch 独自の機能です。 この機能は、（tox "
"のようなツールを使う代わりに）Python のバージョンにまたがってパッケージをローカルでテストしたい場合に便利です。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"✨[Nox / MAKEFILE like "
"functionality](https://hatch.pypa.io/latest/environment/#selection)✨"
msgstr ""
"✨[Nox / "
"MAKEFILEのような機能性](https://hatch.pypa.io/latest/environment/#selection)✨"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"This feature is also unique to Hatch. This functionality allows you to "
"create workflows in the **pyproject.toml** configuration to do things "
"like serve docs locally and clean your package build directory. This "
"means you may have one less tool in your build workflow."
msgstr ""
"これもHatchならではの特徴だ。この機能により、**pyproject.toml** "
"設定にワークフローを作成し、ドキュメントをローカルに提供したり、パッケージのビルドディレクトリをクリーニングしたりすることができます。これは、ビルドワークフローのツールが1つ減ることを意味します。"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "✨A flexible build backend: **hatchling**✨"
msgstr "✨柔軟なビルドバックエンド: **hatchling**✨"

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"**The hatchling build backend offered by the maintainer of Hatch allows "
"developers to easily build plugins to support custom build steps when "
"packaging."
msgstr "**Hatchのメンテナが提供するhatchlingビルドバックエンドは、開発者がパッケージング時にカスタムビルドステップをサポートするプラグインを簡単にビルドすることを可能にします。"

#: ../../package-structure-code/python-package-build-tools.md:362
msgid ""
"_There is some argument about this approach placing a burden on "
"maintainers to create a custom build system. But others appreciate the "
"flexibility. The Hatch build hook approach is also comparable with the "
"features offered by PDM._"
msgstr ""
"_このアプローチは、メンテナにカスタムビルドシステムを作る負担を強いるという議論があリマス。 しかし、柔軟性を高く評価する人もいます。 "
"ハッチのビルドフックアプローチは、PDMが提供する機能にも匹敵します。_"

#: ../../package-structure-code/python-package-build-tools.md:364
msgid "Why you might not want to use Hatch"
msgstr "ハッチを使いたくない理由"

#: ../../package-structure-code/python-package-build-tools.md:366
msgid ""
"There are a few features that hatch is missing that may be important for "
"some. These include:"
msgstr "hatchには、一部の人にとって重要かもしれないいくつかの機能が欠けています。 それは以下のようなものです:"

#: ../../package-structure-code/python-package-build-tools.md:369
msgid ""
"Hatch doesn't support adding dependencies. You will have to add them "
"manually."
msgstr "Hatchは依存関係の追加をサポートしていません。 手動で追加する必要があります。"

#: ../../package-structure-code/python-package-build-tools.md:370
msgid "Hatch won't by default recognize Conda environments without a plugin."
msgstr "HatchはプラグインなしではデフォルトでConda環境を認識しません。"

#: ../../package-structure-code/python-package-build-tools.md:371
msgid ""
"Similar to PDM, Hatch's documentation can difficult to work through, "
"particularly if you are just getting started with creating a package."
msgstr "PDMと同様、Hatchのドキュメントを読みこなすのは難しいです。 特にパッケージの作成を始めたばかりであればなおさらです。"

#: ../../package-structure-code/python-package-build-tools.md:372
msgid "Hatch, similar to PDM and Flit currently only has one maintainer."
msgstr "Hatchは、PDMやFlitと同様、現在1人のメンテナしかいません。"

#: ../../package-structure-code/python-package-build-tools.md:376
msgid ""
"[Poetry is a full-featured build tool.](https://python-poetry.org/) It is"
" also the second most popular front-end packaging tool (based upon the "
"PyPA survey). Poetry is user-friendly and has clean and easy-to-read "
"documentation."
msgstr ""
"[Poetry はフル機能のビルドツールです。](https://python-poetry.org/) "
"また、（PyPAの調査に基づく）2番目に人気のあるフロントエンドパッケージングツールでもあります。 Poetry "
"はユーザーフレンドリーで、きれいで読みやすいドキュメントを持っています。"

#: ../../package-structure-code/python-package-build-tools.md:381
msgid ""
"While some have used Poetry for Python builds with C/C++ extensions, this"
" support is currently undocumented. Thus, we don't recommend using Poetry"
" for more complex builds."
msgstr ""
"C/C++ 拡張を含む Python のビルドに Poetry を使っている人もいますが、このサポートは現在のところ文書化されていません。 "
"したがって、より複雑なビルドに Poetry を使うことはお勧めしません。"

#: ../../package-structure-code/python-package-build-tools.md:385
msgid "Poetry features"
msgstr "Poetryの特徴"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Feature, Poetry, Notes"
msgstr "特徴, Poetry, ノート"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry helps you add dependencies to your `pyproject.toml` metadata. "
"_NOTE: currently Poetry adds dependencies using an approach that is "
"slightly out of alignment with current Python peps - however there is a "
"plan to fix this in an upcoming release._ Poetry also allows you to "
"organize dependencies in groups such as  documentation, packaging and "
"tests."
msgstr ""
"Poetry は `pyproject.toml` メタデータに依存関係を追加するのに役立ちます。 _NOTE: 現在のところ、Poetry "
"は現在の Python peps とは少しずれたアプローチで依存関係を追加しています - しかし、今後のリリースでこれを修正する予定です。 _ "
"Poetryでは、ドキュメント、パッケージング、テストなどのグループに依存関係を整理することもできます。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Dependency specification"
msgstr "依存仕様"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry allows you to be specific about version of dependencies that you "
"add to your package's pyproject.toml file. However, it's default upper "
"bound approach can be problematic for some packages (We suggest you "
"override the default setting when adding dependencies). Read below for "
"more."
msgstr ""
"Poetryはパッケージのpyproject.tomlファイルに追加する依存関係のバージョンを指定することができます。 "
"しかし、デフォルトの上限アプローチはパッケージによっては問題があります(依存関係を追加するときはデフォルトの設定を上書きすることをお勧めします)。"
" 詳しくは以下をお読みください。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry allows you to either use its built in environment or you can "
"select the environment type that you want to use for managing your "
"package. [Read more about its built in environment management "
"options](https://python-poetry.org/docs/basic-usage/#using-your-virtual-"
"environment)."
msgstr ""
"Poetryでは、ビルトイン環境を使用するか、パッケージ管理に使用する環境タイプを選択することができます。 "
"[内蔵された環境管理オプションについての詳細はこちら](https://python-poetry.org/docs/basic-usage"
"/#using-your-virtual-environment) 。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Lock files"
msgstr "ファイルのロック"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry creates a **poetry.lock** file that you can use if you need a lock"
" file for your build."
msgstr "Poetryは **poetry.lock** ファイルを作成するので、ビルドにロックファイルが必要な場合に使用します。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Poetry supports publishing to both test PyPI and PyPI"
msgstr "Poetry は test PyPI と PyPI の両方への公開をサポートしています"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"The plugin [Poetry dynamic versioning](https://github.com/mtkennerly"
"/poetry-dynamic-versioning) supports versioning using git tags with "
"Poetry."
msgstr ""
"[Poetry dynamic versioning](https://github.com/mtkennerly/poetry-dynamic-"
"versioning) プラグインは、Poetryでgitタグを使ったバージョン管理をサポートします。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""
"Poetryでは、標準的なセマンティックバージョン用語である patch; minor; major "
"を使ってパッケージのバージョンを上げることができます。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "✖✅"
msgstr "✖✅"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry does not quite support current packaging standards for adding "
"metadata to the **pyproject.toml** file but plans to fix this in an "
"upcoming release."
msgstr ""
"Poetryは **pyproject.toml** "
"ファイルにメタデータを追加する現在のパッケージング標準を完全にサポートしているわけではありませんが、今後のリリースでこれを修正する予定です。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry supports installing your package in editable mode using "
"`--editable`"
msgstr "Poetry は `--editable` を使った編集可能モードでのパッケージのインストールをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Poetry will build your sdist and wheel distributions using `poetry build`"
msgstr "Poetry は `poetry build` を使って sdist と wheel ディストリビューションをビルドします。"

#: ../../package-structure-code/python-package-build-tools.md:407
msgid "Challenges with Poetry"
msgstr "Poetryの課題"

#: ../../package-structure-code/python-package-build-tools.md:409
msgid "Some challenges of Poetry include:"
msgstr "Poetryの課題には次のようなものがある:"

#: ../../package-structure-code/python-package-build-tools.md:411
msgid ""
"Poetry, by default, pins dependencies using an \"upper bound\" limit "
"specified with the `^` symbol by default. However, this behavior can be "
"over-written by specifying the dependency when you use `Poetry add` as "
"follows: `poetry add \"requests>=2.1\"` See breakout below for more "
"discussion on issues surrounding upper-bounds pinning."
msgstr ""
"Poetryは、デフォルトでは、`^`シンボルで指定された \"上限\" 制限を使用して依存関係をピンします。 しかし、この動作は `Poetry"
" add` を使うときに依存関係を以下のように指定することで上書きすることができます: `poetry add "
"\"requests>=2.1\"` アッパーバウンドピニングをめぐる問題については、以下のブレイクアウトを参照のしてください。"

#: ../../package-structure-code/python-package-build-tools.md:412
msgid ""
"_Minor Challenge:_ The way Poetry currently adds metadata to your "
"pyproject.toml file does not follow current Python standards. However, "
"this is going to be addressed with Poetry release version 2.0."
msgstr ""
"_マイナーチェンジ:_ "
"Poetryが現在pyproject.tomlファイルにメタデータを追加する方法は、現在のPythonの標準に従っていません。 しかし、これは "
"Poetry リリースバージョン 2.0 で対処される予定です。"

#: ../../package-structure-code/python-package-build-tools.md:414
msgid ""
"Poetry is an excellent tool. Use caution when using it to pin "
"dependencies as Poetry's approach to pinning can be problematic for many "
"builds. If you use Poetry, we strongly suggest that you override the "
"default upper bound dependency option."
msgstr ""
"Poetryは優れたツールです。 依存関係を固定するために Poetry を使う場合は注意してください。Poetry "
"の固定方法は、多くのビルドで問題になる可能性があります。 Poetry "
"を使用する場合は、デフォルトの上限依存性オプションをオーバーライドすることを強く推奨します。"

#: ../../package-structure-code/python-package-build-tools.md:420
msgid "Challenges with Poetry dependency pinning"
msgstr "Poetry依存のピン留めの課題"

#: ../../package-structure-code/python-package-build-tools.md:423
msgid ""
"By default, Poetry pins dependencies using `^` by default. This `^` "
"symbol means that there is an \"upper bound\" to the dependency. Thus "
"poetry won't bump a dependency version to a new major version. Thus, if "
"your package uses a dependency that is at version 1.2.3, Poetry will "
"never bump the dependency to 2.0 even if there is a new major version of "
"the package. Poetry will instead bump up to 1.9.x."
msgstr ""
"デフォルトでは、Poetry は `^` を使って依存関係をピン留めします。 このシンボル `^` は依存関係に \"上限\" "
"があることを意味します。 従って、poetryは依存バージョンを新しいメジャーバージョンにバンプすることはありません。 "
"したがって、あなたのパッケージがバージョン1.2.3の依存関係を使用している場合、Poetryは、パッケージの新しいメジャーバージョンがあっても、依存関係を2.0にバンプすることはありません。"
" Poetryは代わりに1.9.xにアップグレードします。"

#: ../../package-structure-code/python-package-build-tools.md:429
msgid ""
"Poetry does this because it adheres to strict semantic versioning which "
"states that a major version bump (from 1.0 to 2.0 for example) means "
"there are breaking changes in the tool. However, not all tools follow "
"strict semantic versioning. [This approach has been found to be "
"problematic by many of our core scientific "
"packages.](https://iscinumpy.dev/post/bound-version-constraints/)"
msgstr ""
"Poetryは、メジャーバージョンアップ（例えば1.0から2.0へ）は、ツールに破壊的な変更があることを意味するという、厳密なセマンティックバージョニングを遵守しているからです。"
" しかし、すべてのツールが厳密なセマンティックバージョニングに従っているわけではありません。 "
"[このアプローチは、私たちのコアとなる科学パッケージの多くによって問題があることが判明しています](https://iscinumpy.dev/post"
"/bound-version-constraints/)"

#: ../../package-structure-code/python-package-build-tools.md:434
msgid ""
"This approach also won't support others ways of versioning tools, for "
"instance, some tools use [calver](https://calver.org/) which creates new "
"versions based on the date."
msgstr "例えば、 [calver](https://calver.org/) を使って、日付に基づいて新しいバージョンを作成するツールもある。"

#: ../../package-structure-code/python-package-build-tools.md:438
msgid "Using Setuptools Back-end for Python Packaging with Build Front-end"
msgstr "PythonパッケージングのためのSetuptoolsバックエンドとBuildフロントエンドの使用"

#: ../../package-structure-code/python-package-build-tools.md:440
msgid ""
"[Setuptools](https://setuptools.pypa.io/en/latest/) is the most mature "
"Python packaging build tool with [development dating back to 2009 and "
"earlier](https://setuptools.pypa.io/en/latest/history.html#). Setuptools "
"also has the largest number of community users (according to the PyPA "
"survey). Setuptools does not offer a user front-end like Flit, Poetry and"
" Hatch offer. As such you will need to use other tools such as **build** "
"to create your package distributions and **twine** to publish to PyPI."
msgstr ""
"[Setuptools](https://setuptools.pypa.io/en/latest/)は最も成熟したPythonパッケージングビルドツールで、[開発は2009年以前にさかのぼります](https://setuptools.pypa.io/en/latest/history.html#)。"
" また、（PyPAの調査によると）Setuptoolsは最も多くのコミュニティユーザを抱えています。 "
"Setuptoolsは、Flit、Poetry、Hatchのようなユーザーフロントエンドを提供していません。そのため、パッケージの配布を作成するには"
" **build** を、PyPI に公開するには **twine** などの他のツールを使用する必要があります。"

#: ../../package-structure-code/python-package-build-tools.md:448
msgid ""
"While setuptools is the most commonly used tool, we encourage package "
"maintainers to consider using a more modern tool for packaging such as "
"Poetry, Hatch or PDM."
msgstr "setuptoolsは最もよく使われるツールですが、パッケージメンテナには、PoetryやHatch、PDMなど、パッケージングにもっとモダンなツールを使うことを検討することをお勧めします。"

#: ../../package-structure-code/python-package-build-tools.md:451
msgid ""
"We discuss setuptools here because it's commonly found in the ecosystem "
"and contributors may benefit from understanding it."
msgstr "ここでsetuptoolsについて説明するのは、それがエコシステムでよく見られるものであり、貢献者がそれを理解することで恩恵を受けるかもしれないからです。"

#: ../../package-structure-code/python-package-build-tools.md:454
msgid "Setuptools Features"
msgstr "Setuptoolsの特徴"

#: ../../package-structure-code/python-package-build-tools.md:456
msgid "Some of features of setuptools include:"
msgstr "setuptoolsの機能には次のようなものがあります:"

#: ../../package-structure-code/python-package-build-tools.md:458
msgid "Fully customizable build workflow"
msgstr "完全にカスタマイズ可能なビルドワークフロー"

#: ../../package-structure-code/python-package-build-tools.md:459
msgid "Many scientific Python packages use it."
msgstr "多くの科学的Pythonパッケージがこれを使用しています。"

#: ../../package-structure-code/python-package-build-tools.md:460
msgid ""
"It offers version control based package versioning using "
"**setuptools_scm**"
msgstr "**setuptools_scm** を使用したバージョン管理ベースのパッケージのバージョン管理を提供します。"

#: ../../package-structure-code/python-package-build-tools.md:461
msgid "It supports modern packaging using **pyproject.toml** for metadata"
msgstr "メタデータに **pyproject.toml** を使用した最新のパッケージングをサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:462
msgid "Supports backwards compatibly for older packaging approaches."
msgstr "古いパッケージングアプローチの下位互換性をサポートします。"

#: ../../package-structure-code/python-package-build-tools.md:464
msgid "Challenges using setuptools"
msgstr "setuptoolsの課題"

#: ../../package-structure-code/python-package-build-tools.md:468
msgid "Setuptools has a few challenges:"
msgstr "Setuptoolsにはいくつかの課題があります:"

#: ../../package-structure-code/python-package-build-tools.md:470
msgid ""
"Setuptools does not support interactive features such as auto / tab "
"completion by default if you are working in an IDE like VSCODE and using "
"an editable install for development. [See notes here about pylance "
"support](https://github.com/microsoft/pylance-"
"release/blob/main/TROUBLESHOOTING.md#editable-install-modules-not-found)."
" In comparison, tools such as flit, hatch, PDM support interactive "
"features such as tab / auto completion when using an IDE like VSCODE or "
"pycharm (as long as your version of pip is current!)."
msgstr ""
"Setuptoolsは、VSCODEのようなIDEで作業し、編集可能なインストーラを開発に使用している場合、デフォルトでは自動/タブ補完のようなインタラクティブな機能をサポートしていません。"
" [pylanceのサポートについてはこちらを参照](https://github.com/microsoft/pylance-"
"release/blob/main/TROUBLESHOOTING.md#editable-install-modules-not-found) "
"。 "
"それに比べて、flit、hatch、PDMのようなツールは、VSCODEやpycharmのようなIDE（pipのバージョンが最新である限り!）を使っているときに、タブや自動補完のようなインタラクティブな機能をサポートしています。"

#: ../../package-structure-code/python-package-build-tools.md:471
msgid ""
"Because **setuptools** has to maintain backwards compatibility across a "
"range of packages, it is not as flexible in its adoption of modern Python"
" packaging standards."
msgstr ""
"**setuptools** "
"は様々なパッケージの後方互換性を維持しなければならないため、最新のPythonパッケージング標準を採用する柔軟性がありません。"

#: ../../package-structure-code/python-package-build-tools.md:474
msgid ""
"The above-mentioned backwards compatibility makes for a more complex "
"code-base."
msgstr "上記の後方互換性は、より複雑なコードベースとなります。"

#: ../../package-structure-code/python-package-build-tools.md:475
msgid ""
"Your experience as a user will be less streamlined and simple using "
"setuptools compared to other tools discussed on this page."
msgstr "このページで説明する他のツールに比べ、setuptoolsを使用した場合、ユーザーとしての体験は合理的でシンプルなものではなくなります。"

#: ../../package-structure-code/python-package-build-tools.md:477
msgid ""
"There are also some problematic default settings that users should be "
"aware of when using setuptools. For instance:"
msgstr "また、setuptoolsを使用する際にユーザーが注意すべき、問題のあるデフォルト設定がいくつかあります。 例えば:"

#: ../../package-structure-code/python-package-build-tools.md:480
msgid ""
"setuptools will build a project without a name or version if you are not "
"using a **pyproject.toml** file to store metadata."
msgstr ""
"メタデータを保存するために **pyproject.toml** "
"ファイルを使用していない場合、setuptoolsは名前やバージョンなしでプロジェクトをビルドします。"

#: ../../package-structure-code/python-package-build-tools.md:482
msgid ""
"setuptools also will include all of the files in your package repository "
"if you do not explicitly tell it to exclude files using a **MANIFEST.in**"
" file"
msgstr ""
"setuptoolsは、 **MANIFEST.in** "
"ファイルを使ってファイルを除外するように明示的に指示しなければ、パッケージリポジトリ内のすべてのファイルも含めます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:1
msgid "Learn about Building a Python Package"
msgstr "Pythonパッケージのビルドについて学ぶ"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:8
#, fuzzy
msgid ""
"Once you have published both package distributions (the source "
"distribution and the wheel) to PyPI, you can then publish to conda-forge."
" The conda-forge requires an source distribution on PyPI in order to "
"build your package on conda-forge. You do not need to rebuild your "
"package to publish to conda-forge."
msgstr ""
"両方のパッケージ配布(ソース配布とホイール)をPyPIに公開したら、次にconda-forgeに公開します。conda-"
"forgeでパッケージをビルドするには、PyPIでのソース配布が必要です。conda-"
"forgeに公開するためにパッケージをリビルドする必要はありません。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:11
msgid ""
"You need to build your Python package in order to publish it to PyPI (or "
"a conda channel). The build process organizes your code and metadata into"
" a distribution format that can be uploaded to PyPI and subsequently "
"downloaded and installed by users. NOTE: you need to publish a sdist to "
"PyPI in order for conda-forge to properly build your package "
"automatically."
msgstr ""
"PythonパッケージをPyPI（またはcondaチャンネル）に公開するには、ビルドする必要があります。ビルドプロセスは、あなたのコードとメタデータをPyPIにアップロードできる配布フォーマットに整理し、その後ユーザーがダウンロードしてインストールできるようにします。"
" 注意: conda-forgeが適切にパッケージを自動ビルドするためには、sdistをPyPIに公開する必要があります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:14
msgid "What is building a Python package?"
msgstr "Pythonパッケージのビルドとは何ですか？"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:16
msgid ""
"To [publish your Python package](publish-python-package-pypi-conda) and "
"make it easy for anyone to install, you first need to build it."
msgstr ""
"[Pythonパッケージを公開](publish-python-package-pypi-conda) "
"し、誰でも簡単にインストールできるようにするには、まずそれをビルドする必要があります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:18
msgid "But, what does it mean to build a Python package?"
msgstr "しかし、Pythonのパッケージを作るとは何ですか？"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:20
msgid ""
"[As shown in the figure above](#pypi-conda-channels), when you build your"
" Python package, you convert the source files into something called a "
"distribution package. A distribution package contains your source code "
"and metadata about the package, in the format required by the Python "
"Package Index, so that it can be installed by tools like pip."
msgstr ""
"[上の図のように](#pypi-conda-channels), "
"Pythonパッケージをビルドするとき、ソースファイルをディストリビューションパッケージと呼ばれるものに変換します。 "
"配布パッケージには、あなたのソースコードとパッケージのメタデータが、 Python Package Index が要求する形式で含まれています。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:23
msgid ""
"The term package used to mean many different things in Python and other "
"languages. On this page, we adapt the convention of the [Python Packaging"
" Authority](https://www.pypa.io/en/latest/) and refer to the product of "
"the build step as a **distribution package**."
msgstr ""
"Pythonや他の言語では、パッケージという言葉は様々な意味で使われています。 このページでは、　[Python Packaging "
"Authority](https://www.pypa.io/en/latest/) の慣例に合わせ、ビルドステップの成果物を "
"**配布パッケージ** と呼ぶことにします。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:27
msgid ""
"This process of organizing and formatting your code, documentation, tests"
" and metadata into a format that both pip and PyPI can use, is called a "
"build step."
msgstr "あなたのコード、ドキュメント、テスト、メタデータをpipとPyPIの両方が使える形式に整理し、フォーマットするこのプロセスは、ビルドステップと呼ばれます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:31
msgid "Project metadata and PyPI"
msgstr "プロジェクトのメタデータとPyPI"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:33
msgid ""
"The metadata that both build tools and PyPI uses to describe and "
"understand your package is generally stored in a [pyproject.toml file"
"](pyproject-toml-python-package-metadata). This metadata is used for "
"several purposes:"
msgstr ""
"ビルドツールとPyPIの両方があなたのパッケージを説明し理解するために使うメタデータは、一般的に [pyproject.tomlファイル"
"](pyproject-toml-python-package-metadata) に格納されます。 "
"このメタデータはいくつかの目的で使用されます:"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:35
msgid ""
"It helps whatever tool you use to build your package (pip, [pypa's "
"Build](https://pypi.org/project/build/) or an end-to-end tool such as "
"poetry, PDM or Hatch) understand how to build your package. Information "
"it provides to your build tool includes:"
msgstr ""
"パッケージのビルドに使用するツール(pip、 [pypa's Build](https://pypi.org/project/build/) "
"、またはpoetry、PDM、Hatchのようなエンドツーエンドツール)があなたのパッケージのビルド方法を理解するのに役立ちます。ビルドツールに提供される情報には以下のものがあります:"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:37
msgid ""
"The `[build-system]` table in your pyproject.toml file tells pip what "
"[build backend tool](build_backends) you wish to use for creating your "
"sdist and wheel distributions."
msgstr ""
"pyproject.tomlファイルの `[build-system]` "
"テーブルは、sdistとwheelディストリビューションの作成に使用したい [ビルドバックエンドツール](build_backends) "
"をpipに伝えます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:45
msgid ""
"And the dependencies section of your project table tells the build tool "
"and PyPI what dependencies your project requires."
msgstr "また、プロジェクトテーブルの dependencies セクションは、ビルドツールと PyPI にプロジェクトが必要とする依存関係を伝えます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:54
msgid ""
"When the build tool creates your package distribution file (the file that"
" you publish on PyPI), it also creates a METADATA file which PyPI can "
"read and use to help users find your package. For example:"
msgstr ""
"ビルドツールがパッケージ配布ファイル（PyPIで公開するファイル）を作成するとき、PyPIが読み込んでユーザがあなたのパッケージを見つけるのに役立つMETADATAファイルも作成します。"
" 例えば:"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:56
msgid ""
"The `classifiers = ` section of your `[project]` table in the "
"pyproject.toml file provides information that users on PyPI can use to "
"filter for packages that contain specific licenses or that support "
"specific versions of python."
msgstr ""
"pyproject.tomlファイルの `[project]` テーブルの `classifiers = ` "
"セクションは、PyPIのユーザが特定のライセンスを含むパッケージや特定のバージョンのpythonをサポートするパッケージをフィルタリングするための情報を提供します。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:73
msgid "What happened to setup.py and setup.cfg for metadata?"
msgstr "メタデータのsetup.pyとsetup.cfgはどうなったのですか？"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:76
msgid ""
"Project metadata used to be stored in either a setup.py file or a "
"setup.cfg file. The current recommended practice for storing package "
"metadata is to use a pyproject.toml file. [Learn more about the "
"pyproject.toml file here.](pyproject-toml-python-package-metadata)"
msgstr ""
"プロジェクトのメタデータは、以前は setup.py ファイルか setup.cfg "
"ファイルに保存されていました。パッケージのメタデータを保存するために現在推奨されている方法は、pyproject.tomlファイルを使用することです。"
" [pyproject.tomlファイルについての詳細はこちらです。](pyproject-toml-python-package-"
"metadata)"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:79
msgid "An example - xclim"
msgstr "例 - xclim"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:81
#, fuzzy
msgid ""
"When you publish to PyPI, you will notice that each package has metadata "
"listed. Let's have a look at [xclim](https://pypi.org/project/xclim/), "
"one of our [pyOpenSci packages](https://www.pyopensci.org/python-"
"packages.html). Notice that on the PyPI landing page you see some "
"metadata about the package including python, maintainer information and "
"more. PyPI is able to populate this metadata because it was defined using"
" correct syntax and classifiers by Xclim's maintainers, [pyproject.toml "
"file](https://github.com/Ouranosinc/xclim/blob/master/pyproject.toml). "
"This metadata when the xclim package is built, is translated into a "
"distribution file that allows PyPI to read the metadata and print it out "
"on their website."
msgstr ""
"PyPIに公開すると、各パッケージにメタデータがリストされていることに気づくでしょう。[pyOpenSciパッケージ](https://www.pyopensci.org"
"/python-packages.html) の一つである [xclim](https://pypi.org/project/xclim/) "
"を見てみましょう。PyPIのランディングページには、pythonやメンテナ情報など、パッケージに関するメタデータが表示されていることに注目してください。PyPIは、Xclimのメンテナ"
" [pyproject.toml "
"file](https://github.com/Ouranosinc/xclim/blob/master/pyproject.toml) "
"によって正しい構文と分類子を用いて定義されたメタデータを入力することができます。xclimパッケージがビルドされるとき、このメタデータは配布ファイルに変換され、PyPIがメタデータを読み込んでウェブサイトに出力できるようになります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:94
#, fuzzy
msgid ""
"Graphic showing the high level packaging workflow. On the left you see a "
"graphic with code, metadata and tests in it. Those items all go into your"
" package. Documentation and data are below that box because they aren't "
"normally published in your packaging wheel distribution. An arrow to the "
"right takes you to a build distribution files box. That box leads you to "
"either publishing to TestPyPI or the real PyPI. From PyPI you can then "
"connect to conda-forge for an automated build that sends distributions "
"from PyPI to conda-forge."
msgstr ""
"ハイレベルなパッケージングのワークフローを示すグラフィックです。左側には、コード、メタデータ、テストが入ったグラフィックがあります。ドキュメンテーションやデータは、通常、パッケージホイールの配布物には掲載されないため、そのボックスの下にあります。右の矢印は、ビルド配布ファイルのボックスに移動します。このボックスは、TestPyPIか本物のPyPIのどちらかに公開するように導きます"
"。PyPIからconda-forgeに接続し、ディストリビューションをPyPIからconda-forgeに送る自動ビルドを行うことができます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:96
msgid ""
"You need to build your Python package in order to publish it to PyPI (or "
"Conda). The build process organizes your code and metadata into a "
"distribution format that can be uploaded to PyPI and subsequently "
"downloaded and installed by users. NOTE: you need to publish a sdist to "
"PyPI in order for conda-forge to properly build your package "
"automatically."
msgstr ""
"PythonパッケージをPyPI（またはConda）に公開するには、ビルドする必要があります。ビルドプロセスは、あなたのコードとメタデータをPyPIにアップロードできる配布フォーマットに整理し、その後ユーザーがダウンロードしてインストールできるようにします。"
" 注意: conda-forgeが適切にパッケージを自動ビルドするためには、sdistをPyPIに公開する必要があります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:101
#, fuzzy
msgid ""
"This screenshot shows the metadata on PyPI for the xclim package. On it "
"you can see the name of the license, the author and maintainer names "
"keywords associated with the package and the base python version it "
"requires which is 3.8."
msgstr "このスクリーンショットは、PyPI上のxclimパッケージのメタデータを示しています。そこには、ライセンスの名前、そのパッケージに関連する作者とメンテナの名前のキーワード、そしてそのパッケージが必要とするpythonの基本バージョン3.8が表示されています。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:103
msgid "PyPI screenshot showing metadata for the xclim package."
msgstr "xclimパッケージのメタデータを示すPyPIのスクリーンショット。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:110
#, fuzzy
msgid ""
"Here you see the maintainer metadata as it is displayed on PyPI. For "
"xclim there are three maintainers listed with their profile pictures and "
"github user names to the right."
msgstr "ここでは、PyPIに表示されているメインテナメタデータを見ることができます。xclimの場合、3人のメンテナがリストアップされており、右側にプロフィール写真とgithubユーザー名が表示されています。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:112
msgid ""
"Maintainer names and GitHub usernames for the xclim package as they are "
"displayed on PyPI. This information is recorded in your pyproject.toml "
"and then processed by your build tool and stored in your packages sdist "
"and wheel distributions."
msgstr ""
"PyPI に表示されている xclim パッケージのメンテナ名と GitHub ユーザ名。 "
"この情報はpyproject.tomlに記録され、ビルドツールで処理され、パッケージのsdistとwheelディストリビューションに保存されます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:115
msgid "How to create the distribution format that PyPI and Pip expects?"
msgstr "PyPIやPipが期待する配布フォーマットを作るには？"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:117
msgid ""
"You could in theory create your own scripts to organize your code the way"
" PyPI wants it to be. However, just like there are packages that handle "
"known structures such as Pandas for data frames and Numpy for arrays, "
"there are packages and tools that help you create package build "
"distribution files."
msgstr ""
"理論的には、PyPIが望むようにコードを整理する独自のスクリプトを作成することができます。 "
"しかし、データフレーム用のPandasや配列用のNumpyのような既知の構造を扱うパッケージがあるように、パッケージのビルド配布ファイルの作成を支援するパッケージやツールがあります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:121
msgid ""
"There are a suite of packaging tools that can either help you with the "
"entire packaging process or just one step of the process. For instance "
"setuptools is a commonly used build back end that can be used to create "
"your sdist and wheel. Whereas tools like Hatch, PDM, Poetry and flit help"
" with other parts of the packaging process."
msgstr ""
"パッケージングツールには、パッケージングプロセス全体を支援するものもあれば、プロセスの1ステップだけを支援するものもあります。 "
"例えばsetuptoolsはよく使われるビルドバックエンドで、sdistやwheelの作成に使うことができます。 "
"一方、Hatch、PDM、Poetry、flitのようなツールは、パッケージングプロセスの他の部分を支援します。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:127
msgid ""
"While this can cause some confusion and complexity in the packaging "
"ecosystem - for the most part, each tool provides the same distribution "
"output (with minor differences that most users may not care about). Learn"
" more about those tools on this page."
msgstr ""
"これは、パッケージングエコシステムに混乱と複雑さをもたらす可能性がありますが、ほとんどの場合、各ツールは同じ配布出力を提供します（ほとんどのユーザーが気にしないような小さな違いはあります）。"
" これらのツールの詳細については、このページを参照してください。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:133
msgid ""
"Below, you will learn about the two distribution files that PyPI expects "
"you to publish: sdist and wheel. You will learn about their structure and"
" what files belong in each."
msgstr ""
"以下では、PyPIが公開することを期待している2つの配布ファイル、sdistとwheelについて学びます。 "
"sdistとwheelです。それぞれの構造と、どのようなファイルがあるのかについて学びます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:136
msgid ""
"There are two core distribution files that you need to create to publish "
"your Python package to PyPI source distribution (often called an sdist) "
"and wheel. The sdist contains the raw source code for your package. The "
"wheel (.whl) contains the built / compiled files that can be directly "
"installed onto anyones' computer."
msgstr ""
"PythonパッケージをPyPIに公開するために作成する必要がある配布ファイルは、ソース配布(sdist)とwheelの2つです。 "
"sdistにはパッケージの生のソースコードが含まれています。 "
"wheel(.whl)には、ビルド/コンパイルされたファイルが含まれており、誰のコンピュータにも直接インストールすることができます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:142
msgid "Learn more about both distributions below."
msgstr "両ディストリビューションの詳細は以下の通りです。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:145
msgid ""
"If your package is a pure python package with no additional build / "
"compilation steps then the sdist and wheel distributions will have "
"similar content. However if your package has extensions in other "
"languages or is more complex in its build, the two distributions will be "
"very different."
msgstr ""
"もし、あなたのパッケージが追加のビルド/コンパイルステップのない純粋なpythonパッケージであれば、sdistとwheelのディストリビューションは似たような内容になるでしょう。"
" "
"しかし、もしあなたのパッケージが他の言語での拡張機能を持っていたり、ビルドがより複雑であったりする場合、2つのディストリビューションは大きく異なるでしょう。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:150
msgid ""
"Also note that we are not discussing conda build workflows in this "
"section. [You can learn more about conda builds "
"here.](https://conda.io/projects/conda-build/en/latest/user-"
"guide/tutorials/index.html)"
msgstr ""
"また、このセクションではcondaのビルドワークフローについては触れないことに注意してください。 "
"[condaのビルドについてはこちらで詳しく説明しています](https://conda.io/projects/conda-"
"build/en/latest/user-guide/tutorials/index.html)"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:155
#, fuzzy
msgid "What is a source distribution (sdist)"
msgstr "ソースディストリビューション (sdist)"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:157
msgid ""
"**Source files** are the unbuilt files needed to build your package. "
"These are the \"raw / as-is\" files that you store on GitHub or whatever "
"platform you use to manage your code."
msgstr ""
"**ソースファイル** は、パッケージをビルドするために必要な、ビルドされていないファイルです。 "
"これらは、GitHubやあなたがコードを管理するために使っているプラットフォームに保存する \"raw / as-is\" ファイルです。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:161
msgid ""
"Source Distributions (**S** + **Dist**) are referred to as sdist. As the "
"name implies, a SDIST contains the source code; it has not been built or "
"compiled in any way. Thus, when a user installs your source distribution "
"using pip, pip needs to run a build step first. For this reason, you "
"could define a source distribution as a compressed archive that contains "
"everything required to build a wheel (except for project dependencies) "
"without network access."
msgstr ""
"Source Distributions（**S** + "
"**Dist**）はsdistと呼ばれます。その名の通り、SDISTにはソースコードが含まれています; ビルドもコンパイルもされていません。 "
"したがって、ユーザーがpipを使ってソースディストリビューションをインストールする場合、pipは最初にビルドステップを実行する必要があります。 "
"このため、ソース・ディストリビューションを、（プロジェクトの依存関係を除いた）ホイールのビルドに必要なすべてを含む圧縮アーカイブとして、ネットワークアクセスなしで定義することができます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:165
msgid ""
"Sdist is normally stored as a `.tar.gz` archive (often called a "
"\"tarball\"). Thus, when a user installs your source distribution using "
"pip, pip needs to run a build step first."
msgstr ""
"Sdist は通常、 `.tar.gz` アーカイブ (しばしば \"tarball\" と呼ばれます) として保存されます。 "
"そのため、ユーザーが pip を使用してソースディストリビューションをインストールする場合、pip "
"は最初にビルドステップを実行する必要があります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:167
msgid "Below is an example sdist for the stravalib Python package:"
msgstr "以下はstravalib Pythonパッケージのsdistの例です:"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:219
msgid "GitHub archive vs sdist"
msgstr "GitHubアーカイブとsdistの比較"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:221
msgid ""
"When you make a release on GitHub, it creates a `git archive` that "
"contains all of the files in your GitHub repository. While these files "
"are similar to an sdist, these two archives are not the same. The sdist "
"contains a few other items including a metadata directory and if you use "
"`setuptools_scm` or `hatch_vcs` the sdist may also contain a file that "
"stores the version."
msgstr ""
"GitHub でリリースを作成すると、GitHub リポジトリ内のすべてのファイルを含む `git archive` "
"が作成されます。これらのファイルはsdistと似ているが、これら2つのアーカイブは同じではない。sdistには、メタデータ・ディレクトリーや、 "
"`setuptools_scm` や `hatch_vcs` を使う場合はバージョンを保存するファイルなど、他にもいくつかの項目が含まれています。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:229
msgid "What is a Python wheel (whl):"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:231
msgid ""
"A wheel file is a ZIP-format archive whose filename follows a specific "
"format (below) and has the extension `.whl`. The `.whl` archive contains "
"a specific set of files, including metadata that are generated from your "
"project's pyproject.toml file. The pyproject.toml and other files that "
"may be included in source distributions are not included in wheels "
"because it is a built distribution."
msgstr ""
"ホイールファイルはZIP形式のアーカイブで、ファイル名は特定のフォーマット（下記）に従い、拡張子は `.whl` です。 `.whl` "
"アーカイブには、プロジェクトのpyproject.tomlファイルから生成されたメタデータを含む特定のファイル群が含まれています。 "
"pyproject.tomlや、ソース配布物に含まれる可能性のあるその他のファイルは、ビルドされた配布物であるため、wheelには含まれません。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:238
msgid ""
"The wheel (.whl) is your built binary distribution. **Binary files** are "
"the built / compiled source files. These files are ready to be installed."
" A wheel (**.whl**) is a **zip** file containing all of the files needed "
"to directly install your package. All of the files in a wheel are "
"binaries - this means that code is already compiled / built. Wheels are "
"thus faster to install - particularly if you have a package that requires"
" build steps."
msgstr ""
"wheel（.whl）は、ビルドされたバイナリーディストリビューションです。 **バイナリファイル** "
"は、ビルド/コンパイルされたソースファイルです。 これらのファイルはすぐにインストールできます。 wheel (**.whl**) "
"は、パッケージを直接インストールするために必要な すべてのファイルを含む **zip** ファイルです。 "
"wheelに含まれるファイルはすべてバイナリで、これはコードがすでにコンパイル/ビルドされていることを意味します。 "
"wheelの取り付けがより迅速に - 特にビルド・ステップが必要なパッケージの場合はそうなります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:240
msgid ""
"The wheel does not contain any of your package's configuration files such"
" as **setup.cfg** or **pyproject.toml**. This distribution is already "
"built so it's ready to install."
msgstr ""
"ホイールには、**setup.cfg** や **pyproject.toml** のようなパッケージの設定ファイルは含まれていません。 "
"このディストリビューションはすでにビルドされていますので、すぐにインストールできます。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:244
msgid ""
"Because it is built, the wheel file will be faster to install for pure "
"Python projects and can lead to consistent installs across machines."
msgstr ""
"ビルドされているため、純粋な Python プロジェクトでは wheel "
"ファイルのインストールが速くなり、マシン間で一貫したインストールができるようになります。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:252
msgid ""
"Wheels are also useful in the case that a package needs a **setup.py** "
"file to support a more complex build. In this case, because the files in "
"the wheel bundle are pre built, the user installing doesn't have to worry"
" about malicious code injections when it is installed."
msgstr ""
"ウィールは、パッケージがより複雑なビルドをサポートするために **setup.py** ファイルを必要とする場合にも便利です。 "
"この場合、wheelバンドルのファイルはあらかじめビルドされているので、インストールするユーザはインストール時に悪意のあるコードインジェクションを心配する必要がありません。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:259
msgid "The filename of a wheel contains important metadata about your package."
msgstr "wheelのファイル名には、パッケージに関する重要なメタデータが含まれています。"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:261
msgid "Example: **stravalib-1.1.0.post2-py3-none.whl**"
msgstr "例: **stravalib-1.1.0.post2-py3-none.whl**"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:263
msgid "name: stravalib"
msgstr "名前: stravalib"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:264
msgid "version: 1.1.0"
msgstr "version: 1.1.0"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:265
msgid ""
"build-number: 2 (post2) [(read more about post "
"here)](https://peps.python.org/pep-0440/#post-release-separators)"
msgstr ""
"ビルド番号: 2 (post2) [(read more about post "
"here)](https://peps.python.org/pep-0440/#post-release-separators)"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:266
msgid "py3: supports Python 3.x"
msgstr "py3: Python 3.x をサポート"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:267
msgid "none: is not operating system specific (runs on windows, mac, linux)"
msgstr "none: オペレーティングシステムに依存しない (Windows、Mac、Linuxで動作)"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:268
msgid "any: runs on any computer processor / architecture"
msgstr "any: あらゆるコンピュータ・プロセッサ/アーキテクチャで動作"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:270
msgid "What a wheel file looks like when unpacked (unzipped):"
msgstr "ホイールファイルを解凍 (unzipped) するとどのように見えるか:"

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:304
msgid "[Read more about the wheel format here](https://pythonwheels.com/)"
msgstr "[wheelフォーマットについての詳細はこちら](https://pythonwheels.com/)"

#: ../../package-structure-code/python-package-structure.md:1
msgid "Python Package Structure for Scientific Python Projects"
msgstr "科学的PythonプロジェクトのためのPythonパッケージ構造"

#: ../../package-structure-code/python-package-structure.md:3
#, fuzzy
msgid ""
"There are two different layouts that you will commonly see within the "
"Python packaging ecosystem: src and flat layouts. Both layouts have "
"advantages for different groups of maintainers."
msgstr ""
"Pythonのパッケージングエコシステムでよく見られるレイアウトは2種類あります。: "
"[srcとフラットレイアウト。](https://packaging.python.org/en/latest/discussions/src-"
"layout-vs-flat-layout/) どちらのレイアウトも、異なるメンテナグループにとって利点があります。"

#: ../../package-structure-code/python-package-structure.md:8
#, fuzzy
msgid ""
"We strongly suggest, but do not require, that you use the **src/** layout"
" (discussed below) for creating your Python package. This layout is also "
"recommended in the [PyPA packaging guide "
"tutorial](https://packaging.python.org/en/latest/tutorials/packaging-"
"projects/)."
msgstr ""
"Python パッケージの作成には **src/** レイアウト (後述) を使うことを強く推奨しますが、必須ではありません。 このレイアウトは、"
" [PyPA packaging guide](https://packaging.python.org/en/latest/tutorials"
"/packaging-projects/) でも推奨されています。"

#: ../../package-structure-code/python-package-structure.md:12
msgid "pyOpenSci will never require a specific package structure for peer review"
msgstr "pyOpenSciは査読のために特定のパッケージ構造を要求することはありません"

#: ../../package-structure-code/python-package-structure.md:15
#, fuzzy
msgid ""
"We understand that it would take significant effort for existing "
"maintainers to move to a new layout."
msgstr "新しいレイアウトに移行することは、既存のメンテナンス担当者にとって多大な労力となることは理解しています。"

#: ../../package-structure-code/python-package-structure.md:18
msgid ""
"The overview on this page presents recommendations that we think are best"
" for someone getting started with Python packaging or someone who's "
"package has a simple build and might be open to moving to a more fail-"
"proof approach."
msgstr ""
"このページの概要では、これから Python "
"のパッケージングを始める人や、パッケージがシンプルなビルドで、より失敗のないアプローチに移行することに前向きな人に最適だと思われる推奨事項を紹介します。"

#: ../../package-structure-code/python-package-structure.md:22
msgid "Other resources you can check out:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:23
msgid ""
"[PyPA's overview of src vs flat "
"layouts](https://packaging.python.org/en/latest/discussions/src-layout-"
"vs-flat-layout/)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:26
msgid ""
"You can use tools like Hatch to quickly create a modern Python package "
"structure. Check out our quickstart tutorial:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:29
msgid ""
"Want to learn how to create the structure to build your package? Click "
"here."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:37
#, fuzzy
msgid "What is the Python package source layout?"
msgstr "フラットなPythonパッケージレイアウトについて"

#: ../../package-structure-code/python-package-structure.md:39
#, fuzzy
msgid "An example of the **src/package** layout structure is below."
msgstr "**src/package** のレイアウト構造の例を以下に示します。"

#: ../../package-structure-code/python-package-structure.md:61
msgid "Note the location of the following directories in the example above:"
msgstr "上の例では、以下のディレクトリの位置に注意してください:"

#: ../../package-structure-code/python-package-structure.md:63
#, fuzzy
msgid ""
"**docs/:** Discussed in our docs chapter, this directory contains your "
"user-facing documentation website. In a **src/** layout docs/ are "
"normally included at the same directory level as the **src/** folder."
msgstr ""
"**docs/:** docsの章で説明したように、このディレクトリにはユーザー向けのドキュメントサイトが含まれます。 **src/** "
"レイアウトでは、通常 docs/ は **src/** フォルダの同じディレクトリレベルに含まれます。"

#: ../../package-structure-code/python-package-structure.md:64
#, fuzzy
msgid ""
"**tests/** This directory contains the tests for your project code. In a "
"**src/** layout, tests are normally included at the same directory level "
"as the **src/** folder."
msgstr ""
"**tests/** このディレクトリには、プロジェクトコードのテストが含まれます。 **src/** レイアウトでは、テストは通常 "
"**src/** フォルダの同じディレクトリレベルに含まれます。"

#: ../../package-structure-code/python-package-structure.md:65
msgid ""
"**src/package/**: this is the directory that contains the code for your "
"Python project. \"Package\" is normally your project's name."
msgstr ""
"**src/package/**: これはPythonプロジェクトのコードを含むディレクトリです。 \"Package\" "
"は通常プロジェクトの名前です。"

#: ../../package-structure-code/python-package-structure.md:67
msgid ""
"Also in the above example, notice that all of the core documentation "
"files that pyOpenSci requires live in the root of your project directory."
" These files include:"
msgstr ""
"また、上記の例では、pyOpenSciが必要とするすべてのコアドキュメントファイルがプロジェクトディレクトリのルートにあることに注意してください。"
" これらのファイルには以下が含まれています:"

#: ../../package-structure-code/python-package-structure.md:71
msgid "CHANGELOG.md"
msgstr "CHANGELOG.md"

#: ../../package-structure-code/python-package-structure.md:72
msgid "CODE_OF_CONDUCT.md"
msgstr "CODE_OF_CONDUCT.md"

#: ../../package-structure-code/python-package-structure.md:73
msgid "CONTRIBUTING.md"
msgstr "CONTRIBUTING.md"

#: ../../package-structure-code/python-package-structure.md:74
msgid "LICENSE.txt"
msgstr "LICENSE.txt"

#: ../../package-structure-code/python-package-structure.md:75
msgid "README.md"
msgstr "README.md"

#: ../../package-structure-code/python-package-structure.md:79
msgid "Click here to read about our packaging documentation requirements."
msgstr "パッケージングに関するドキュメント要件については、こちらをご覧ください。"

#: ../../package-structure-code/python-package-structure.md:86
msgid "Example scientific packages that use **src/package** layout"
msgstr "**src/package** レイアウトを使用する科学的パッケージの例"

#: ../../package-structure-code/python-package-structure.md:88
msgid "[Sourmash](https://github.com/sourmash-bio/sourmash)"
msgstr "[Sourmash](https://github.com/sourmash-bio/sourmash)"

#: ../../package-structure-code/python-package-structure.md:89
msgid "[bokeh](https://github.com/bokeh/bokeh)"
msgstr "[bokeh](https://github.com/bokeh/bokeh)"

#: ../../package-structure-code/python-package-structure.md:90
msgid "[openscm](https://github.com/openscm/openscm-runner)"
msgstr "[openscm](https://github.com/openscm/openscm-runner)"

#: ../../package-structure-code/python-package-structure.md:91
msgid "[awkward](https://github.com/scikit-hep/awkward)"
msgstr "[awkward](https://github.com/scikit-hep/awkward)"

#: ../../package-structure-code/python-package-structure.md:92
msgid "[poliastro](https://github.com/poliastro/poliastro/)"
msgstr "[poliastro](https://github.com/poliastro/poliastro/)"

#: ../../package-structure-code/python-package-structure.md:96
msgid "The src/ layout and testing"
msgstr "src/ のレイアウトとテスト"

#: ../../package-structure-code/python-package-structure.md:98
#, fuzzy
msgid ""
"The benefit of using the **src/package** layout is that it ensures tests "
"are run against the installed version of your package rather than the "
"files in your package working directory. If you run your tests on your "
"files rather than the installed version of your package, you may be "
"missing issues that users encounter when your package is installed."
msgstr ""
"**src/package** "
"レイアウトを使用する利点は、特に新しいパッケージを作成する場合、パッケージの作業ディレクトリ内のファイルではなく、インストールされたバージョンのパッケージに対してテストが実行されることを保証することです。"
" "
"インストールされたバージョンではなく、あなたのファイルでテストを実行すると、あなたのパッケージがインストールされたときにユーザが遭遇する問題を見逃してしまうかもしれません。"

#: ../../package-structure-code/python-package-structure.md:104
#, fuzzy
msgid ""
"If `tests/` are outside the **src/package** directory, they aren't "
"included in the package's [wheel](python-wheel). This makes your package "
"size slightly smaller, which places a smaller storage burden on PyPI, and"
" makes them faster to fetch."
msgstr ""
"`tests/` が **src/package** ディレクトリの外にある場合、それらはパッケージホイールに含まれません。 "
"これにより、パッケージのサイズが少し小さくなり、400,000以上のパッケージをサポートするPyPIのストレージの負担が小さくなります。"

#: ../../package-structure-code/python-package-structure.md:106
msgid ""
"[Read more about reasons to use the **src/package** "
"layout](https://hynek.me/articles/testing-packaging/)"
msgstr ""
"[**src/package** レイアウトを使用する理由についてもっと読む](https://hynek.me/articles"
"/testing-packaging/)"

#: ../../package-structure-code/python-package-structure.md:108
msgid "How Python discovers and prioritizes importing modules"
msgstr "Pythonはどのようにインポートモジュールを検出し、優先順位をつけるか"

#: ../../package-structure-code/python-package-structure.md:110
msgid ""
"By default, Python adds a module in your current working directory to the"
" front of the Python module search path."
msgstr "デフォルトでは、Pythonは現在の作業ディレクトリにあるモジュールをPythonモジュール検索パスの先頭に追加します。"

#: ../../package-structure-code/python-package-structure.md:112
msgid ""
"This means that if you run your tests in your package's working "
"directory, using a flat layout, `/package/module.py`, Python will "
"discover `package/module.py` file before it discovers the installed "
"package."
msgstr ""
"つまり、パッケージの作業ディレクトリでフラットレイアウトの `/package/module.py` を使ってテストを実行すると、Python "
"はインストールされたパッケージを検出する前に `package/module.py` ファイルを検出します。"

#: ../../package-structure-code/python-package-structure.md:114
#, fuzzy
msgid ""
"However, if your package lives in a src/ directory structure "
"**src/package**, then it won't be added to the Python path by default. "
"This means that when you import your package, Python will be forced to "
"search the active environment (which has your package installed)."
msgstr ""
"しかし、あなたのパッケージが src/ ディレクトリ構造の **src/package** にある場合、デフォルトでは Python "
"のパスに追加されません。 これは、あなたのパッケージをインポートするとき、Python "
"は（あなたのパッケージがインストールされている）アクティブな環境を強制的に検索することを意味します。"

#: ../../package-structure-code/python-package-structure.md:116
#, fuzzy
msgid ""
"Note: Python versions 3.11 and above have a path setting that can be "
"adjusted to ensure the priority is to use installed packages first (e.g.,"
" `PYTHONSAFEPATH`)."
msgstr ""
"注意: Pythonのバージョン3.11以上では、インストールされているパッケージを優先的に使うようにパスの設定を調整することができます ( "
"`PYTHONSAFEPATH` など)。"

#: ../../package-structure-code/python-package-structure.md:119
#, fuzzy
msgid "Don't include tests in your package wheel"
msgstr "**テストスイートのデータセットをパッケージに含めないでください**"

#: ../../package-structure-code/python-package-structure.md:121
#, fuzzy
msgid ""
"Writing [tests](tests-intro) for your package is important; however, we "
"do not recommend including tests as part of your [package wheel](python-"
"wheel) by default. However, not including tests in your package "
"distribution will make it harder for people other than yourself to test "
"whether your package runs properly on their system. If you have a small "
"test suite (Python files + data), and think your users may want to run "
"tests locally on their systems, you can include tests by moving the "
"`tests/` directory into the **src/package** directory (see example "
"below)."
msgstr ""
"デフォルトでテストをパッケージホイールの一部として含めることはお勧めしません。 "
"しかし、パッケージの配布にテストを含めないことは、あなた以外の人が、あなたのパッケージが自分のシステム上で正しく機能しているかどうかをテストすることを難しくします。小さなテストスイート"
" (Python ファイル + データ) を持っていて、ユーザが自分のシステムでローカルにテストを実行したいと思う場合、`tests/` "
"ディレクトリを **src/package** ディレクトリに移動することでテストを含めることができます (以下の例を参照してください)。"

#: ../../package-structure-code/python-package-structure.md:130
#, fuzzy
msgid ""
"Including the **tests/** directory in your **src/package** directory "
"ensures that tests will be included in your package's [wheel](python-"
"wheel)."
msgstr ""
"**src/package** ディレクトリに **tests/** ディレクトリをインクルードすることで、パッケージの wheel "
"にテストが含まれるようになります。"

#: ../../package-structure-code/python-package-structure.md:132
msgid ""
"Be sure to read the [pytest documentation for more about including tests "
"in your package "
"distribution](https://docs.pytest.org/en/7.2.x/explanation/goodpractices.html#choosing-a"
"-test-layout-import-rules)."
msgstr ""
"パッケージ配布にテストを含める方法については、 [pytest documentation for more about including "
"tests in your package "
"distribution](https://docs.pytest.org/en/7.2.x/explanation/goodpractices.html#choosing-a"
"-test-layout-import-rules) を必ず読んでください。"

#: ../../package-structure-code/python-package-structure.md:134
msgid "Challenges with including tests and data in a package wheel"
msgstr "パッケージwheelにテストとデータを含める際の課題"

#: ../../package-structure-code/python-package-structure.md:137
#, fuzzy
msgid ""
"Tests, especially when accompanied by test data, can create a few small "
"challenges, including:"
msgstr "テストは、特にテストデータを伴う場合、以下のような小さな課題を生み出す可能性があります:"

#: ../../package-structure-code/python-package-structure.md:139
#, fuzzy
msgid ""
"Take up space in your distribution, which will build up over time as "
"storage space on PyPI"
msgstr "PyPI上のストレージスペースとして時間の経過とともに蓄積される、ディストリビューション内のスペースを占有します。"

#: ../../package-structure-code/python-package-structure.md:140
#, fuzzy
msgid "Large file sizes can also slow down package installation."
msgstr "ファイルサイズが大きいと、パッケージのインストールも遅くなります。"

#: ../../package-structure-code/python-package-structure.md:142
#, fuzzy
msgid ""
"However, in some cases, particularly in the scientific Python ecosystem, "
"you may need to include tests."
msgstr "しかし、場合によっては、特に科学的なPythonのエコシステムでは、テストを含める必要があるかもしれません。"

#: ../../package-structure-code/python-package-structure.md:145
msgid "**Don't include test suite datasets in your package**"
msgstr "**テストスイートのデータセットをパッケージに含めないでください**"

#: ../../package-structure-code/python-package-structure.md:147
#, fuzzy
msgid ""
"If you include your tests in your package distribution, we strongly "
"discourage you from including data in your test suite directory. Rather, "
"host your test data in a repository such as Figshare or Zenodo. Use a "
"tool such as [Pooch](https://www.fatiando.org/pooch/latest/) to access "
"the data when you (or a user) runs tests."
msgstr ""
"テストをパッケージ配布に含める場合、テストスイートディレクトリにデータを含めることは強くお勧めしません。 "
"そうではなく、FigshareやZenodoのようなリポジトリでテストデータをホストします。 "
"[Pooch](https://www.fatiando.org/pooch/latest/) "
"のようなツールを使用して、あなた（またはユーザー）がテストを実行する際にデータにアクセスします。"

#: ../../package-structure-code/python-package-structure.md:153
msgid ""
"For more information about Python package tests, see the [tests section "
"of our guide](tests-intro)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:155
msgid ""
"The **src/package** layout is semantically more clear. Code is always "
"found in the **src/package** directory, `tests/` and `docs/`are in the "
"root directory."
msgstr ""
"**src/package** レイアウトの方が意味的に明確である。 コードは常に **src/package** ディレクトリにあり、　"
"`tests/` と `docs/` はルートディレクトリにあります。"

#: ../../package-structure-code/python-package-structure.md:159
#, fuzzy
msgid ""
"If your package tests require data, do NOT include that data within your "
"package structure. Including data in your package structure increases the"
" size of your distribution files. This places a maintenance toll on "
"repositories like PyPI and Anaconda.org that have to deal with thousands "
"of package uploads."
msgstr ""
"パッケージのテストにデータが必要な場合は、そのデータをパッケージ構造に含めないことをお勧めします。 "
"これについてはチュートリアルで詳しく説明します。 パッケージ構造にデータをインクルードすると、配布ファイルのサイズが大きくなります。 これは "
"PyPI や Anaconda.org のような何千ものパッケージのアップロードに対応しなければならないリポジトリにメンテナンスの負担をかけます。"

#: ../../package-structure-code/python-package-structure.md:166
#, fuzzy
msgid "Click here for a quickstart tutorial on creating your Python package."
msgstr "PyPIへのパッケージ公開のチュートリアルはこちら。"

#: ../../package-structure-code/python-package-structure.md:176
#, fuzzy
msgid "What is the flat Python package layout?"
msgstr "フラットなPythonパッケージレイアウトについて"

#: ../../package-structure-code/python-package-structure.md:178
#, fuzzy
msgid "Many scientific packages use the **flat-layout** given:"
msgstr "現在、ほとんどの科学的パッケージは **flat-layout** を使用しています："

#: ../../package-structure-code/python-package-structure.md:180
msgid ""
"This layout is used by many core scientific Python packages such as "
"NumPy, SciPy, and Matplotlib."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:181
#, fuzzy
msgid ""
"Many Python tools depend upon tools in other languages and/or complex "
"builds with compilation steps. Many maintainers prefer features of the "
"flat layout for more complex builds."
msgstr ""
"Pythonのツールの多くは、他の言語のツールに依存していたり、コンパイルステップのある複雑なビルドが必要だったりします。 "
"そのため、多くの開発者はフラットレイアウトの機能を高く評価しています。"

#: ../../package-structure-code/python-package-structure.md:185
msgid ""
"While we suggest that you use the **src/package** layout discussed above,"
" it's important to also understand the flat layout, especially if you "
"plan to contribute to a package that uses this layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:189
msgid "Why most scientific Python packages do not use source"
msgstr "ほとんどの科学的Pythonパッケージがソースを使わない理由"

#: ../../package-structure-code/python-package-structure.md:192
#, fuzzy
msgid ""
"In most cases, moving to the **src/package** layout for larger scientific"
" packages that already use a flat layout would consume significant time."
msgstr ""
"ほとんどの場合、すでにフラットなアプローチを使っている大規模な科学パッケージで **src/package** "
"レイアウトを使う利点は、それに見合うものではありません。 フラットレイアウトから **src/package** "
"レイアウトへの移行は、メンテナにとって大きなコストとなります。"

#: ../../package-structure-code/python-package-structure.md:195
#, fuzzy
msgid ""
"However, the advantages of using the  **src/package** layout for a "
"beginner are significant. As such, we recommend that you use the "
"**src/package** layout if you are creating a new package."
msgstr ""
"しかし、初心者にとって**src/package**レイアウトを使う利点は大きいです。そのため、パッケージの作成を始めるのであれば、 "
"**src/package** レイアウトの使用を検討することをお勧めします。"

#: ../../package-structure-code/python-package-structure.md:198
#, fuzzy
msgid ""
"Numerous packages in the ecosystem [have had to move to a **src/package**"
" layout](https://github.com/scikit-build/cmake-python-"
"distributions/pull/145)."
msgstr ""
"私たちのガイドではこのレイアウトを紹介しているので、pythonのパッケージングを始めたばかりの人は、上で説明したsrc/packageレイアウトから始めることをお勧めします。エコシステム内の数多くのパッケージが"
" [src/レイアウトに移行しなければならなくなりました](https://github.com/scikit-build/cmake-"
"python-distributions/pull/145)"

#: ../../package-structure-code/python-package-structure.md:202
msgid "What does the flat layout structure look like?"
msgstr "フラットレイアウトの構造はどのようなものですか？"

#: ../../package-structure-code/python-package-structure.md:204
msgid "The flat layout's primary characteristics are:"
msgstr "フラットレイアウトの主な特徴は以下の通りです:"

#: ../../package-structure-code/python-package-structure.md:206
msgid ""
"The source code for your package lives in a directory with your package's"
" name in the root of your directory"
msgstr "パッケージのソースコードは、ディレクトリのルートにあるパッケージ名のディレクトリに格納されます"

#: ../../package-structure-code/python-package-structure.md:208
msgid ""
"Often the `tests/` directory also lives within that same `package` "
"directory."
msgstr "多くの場合、 `tests/` ディレクトリも同じ `package` ディレクトリの中にあります。"

#: ../../package-structure-code/python-package-structure.md:210
msgid ""
"Below you can see the recommended structure of a scientific Python "
"package using the flat layout."
msgstr "以下に、フラットレイアウトを使った科学的Pythonパッケージの推奨構造を示します。"

#: ../../package-structure-code/python-package-structure.md:232
msgid "Benefits of using the flat layout in your Python package"
msgstr "Pythonパッケージでフラットレイアウトを使うメリット"

#: ../../package-structure-code/python-package-structure.md:234
msgid ""
"There are some benefits to the scientific community in using the flat "
"layout."
msgstr "フラットレイアウトを採用することは、科学コミュニティにとってもメリットがあります。"

#: ../../package-structure-code/python-package-structure.md:236
msgid ""
"This structure has historically been used across the ecosystem and "
"packages using it are unlikely to change."
msgstr "この構造は歴史的にエコシステム全体で使われてきたものであり、これを使うパッケージが変わることはないでしょう。"

#: ../../package-structure-code/python-package-structure.md:238
msgid ""
"You can import the package directly from the root directory. For some "
"this is engrained in their respective workflows. However, for a beginner "
"the danger of doing this is that you are not developing and testing "
"against the installed version of your package. Rather, you are working "
"directly with the flat files."
msgstr ""
"ルートディレクトリからパッケージを直接インポートすることができます。これがそれぞれのワークフローに組み込まれている人もいるでしょう。しかし、初心者がこの方法をとる危険性は、インストールされたバージョンのパッケージに対して開発やテストを行っていないことにあります。"
" むしろ、フラットファイルを直接扱うことになります。"

#: ../../package-structure-code/python-package-structure.md:244
msgid "Core scientific Python packages that use the flat layout"
msgstr "フラットレイアウトを使用する科学的Pythonのコアパッケージ"

#: ../../package-structure-code/python-package-structure.md:247
msgid "[numpy](https://github.com/numpy/numpy)"
msgstr "[numpy](https://github.com/numpy/numpy)"

#: ../../package-structure-code/python-package-structure.md:248
msgid "[scipy](https://github.com/scipy/scipy)"
msgstr "[scipy](https://github.com/scipy/scipy)"

#: ../../package-structure-code/python-package-structure.md:249
msgid "[pandas](https://github.com/pandas-dev/pandas)"
msgstr "[pandas](https://github.com/pandas-dev/pandas)"

#: ../../package-structure-code/python-package-structure.md:250
msgid "[xarray](https://github.com/pydata/xarray)"
msgstr "[xarray](https://github.com/pydata/xarray)"

#: ../../package-structure-code/python-package-structure.md:251
msgid "[Jupyter-core](https://github.com/jupyter/jupyter_core)"
msgstr "[Jupyter-core](https://github.com/jupyter/jupyter_core)"

#: ../../package-structure-code/python-package-structure.md:252
msgid "[Jupyter notebook](https://github.com/jupyter/notebook)"
msgstr "[Jupyter notebook](https://github.com/jupyter/notebook)"

#: ../../package-structure-code/python-package-structure.md:253
msgid "[scikit-learn](https://github.com/scikit-learn/scikit-learn)"
msgstr "[scikit-learn](https://github.com/scikit-learn/scikit-learn)"

#: ../../package-structure-code/python-package-structure.md:255
#, fuzzy
msgid ""
"It would be a significant maintenance cost and burden to move all of "
"these packages to a different layout. The potential benefits of the "
"source layout for these tools are not worth the maintenance investment."
msgstr ""
"これらのパッケージをすべて別のレイアウトに移行するのは、かなりのメンテナンスコストと負担になるでしょう。 "
"これらのツールのソースレイアウトの潜在的な利点は、メンテナンスの投資に見合うものではありません。"

#: ../../package-structure-code/python-package-versions.md:1
msgid "Creating New Versions of Your Python Package"
msgstr "Pythonパッケージの新しいバージョンを作成する"

#: ../../package-structure-code/python-package-versions.md:6
msgid "Key Takeways"
msgstr "キーポイント"

#: ../../package-structure-code/python-package-versions.md:8
msgid ""
"Follow [semantic versioning guidelines (SemVer) "
"rules](https://semver.org/) when bumping (increasing) your Python's "
"package version; for example a major version bump (version 1.0 --> 2.0) "
"equates to breaking changes in your package's code for a user."
msgstr ""
"Pythonのパッケージのバージョンを(上げる)ときは [semantic versioning guidelines "
"(SemVer)のルール](https://semver.org/) に従ってください。例えばメジャーバージョンアップ(バージョン1.0 --> "
"2.0)は、ユーザーにとってパッケージのコードを変更することに相当します。"

#: ../../package-structure-code/python-package-versions.md:9
msgid ""
"You may want to consider using a plugin like hatch_vsc for managing "
"versions of your package - if you want to have a GitHub only release "
"workflow."
msgstr ""
"パッケージのバージョン管理には、hatch_vsc のようなプラグインを使うことを検討するとよいでしょう - GitHub "
"でのみリリースを行うワークフローを作りたいのであれば。"

#: ../../package-structure-code/python-package-versions.md:10
msgid ""
"Otherwise most major package build tools such as Hatch, Flit and PDM have"
" a version feature that will help you update your package's version"
msgstr "その他、Hatch、Flit、PDMなどの主要なパッケージビルドツールには、パッケージのバージョンを更新するためのバージョン機能があります。"

#: ../../package-structure-code/python-package-versions.md:11
msgid "Avoid updating your packages version number manually by hand in your code!"
msgstr "パッケージのバージョン番号をコード内で手作業で更新するのは避けましょう！"

#: ../../package-structure-code/python-package-versions.md:14
msgid ""
"pyOpenSci recommends that you follow the [Python PEP "
"440](https://peps.python.org/pep-0440) which recommends using [semantic "
"versioning guidelines](https://www.python.org/dev/peps/pep-0440"
"/#semantic-versioning) when assigning release values to new versions of "
"your Python package."
msgstr ""
"pyOpenSciでは、Pythonパッケージの新しいバージョンにリリース値を割り当てる際に、 [semantic versioning "
"guidelines](https://www.python.org/dev/peps/pep-0440/#semantic-"
"versioning) を使用することを推奨している [Python PEP "
"440](https://peps.python.org/pep-0440) に従うことを推奨しています。"

#: ../../package-structure-code/python-package-versions.md:18
msgid ""
"[Semantic versioning](https://semver.org/) is an approach to updating "
"package versions that considers the type and extent of a change that you "
"are making to the package code. Being consistent with how and when you "
"update your package versions is important as:"
msgstr ""
"[Semantic versioning](https://semver.org/) "
"は、パッケージのバージョンを更新するためのアプローチで、パッケージのコードに加えようとしている変更の種類と程度を考慮します。パッケージのバージョンを更新する方法とタイミングを一貫させることは、次のように重要です:"

#: ../../package-structure-code/python-package-versions.md:23
msgid ""
"It helps your users (which might include other developers that depend on "
"your package) understand the extent of changes to a package."
msgstr "これは、あなたのユーザ (あなたのパッケージに依存している他の開発者を含むかもしれません) がパッケージの変更範囲を理解するのに役立ちます。"

#: ../../package-structure-code/python-package-versions.md:24
msgid ""
"It helps your development team make decisions about when to bump a "
"package version based on standard rules."
msgstr "標準的なルールに基づいて、開発チームがパッケージのバージョンを上げるタイミングを判断するのに役立ちます。"

#: ../../package-structure-code/python-package-versions.md:26
#, fuzzy
msgid ""
"Consistent version increases following semver rules mean that values of "
"your package version explain the extent of the changes made in the code "
"base from version to version. Thus your package version numbers become "
"\"expressive\" in the same way that naming code variables well can [make "
"code expressive](https://medium.com/@daniel.oliver.king/writing-"
"expressive-code-b69ef7a5a2fa)."
msgstr ""
"センバーのルールに従った一貫したバージョンの増加とは、パッケージのバージョンの値が、バージョンごとにコードベースで行われた変更の程度を説明することを意味します。こうしてパッケージのバージョン番号は、コードの変数にうまく名前をつけることで"
" [コードを表現豊かにする](https://medium.com/@daniel.oliver.king/writing-expressive-"
"code-b69ef7a5a2fa) ことができるのと同じように、 \"表現豊かに\" なります。"

#: ../../package-structure-code/python-package-versions.md:28
msgid "A note about versioning"
msgstr "バージョン管理について"

#: ../../package-structure-code/python-package-versions.md:29
msgid ""
"In some cases even small version changes can turn a package update into a"
" breaking change for some users. What is also important is that you "
"document how you version your code and if you can, also document your "
"deprecation policy for code."
msgstr ""
"場合によっては、小さなバージョン変更でさえも、パッケージのアップデートを一部のユーザーにとって破壊的な変更に変えてしまう可能性があります。 "
"さらに重要なのは、コードのバージョンアップ方法を文書化することであり、可能であればコードの非推奨ポリシーも文書化することです。"

#: ../../package-structure-code/python-package-versions.md:37
msgid "SemVer rules"
msgstr "SemVerルール"

#: ../../package-structure-code/python-package-versions.md:39
msgid "Following SemVer, your bump your package version to a:"
msgstr "SemVerに従って、パッケージのバージョンを上げます:"

#: ../../package-structure-code/python-package-versions.md:41
msgid "patch (1.1.1 --> 1.1.**2**)"
msgstr "パッチ (1.1.1 --> 1.1.**2**)"

#: ../../package-structure-code/python-package-versions.md:42
msgid "minor (1.1.1 --> 1.**2**.1)"
msgstr "マイナー (1.1.1 --> 1.**2**.1)"

#: ../../package-structure-code/python-package-versions.md:43
msgid "major (1.1.1 --> **2**.1.1)"
msgstr "メジャー (1.1.1 --> **2**.1.1)"

#: ../../package-structure-code/python-package-versions.md:45
msgid "version number change based on the following rules:"
msgstr "バージョン番号は以下のルールに基づいて変更されます:"

#: ../../package-structure-code/python-package-versions.md:47
msgid "Given a version number MAJOR.MINOR.PATCH, increment the:"
msgstr "バージョン番号MAJOR.MINOR.PATCHが与えられたら、インクリメントする:"

#: ../../package-structure-code/python-package-versions.md:49
msgid "**MAJOR version** when you make incompatible API changes"
msgstr "**MAJOR version** 互換性のないAPIの変更を行った場合"

#: ../../package-structure-code/python-package-versions.md:50
msgid ""
"**MINOR version** when you add functionality in a backwards compatible "
"manner"
msgstr "後方互換性のある方法で機能を追加する場合の **MINOR version** 。"

#: ../../package-structure-code/python-package-versions.md:51
msgid ""
"**PATCH version** when you make backwards compatible bug fixes Additional"
" labels for pre-release and build metadata are available as extensions to"
" the MAJOR.MINOR.PATCH format."
msgstr ""
"**PATCH version** 後方互換性のあるバグ修正を行う場合 "
"プレリリースとビルドのメタデータ用の追加ラベルは、MAJOR.MINOR.PATCHフォーマットの拡張として利用できます。"

#: ../../package-structure-code/python-package-versions.md:56
msgid ""
"Some people prefer to use [calver](https://calver.org/index.html) for "
"versioning. It may be a simpler-to-use system given it relies upon date "
"values associated with released versions. However, calver does not "
"provide a user with a sense of when a new version might break an existing"
" build. As such we still suggest semver."
msgstr ""
"バージョン管理には[calver](https://calver.org/index.html)を好んで使う人もいます。リリースされたバージョンに関連する日付の値に依存することを考えれば、より使いやすいシステムかもしれません。"
" しかし、calverは、新しいバージョンがいつ既存のビルドを壊すかもしれないという感覚をユーザーに提供しません。 "
"そのため、semverをお勧めします。"

#: ../../package-structure-code/python-package-versions.md:59
msgid ""
"pyOpenSci will never require semver in a peer review as long as a package"
" has a reasonable approach to versioning!"
msgstr "pyOpenSciは、パッケージがバージョニングに対して合理的なアプローチを持っている限り、査読でsemverを要求することはありません！"

#: ../../package-structure-code/python-package-versions.md:63
msgid "Avoid manually updating Python package version numbers if you can"
msgstr "Python パッケージのバージョン番号を手動で更新するのは、できる限り避けてください。"

#: ../../package-structure-code/python-package-versions.md:65
msgid ""
"Often times you may want to have your package version value in multiple "
"locations. One example of this is that it might be both an attribute in "
"your package **version** and also called in your documentation."
msgstr ""
"パッケージのバージョンの値を複数の場所で持ちたい場合がよくあります。 その一例として、パッケージの **version** "
"の属性であると同時に、ドキュメントの中で呼び出されることがあります。"

#: ../../package-structure-code/python-package-versions.md:70
msgid ""
"We recommend that you avoid manual updates of your package version number"
" to avoid human-error. It is better practice to keep your version number "
"in one location."
msgstr ""
"ヒューマンエラーを避けるため、パッケージのバージョン番号の手動更新は 避けることをお勧めします。 "
"バージョン番号は一箇所にまとめておく方がよいでしょう。"

#: ../../package-structure-code/python-package-versions.md:74
msgid ""
"If you can't implement a single location version, then consider using a "
"tool like hatch, PDM or bump2version that will update the version values "
"for you - throughout your package."
msgstr "もし1カ所のバージョンを実装できないのであれば、hatchやPDM、bump2versionのような、パッケージ全体でバージョン値を更新してくれるツールの使用を検討しましょう。"

#: ../../package-structure-code/python-package-versions.md:78
msgid ""
"Below we discuss some tools that you can use to manage updating Python "
"package versions."
msgstr "以下では、Pythonパッケージのバージョン更新を管理するために使用できるいくつかのツールについて説明します。"

#: ../../package-structure-code/python-package-versions.md:83
msgid "Tools to manage versions for your Python package"
msgstr "Pythonパッケージのバージョンを管理するツール"

#: ../../package-structure-code/python-package-versions.md:85
msgid ""
"There are a handful of tools that are widely used in the scientific "
"ecosystem that you can use to manage your package versions. Some of these"
" tools are built into or work with your chosen [packaging build tools "
"that discussed in this chapter.](python-package-build-tools)"
msgstr ""
"パッケージのバージョンを管理するために使用できる、科学的なエコシステムで広く使われているツールがいくつかあります。 "
"これらのツールのいくつかは、あなたが選択した [この章で議論するパッケージングビルドツール](python-package-build-"
"tools) に組み込まれているか、それらと連携しています。"

#: ../../package-structure-code/python-package-versions.md:91
msgid "Below, we provide an overview of these tools."
msgstr "以下に、これらのツールの概要を示します。"

#: ../../package-structure-code/python-package-versions.md:97
msgid ""
"There are three general groups of tools that you can use to manage "
"package versions:"
msgstr "パッケージのバージョンを管理するために使用できるツールには、一般的に3つのグループがあります:"

#: ../../package-structure-code/python-package-versions.md:100
msgid ""
"**semantic release tools:** These tools will automagically determine what"
" type of version bump to use using the text in your commit messages. "
"Below we discuss [Python Semantic Release](https://python-semantic-"
"release.readthedocs.io/en/latest/) as a Python tool that implements a "
"semantic versioning approach."
msgstr ""
"**セマンティックリリースツール:** これらのツールは、コミットメッセージのテキストから、使用するバージョンバンプのタイプを自動的に判断します。"
" 以下では、セマンティックバージョニングアプローチを実装したPythonツールとして、 [Python Semantic "
"Release](https://python-semantic-release.readthedocs.io/en/latest/) "
"を取り上げます。"

#: ../../package-structure-code/python-package-versions.md:102
msgid ""
"**Manual incremental bump tools:** Tools like "
"[Hatch](https://hatch.pypa.io/latest/version/) offer version bumping "
"within your package. Normally this is implemented at the command link for"
" instance `hatch version major` would bump your project from 0.x to 1.0."
msgstr ""
"**手動インクリメンタルバンプツール:** "
"[Hatch](https://hatch.pypa.io/latest/version/)のようなツールは、パッケージ内でのバージョンバンプを提供します。通常、これはコマンドリンクで実装されます。例えば、"
" `hatch version major` はプロジェクトを0.xから1.0にします。"

#: ../../package-structure-code/python-package-versions.md:103
msgid ""
"**Version Control System tools:** Finally there are tools that rely on "
"your version control system to track versions. These tools often are "
"plugins to your package build tool (ex: setuptools build or hatchling). "
"We discuss this option below assuming that you are using **.git tags** "
"and **GitHub** to manage your package repository."
msgstr ""
"**バージョン管理システムツール:** 最後に、バージョンを追跡するためにバージョン管理システムに依存するツールがある。 "
"これらのツールは、パッケージビルドツールのプラグインであることが多いです (例：setuptools build または hatchling)。 "
"以下では、パッケージリポジトリの管理に **.git tags** と **GitHub** "
"を使用していることを前提に、このオプションについて説明します。"

#: ../../package-structure-code/python-package-versions.md:105
msgid "Semantic release, vs version control based vs manual version bumping"
msgstr "セマンティックリリース、バージョン管理ベースと手動バージョンバンプの比較"

#: ../../package-structure-code/python-package-versions.md:107
#, fuzzy
msgid ""
"Generally semantic release and version control system tools can be setup "
"to run automatically on GitHub using GitHub Actions. This means that you "
"can create a workflow where a GitHub release and associated new version "
"tag is used to trigger an automated build that:"
msgstr ""
"一般的に、セマンティックリリースツールやバージョン管理システムツールは、GitHubアクションを使ってGitHub上で自動的に実行するように設定することができる。"
" つまり、GitHub のリリースとそれに関連する新しいバージョンのタグを使って、自動ビルドのトリガーとなるワークフローを作れるということです:"

#: ../../package-structure-code/python-package-versions.md:113
msgid "Builds your package and updates the version following the new tag"
msgstr "パッケージをビルドし、新しいタグに従ってバージョンを更新します。"

#: ../../package-structure-code/python-package-versions.md:114
msgid "Tests the build and publishes to test PyPI"
msgstr "ビルドをテストし、テスト用PyPIに公開します。"

#: ../../package-structure-code/python-package-versions.md:115
msgid "Publishes the package to PyPI"
msgstr "パッケージをPyPIに公開します"

#: ../../package-structure-code/python-package-versions.md:118
#, fuzzy
msgid ""
"Bumping a package version refers to the step of increasing the package "
"version after a set number of changes have been made to it. For example, "
"you might bump from version 0.8 to 0.9 of a package or from 0.9 to 1.0."
msgstr ""
"パッケージのバージョンを上げるとは、パッケージのバージョンに一定の 変更が加えられた後に、そのパッケージのバージョンを上げることです。 "
"たとえば、あるパッケージのバージョン 0.8 から 0.9 にバンプしたり、0.9 から 1.0 にバンプしたりします。"

#: ../../package-structure-code/python-package-versions.md:122
msgid ""
"Using semantic versioning, there are three main \"levels\" of versions "
"that you might consider:"
msgstr "セマンティックバージョニングを使用する場合、3つの主な \"レベル\" が考えられます:"

#: ../../package-structure-code/python-package-versions.md:125
msgid "Major, minor and patch. These are described in more detail below."
msgstr "メジャー、マイナー、パッチ。 これらの詳細については後述します。"

#: ../../package-structure-code/python-package-versions.md:128
msgid "Tools for bumping Python package versions"
msgstr "Pythonパッケージのバージョンを上げるツール"

#: ../../package-structure-code/python-package-versions.md:130
msgid ""
"In this section we discuss the following tools for managing your Python "
"package's version:"
msgstr "このセクションでは、Pythonパッケージのバージョンを管理するための以下のツールについて説明します:"

#: ../../package-structure-code/python-package-versions.md:133
msgid "hatch &"
msgstr "hatch &"

#: ../../package-structure-code/python-package-versions.md:134
msgid "hatch_vcs plugin for hatchling"
msgstr "hatchling 用 hatch_vcs プラグイン"

#: ../../package-structure-code/python-package-versions.md:135
msgid "setuptools-scm"
msgstr "setuptools-scm"

#: ../../package-structure-code/python-package-versions.md:136
msgid "python-semantic-version"
msgstr "python-semantic-version"

#: ../../package-structure-code/python-package-versions.md:138
msgid "Tool 1: Hatch and other build tools that offer incremental versioning"
msgstr "ツール1: インクリメンタルバージョニングを提供するHatchやその他のビルドツール"

#: ../../package-structure-code/python-package-versions.md:140
msgid ""
"Many of the modern build tool front end tools offer version support that "
"follow semantic versioning rules. These tools are different from Python "
"Semantic Version in that they do not require specific commit messages to "
"implement version. Rather, they allow you to update the version at the "
"command line using commands such as:"
msgstr ""
"最近のビルドツールのフロントエンドツールの多くは、セマンティックバージョン管理のルールに従ったバージョンサポートを提供しています。 "
"これらのツールは Python Semantic Version とは異なり、バージョンを実装するために特定のコミットメッセージを必要としません。"
" そうではなく、コマンドラインで次のようなコマンドを使ってバージョンを更新することができます:"

#: ../../package-structure-code/python-package-versions.md:146
msgid "`tool-name version update major`"
msgstr "`tool-name version update major`"

#: ../../package-structure-code/python-package-versions.md:147
msgid "`tool-name version update minor`"
msgstr "`tool-name version update minor`"

#: ../../package-structure-code/python-package-versions.md:149
msgid ""
"[Hatch](https://hatch.pypa.io/latest/version/), for instance offers "
"`hatch version minor` which will modify the version of your package "
"incrementally. With **Hatch** the version value will be found in your "
"`pyproject.toml` file. <!-- TODO double check this -->"
msgstr ""
"例えば、[Hatch](https://hatch.pypa.io/latest/version/) "
"は、パッケージのバージョンをインクリメンタルに変更する `hatch version minor` を提供しています。 **Hatch** "
"の場合、バージョン値は`pyproject.toml`ファイルにあります。 <!-- TODO double check this -->"

#: ../../package-structure-code/python-package-versions.md:152
msgid "Hatch (or other tools like PDM) Pros"
msgstr "Hatch（またはPDMのような他のツール）の長所"

#: ../../package-structure-code/python-package-versions.md:154
msgid "Easy to use version updates locally using a single tool!"
msgstr "1つのツールを使ってローカルで簡単にバージョン更新ができます！"

#: ../../package-structure-code/python-package-versions.md:156
msgid "Hatch (or other tools like PDM) Cons"
msgstr "Hatch（またはPDMのような他のツール）の短所"

#: ../../package-structure-code/python-package-versions.md:158
msgid ""
"There will be some setup involved to ensure package version is updated "
"throughout your package"
msgstr "パッケージのバージョンがパッケージ全体で更新されるようにするには、いくつかの設定が必要です。"

#: ../../package-structure-code/python-package-versions.md:160
msgid "Tool 2: Hatch_vcs & hatchling build back-end"
msgstr "ツール 2: Hatch_vcs & hatchling ビルドバックエンド"

#: ../../package-structure-code/python-package-versions.md:162
msgid ""
"[hatch_vcs](https://github.com/ofek/hatch-vcs) is a versioning tool that "
"allows you to manage package versions using **git tags**. Hatch_vcs "
"creates a **\\_version.py** file in your package ecosystem that keeps "
"track of the package's current version."
msgstr ""
"[hatch_vcs](https://github.com/ofek/hatch-vcs)は、 **git tags** "
"を使ってパッケージのバージョンを管理できるバージョン管理ツールです。Hatch_vcs はパッケージの現在のバージョンを追跡する "
"**_version.py** ファイルをパッケージのエコシステムに作成します。"

#: ../../package-structure-code/python-package-versions.md:167
msgid ""
"Hatch keeps track of your package's version in a `_version.py` file. "
"Storing the version in a single file managed by Hatch provides your "
"package with a \"single source of truth\" value for the version number. "
"This in turn eliminates potential error associated with manually updating"
" your package's version."
msgstr ""
"Hatch はパッケージのバージョンを `_version.py` ファイルに記録しています。 "
"Hatchが管理する単一のファイルにバージョンを保存することで、パッケージにバージョン番号の \"単一の真のソース\" 値を提供します。 "
"これにより、パッケージのバージョンを手動で更新することに伴う潜在的なエラーを排除することができます。"

#: ../../package-structure-code/python-package-versions.md:173
#, fuzzy
msgid ""
"When you (or your CI system) build your package, hatch checks the current"
" tag number for your package. If it has increased, it will update the "
"**\\_version.py** file with the new value."
msgstr ""
"あなた（またはあなたのCIシステム）がパッケージをビルドするとき、hatchはあなたのパッケージの現在のタグ番号をチェックします。 "
"もし増加していれば、新しい値で **_version.py** ファイルを更新します。"

#: ../../package-structure-code/python-package-versions.md:176
msgid ""
"Thus, when you create a new tag or a new release with a tag and build "
"your package, Hatch will access the new tag value and use it to update "
"your package version."
msgstr "このように、新しいタグを作成したり、タグ付きの新しいリリースを作成してパッケージをビルドすると、Hatchは新しいタグの値にアクセスし、それを使ってパッケージのバージョンを更新します。"

#: ../../package-structure-code/python-package-versions.md:179
msgid ""
"To use **hatch_vcs** you will need to use the **hatchling** build back "
"end."
msgstr "**hatch_vcs** を使用するには、 **hatchling** ビルドバックエンドを使用する必要があります。"

#: ../../package-structure-code/python-package-versions.md:182
msgid ""
"Hatchling can also be used with any of the modern build tools including "
"**Flit** and **PDM** if you prefer those for your day to day workflow."
msgstr "日々のワークフローにそれらを好むなら、Hatchlingは **Flit** や **PDM** を含む最新のビルドツールでも使用できます。"

#: ../../package-structure-code/python-package-versions.md:187
msgid "Hatch example setup in your pyproject.toml"
msgstr "pyproject.tomlでのHatchのセットアップ例"

#: ../../package-structure-code/python-package-versions.md:196
msgid ""
"**Hatch_vcs** supports a fully automated package release and build, and "
"push to PyPI workflow on GitHub."
msgstr ""
"**Hatch_vcs** "
"は完全に自動化されたパッケージのリリースとビルド、GitHub上のPyPIへのプッシュのワークフローをサポートしています。"

#: ../../package-structure-code/python-package-versions.md:206
msgid ""
"If you use **setuptools_scm**, then you might find **hatch_vcs** and "
"**hatchling** to be the modern equivalent to your current setuptools / "
"build workflow."
msgstr ""
"もしあなたが **setuptools_scm** を使っているのであれば、 **hatch_vcs** と **hatchling** "
"があなたの現在のsetuptools/ビルドワークフローと現代的に同等であることがわかるかもしれません。"

#: ../../package-structure-code/python-package-versions.md:209
msgid "hatch_vcs Pros"
msgstr "hatch_vcs Pros"

#: ../../package-structure-code/python-package-versions.md:211
msgid "Hatch supports modern Python packaging standards"
msgstr "Hatchは最新のPythonパッケージング標準をサポート"

#: ../../package-structure-code/python-package-versions.md:212
#: ../../package-structure-code/python-package-versions.md:238
msgid "It creates a single-source file that contains your package version."
msgstr "これは、あなたのパッケージバージョンを含む単一ソースファイルを作成します。"

#: ../../package-structure-code/python-package-versions.md:213
#: ../../package-structure-code/python-package-versions.md:239
msgid "You never manually update the package version"
msgstr "パッケージのバージョンを手動で更新することはありません"

#: ../../package-structure-code/python-package-versions.md:214
#: ../../package-structure-code/python-package-versions.md:240
msgid ""
"You can automate writing the version anywhere in your package including "
"your documentation!"
msgstr "ドキュメンテーションを含め、パッケージのどこにでもバージョンを書くことを自動化できます！"

#: ../../package-structure-code/python-package-versions.md:215
#: ../../package-structure-code/python-package-versions.md:241
msgid ""
"It supports a purely GitHub based release workflow. This simplifies "
"maintenance workflows."
msgstr "純粋にGitHubベースのリリースワークフローをサポートしています。 これにより、メンテナンスのワークフローが簡素化されます。"

#: ../../package-structure-code/python-package-versions.md:216
#: ../../package-structure-code/python-package-versions.md:242
msgid ""
"Version number is updated in your package via a hidden `_version.py` "
"file. There is no manual configuration updates required."
msgstr "バージョン番号は隠された `_version.py` ファイルを通してパッケージ内で更新されます。 手動で設定を更新する必要はありません。"

#: ../../package-structure-code/python-package-versions.md:217
#: ../../package-structure-code/python-package-versions.md:243
msgid ""
"While we like detailed commit messages (See Python Semantic Version "
"below), we know that sometimes when maintaining a package specific "
"guidelines around commit messages can be hard to apply and manage."
msgstr ""
"私たちは詳細なコミットメッセージを好みますが(下記のPython Semantic "
"Versionを参照してください)、パッケージを管理する際にコミットメッセージに関する特定のガイドラインを適用したり管理したりするのが難しい場合があることも知っています。"

#: ../../package-structure-code/python-package-versions.md:219
msgid "hatch_vcs Cons"
msgstr "hatch_vcs Cons"

#: ../../package-structure-code/python-package-versions.md:221
msgid ""
"In a CI workflow you will end up manually entering or creating the "
"version number via a tag on GitHub. But you could locally develop a build"
" to \"bump\" tag versions"
msgstr ""
"CIワークフローでは、GitHubのタグを使ってバージョン番号を手動で入力したり作成したりすることになります。 しかし、タグのバージョンを "
"\"bump\" するビルドをローカルで開発することもできます。"

#: ../../package-structure-code/python-package-versions.md:224
msgid "Tool 3: setuptools-scm versioning using git tags"
msgstr "ツール3: gitタグを使ったsetuptools-scmのバージョン管理"

#: ../../package-structure-code/python-package-versions.md:226
msgid ""
"[`Setuptools_scm`](https://github.com/pypa/setuptools_scm/) is an "
"extension that you can use with setuptools to manage package versions. "
"**Setuptools_scm** operates the same way that **hatch_vcs** (discussed "
"above) does. It stores a version in a **\\_version.py** file and relies "
"on (**git**) tags to determine the package's current version."
msgstr ""
"[`Setuptools_scm`](https://github.com/pypa/setuptools_scm/) "
"は、パッケージのバージョンを管理するために setuptools と一緒に使うことができる拡張機能です。 "
"**Setuptools_scm**は、**hatch_vcs**（前述）と同じように動作します。 バージョンを **_version.py** "
"ファイルに保存し、パッケージの現在のバージョンを決定するために (**git**) タグに依存します。"

#: ../../package-structure-code/python-package-versions.md:232
msgid ""
"If you are using **setuptools** as your primary build tool, then "
"`*setuptools-scm` is a good choice as:"
msgstr "**setuptools** を主なビルドツールとして使っているのであれば、 `*setuptools-scm` は良い選択です:"

#: ../../package-structure-code/python-package-versions.md:236
msgid "setuptools_scm Pros"
msgstr "setuptools_scm Pros"

#: ../../package-structure-code/python-package-versions.md:244
msgid "**setuptools** is still the most commonly used Python packaging build tool"
msgstr "**setuptools** は今でも最もよく使われているPythonパッケージング構築ツールです。"

#: ../../package-structure-code/python-package-versions.md:246
msgid "setuptools_scm Cons"
msgstr "setuptools_scm Cons"

#: ../../package-structure-code/python-package-versions.md:248
msgid ""
"In a CI workflow you will end up manually entering or creating the "
"version number via a tag on GitHub."
msgstr "CIワークフローでは、GitHubのタグを使って手動でバージョン番号を入力したり作成したりすることになります。"

#: ../../package-structure-code/python-package-versions.md:249
msgid "Not well documented"
msgstr "文書化されていません"

#: ../../package-structure-code/python-package-versions.md:250
msgid ""
"Because setuptools will always have to support backwards compatibility it"
" will always be slower in adopting modern Python packaging conventions."
msgstr "setuptools は常に後方互換性をサポートしなければならないので、最新の Python パッケージング規約を採用するのは常に遅くなります。"

#: ../../package-structure-code/python-package-versions.md:252
msgid ""
"As such you might consider using a more modern tool such as **hatch_vcs**"
" and **hatchling** to build your package and manage package versions."
msgstr ""
"そのため、パッケージのビルドやパッケージのバージョン管理には、 **hatch_vcs** や **hatchling** "
"のような、より現代的なツールの使用を検討してください。"

#: ../../package-structure-code/python-package-versions.md:264
msgid ""
"Tool 4: [Python semantic release](https://python-semantic-"
"release.readthedocs.io/en/latest/)"
msgstr ""
"ツール4: [Pythonセマンティックリリース](https://python-semantic-"
"release.readthedocs.io/en/latest/)"

#: ../../package-structure-code/python-package-versions.md:266
msgid ""
"Python semantic release uses a commit message workflow that updates the "
"version of your package based on keywords found in your commit messages. "
"As the name implies, Python Semantic Release follows semver release "
"rules."
msgstr ""
"Python semantic release "
"はコミットメッセージのワークフローを使い、コミットメッセージに含まれるキーワードに基づいてパッケージのバージョンを更新します。 "
"その名の通り、Python Semantic Release は semver release のルールに従います。"

#: ../../package-structure-code/python-package-versions.md:271
msgid ""
"With Python Semantic Release, versions are triggered using specific "
"language found in a git commit message."
msgstr "Python Semantic Release では、git のコミットメッセージにある特定の言語を使ってバージョンをトリガーします。"

#: ../../package-structure-code/python-package-versions.md:274
msgid ""
"For example, the words `fix(attribute_warning):` trigger Python Semantic "
"Release to implement a **patch** version bump. For instance if your "
"package was at version 1.1.0 and you made the commit below with the words"
" fix(text-here), Python Semantic Release would bump your package to "
"version 1.1.1."
msgstr ""
"例えば、 `fix(attribute_warning):` という言葉は、Python Semantic Releaseが **patch** "
"バージョンバンプを実装する引き金になります。 例えば、あなたのパッケージのバージョンが1.1.0で、fix(text-here) "
"と書かれた以下のコミットをした場合、Python Semantic Release はあなたのパッケージをバージョン1.1.1にします。"

#: ../../package-structure-code/python-package-versions.md:284
msgid ""
"Similarly a feature (`feat()`) triggers a minor version bump. For example"
" from version 1.1 to version 1.2"
msgstr "同様に、機能（`feat()`）はマイナーバージョンアップの引き金となります。 例えばバージョン1.1からバージョン1.2へ"

#: ../../package-structure-code/python-package-versions.md:292
msgid ""
"You can find a thoughtful discussion of python semantic version [in this "
"Python package guide](https://py-pkgs.org/07-releasing-versioning"
"#automatic-version-bumping). Note that the guide hasn't been updated "
"since 2020 and will potentially be updated in the future! But for now, "
"some of the commands are dated but the content is still excellent."
msgstr ""
"[このPythonパッケージガイド](https://py-pkgs.org/07-releasing-versioning#automatic-"
"version-bumping) "
"で、pythonのセマンティックバージョンについての丁寧な議論を見つけることができます。なお、このガイドは2020年以降更新されておらず、今後も更新される可能性があります！しかし、今のところ、いくつかのコマンドは古いが、内容は依然として素晴らしいです。"

#: ../../package-structure-code/python-package-versions.md:295
msgid "Python Semantic Release Pros"
msgstr "Pythonセマンティックリリースの長所"

#: ../../package-structure-code/python-package-versions.md:297
msgid "Follows semver versioning closely"
msgstr "センバーのバージョニングに忠実に従う"

#: ../../package-structure-code/python-package-versions.md:298
msgid ""
"Enforces maintainers using descriptive commit messages which can simplify"
" troubleshooting and ensure a cleaner and more self-describing git "
"history."
msgstr "説明的なコミットメッセージを使ってメンテナを強制します。これにより、トラブルシューティングを簡素化し、よりクリーンで自己記述的なgit履歴を確保することができます。"

#: ../../package-structure-code/python-package-versions.md:300
msgid "Python Semantic Release Cons"
msgstr "Pythonセマンティックリリースの短所"

#: ../../package-structure-code/python-package-versions.md:302
msgid ""
"Requires very specific commit language to work. In practice some "
"maintainers and contributors may not be able to maintain that level of "
"specificity in commit messages (NOTE: there are bots that will check git "
"commit messages in a repo)"
msgstr ""
"動作させるには、非常に特殊なコミット言語が必要です。 "
"実際には、メンテナや貢献者の中にはコミットメッセージにそのレベルの具体性を保てない人もいるでしょう (注意: リポジトリ内の git commit"
" メッセージをチェックするボットがあります)。"

#: ../../package-structure-code/python-package-versions.md:303
msgid ""
"Release happens at the command line. This makes is harder to implement a "
"GitHub based release workflow as the wrong commit message could trigger a"
" release."
msgstr ""
"リリースはコマンドラインで行われます。 このため、GitHub "
"ベースのリリースワークフローを実装するのが難しくなります。間違ったコミットメッセージがリリースのトリガーになってしまう可能性があるからです。"

#: ../../package-structure-code/python-package-versions.md:304
msgid ""
"The version number is manually updated in a configuration file such as "
"`pyproject.toml` vs. in a package **\\_version.py** file."
msgstr ""
"バージョン番号は、 `pyproject.toml` のような設定ファイルとパッケージの **_version.py** "
"ファイルの間で手動で更新されます。"

#~ msgid "Package structure & code style"
#~ msgstr "パッケージ構造とコードスタイル"

#~ msgid "Python package structure information"
#~ msgstr "Pythonパッケージ構造情報"

#~ msgid "Wheel (.whl files):"
#~ msgstr "Wheel(.whlファイル):"

#~ msgid ""
#~ "While we recommend the **src/** layout"
#~ " we also review the **flat** layout"
#~ " here. Both are used in the "
#~ "Python ecosystem."
#~ msgstr ""
#~ "**src/** レイアウトを推奨しますが、ここでは **flat** レイアウトもレビューします。"
#~ " どちらも Python のエコシステムで使われています。"

#~ msgid "Sometimes tests are needed in a distribution"
#~ msgstr "ディストリビューションでテストが必要になることがあります"

#~ msgid ""
#~ "Check out the testing section of "
#~ "our guide for more information about "
#~ "tests."
#~ msgstr "テストの詳細については、ガイドのテストのセクションをご覧ください。"

#~ msgid ""
#~ "It's the most commonly found layout "
#~ "with the scientific Python ecosystem and"
#~ " people tend to look to other "
#~ "packages / maintainers that they respect"
#~ " for examples of how to build "
#~ "Python packages."
#~ msgstr "これは科学的なPythonエコシステムで最もよく見られるレイアウトであり、人々はPythonパッケージの構築方法の例として、尊敬する他のパッケージやメンテナに注目する傾向があります。"
