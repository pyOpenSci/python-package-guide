# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, pyOpenSci
# This file is distributed under the same license as the pyOpenSci Python
# Package Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pyOpenSci Python Package Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-02 18:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../tests/index.md:72
msgid "Intro"
msgstr ""

#: ../../tests/index.md:72
msgid "Write tests"
msgstr ""

#: ../../tests/index.md:72
msgid "Test types"
msgstr ""

#: ../../tests/index.md:72
msgid "Run tests locally"
msgstr ""

#: ../../tests/index.md:72
msgid "Run tests online (using CI)"
msgstr ""

#: ../../tests/index.md:72
msgid "Create & Run Tests"
msgstr ""

#: ../../tests/index.md:1
msgid "Tests and data for your Python package"
msgstr ""

#: ../../tests/index.md:3
msgid ""
"Tests are an important part of your Python package because they provide a"
" set of checks that ensure that your package is functioning how you "
"expect it to."
msgstr ""

#: ../../tests/index.md:7
msgid ""
"In this section you will learn more about the importance of writing tests"
" for your Python package and how you can setup infrastructure to run your"
" tests both locally and on GitHub."
msgstr ""

#: ../../tests/index.md:19
msgid "✨ Why write tests ✨"
msgstr ""

#: ../../tests/index.md:24
msgid ""
"Learn more about the art of writing tests for your Python package. Learn "
"about why you should write tests and how they can help you and potential "
"contributors to your project."
msgstr ""

#: ../../tests/index.md:31
msgid "✨ Types of tests ✨"
msgstr ""

#: ../../tests/index.md:36
msgid ""
"There are three general types of tests that you can write for your Python"
" package: unit tests, integration tests and end-to-end (or functional) "
"tests. Learn about all three."
msgstr ""

#: ../../tests/index.md:42
msgid "✨ Run tests locally ✨"
msgstr ""

#: ../../tests/index.md:47
msgid ""
"If you expect your users to use your package across different versions of"
" Python, then using an automation tool such as nox to run your tests is "
"useful. Learn about the various tools that you can use to run your tests "
"across python versions here."
msgstr ""

#: ../../tests/index.md:53
msgid "✨ Run tests online (using CI) ✨"
msgstr ""

#: ../../tests/index.md:58
msgid ""
"Continuous integration platforms such as GitHub actions can be useful for"
" running your tests across both different Python versions and different "
"operating systems. Learn about setting up tests to run in Continuous "
"Integration here."
msgstr ""

#: ../../tests/index.md:69
msgid "Graphic showing the elements of the packaging process."
msgstr ""

#: ../../tests/run-tests.md:6
msgid "Run Python package tests"
msgstr ""

#: ../../tests/run-tests.md:8
msgid ""
"Running your tests is important to ensure that your package is working as"
" expected. It's good practice to consider that tests will run on your "
"computer and your users' computers that may be running a different Python"
" version and operating systems. Think about the following when running "
"your tests:"
msgstr ""

#: ../../tests/run-tests.md:11
msgid ""
"Run your test suite in a matrix of environments that represent the Python"
" versions and operating systems your users are likely to have."
msgstr ""

#: ../../tests/run-tests.md:12
msgid ""
"Running your tests in an isolated environment provides confidence in the "
"tests and their reproducibility. This ensures that tests do not pass "
"randomly due to your computer's specific setup. For instance, you might "
"have unexpectedly installed dependencies on your local system that are "
"not declared in your package's dependency list. This oversight could lead"
" to issues when others try to install or run your package on their "
"computers."
msgstr ""

#: ../../tests/run-tests.md:14
msgid ""
"On this page, you will learn about the tools that you can use to both run"
" tests in isolated environments and across Python versions."
msgstr ""

#: ../../tests/run-tests.md:19
msgid "Tools to run your tests"
msgstr ""

#: ../../tests/run-tests.md:21
msgid ""
"There are three categories of tools that will make is easier to setup and"
" run your tests in various environments:"
msgstr ""

#: ../../tests/run-tests.md:24
msgid ""
"A **test framework**, is a package that provides a particular syntax and "
"set of tools for _both writing and running your tests_. Some test "
"frameworks also have plugins that add additional features such as "
"evaluating how much of your code the tests cover. Below you will learn "
"about the **pytest** framework which is one of the most commonly used "
"Python testing frameworks in the scientific ecosystem. Testing frameworks"
" are essential but they only serve to run your tests. These frameworks "
"don't provide a way to easily run tests across Python versions without "
"the aid of additional automation tools."
msgstr ""

#: ../../tests/run-tests.md:25
msgid ""
"**Automation tools** allow you to automate running workflows such as "
"tests in specific ways using user-defined commands. For instance it's "
"useful to be able to run tests across different Python versions with a "
"single command. Tools such as "
"[**nox**](https://nox.thea.codes/en/stable/index.html) and "
"[**tox**](https://tox.wiki/en/latest/index.html) also allow you to run "
"tests across Python versions. However, it will be difficult to test your "
"build on different operating systems using only nox and tox - this is "
"where continuous integration (CI) comes into play."
msgstr ""

#: ../../tests/run-tests.md:26
msgid ""
"**Continuous Integration (CI):** is the last tool that you'll need to run"
" your tests. CI will not only allow you to replicate any automated builds"
" you create using nox or tox to run your package in different Python "
"environments. It will also allow you to run your tests on different "
"operating systems (Windows, Mac and Linux). [We discuss using CI to run "
"tests here](tests-ci)."
msgstr ""

#: ../../tests/run-tests.md:28
msgid "Table: Testing & Automation Tool"
msgstr ""

#: ../../tests/run-tests.md:35
msgid "Features"
msgstr ""

#: ../../tests/run-tests.md:36
msgid "Testing Framework (pytest)"
msgstr ""

#: ../../tests/run-tests.md:37
msgid "Test Runner (Tox)"
msgstr ""

#: ../../tests/run-tests.md:38
msgid "Automation Tools (Nox)"
msgstr ""

#: ../../tests/run-tests.md:39
msgid "Continuous Integration (GitHub Actions)"
msgstr ""

#: ../../tests/run-tests.md:40
msgid "Run Tests Locally"
msgstr ""

#: ../../tests/run-tests.md:41 ../../tests/run-tests.md:42
#: ../../tests/run-tests.md:43 ../../tests/run-tests.md:49
#: ../../tests/run-tests.md:52 ../../tests/run-tests.md:53
#: ../../tests/run-tests.md:54 ../../tests/run-tests.md:57
#: ../../tests/run-tests.md:58 ../../tests/run-tests.md:59
#: ../../tests/run-tests.md:64 ../../tests/run-tests.md:68
#: ../../tests/run-tests.md:69
msgid "<i class=\"fa-solid fa-circle-check fa-xl\"></i>"
msgstr ""

#: ../../tests/run-tests.md:44 ../../tests/run-tests.md:46
#: ../../tests/run-tests.md:47 ../../tests/run-tests.md:48
#: ../../tests/run-tests.md:51 ../../tests/run-tests.md:56
#: ../../tests/run-tests.md:61 ../../tests/run-tests.md:62
#: ../../tests/run-tests.md:63 ../../tests/run-tests.md:66
#: ../../tests/run-tests.md:67
msgid "<i class=\"fa-solid fa-xmark fa-xl\" style=\"color: #afb3bb;\"></i>"
msgstr ""

#: ../../tests/run-tests.md:45
msgid "Run Tests Online"
msgstr ""

#: ../../tests/run-tests.md:50
msgid "Run Tests Across Python Versions"
msgstr ""

#: ../../tests/run-tests.md:55
msgid "Run Tests In Isolated Environments"
msgstr ""

#: ../../tests/run-tests.md:60
msgid "Run Tests Across Operating Systems (Windows, MacOS, Linux)"
msgstr ""

#: ../../tests/run-tests.md:65
msgid "Use for other automation tasks (e.g. building docs)"
msgstr ""

#: ../../tests/run-tests.md:73
msgid "What testing framework / package should I use to run tests?"
msgstr ""

#: ../../tests/run-tests.md:75
msgid ""
"We recommend using `Pytest` to build and run your package tests. Pytest "
"is the most common testing tool used in the Python ecosystem."
msgstr ""

#: ../../tests/run-tests.md:77
msgid ""
"[The Pytest package](https://docs.pytest.org/en/latest/) also has a "
"number of extensions that can be used to add functionality such as:"
msgstr ""

#: ../../tests/run-tests.md:80
msgid ""
"[pytest-cov](https://pytest-cov.readthedocs.io/en/latest/) allows you to "
"analyze the code coverage of your package during your tests, and "
"generates a report that you can [upload to codecov](https://codecov.io/)."
msgstr ""

#: ../../tests/run-tests.md:82 ../../tests/run-tests.md:174
#: ../../tests/test-types.md:14 ../../tests/tests-ci.md:7
msgid "Todo"
msgstr ""

#: ../../tests/run-tests.md:83
msgid "Learn more about code coverage here. (add link)"
msgstr ""

#: ../../tests/run-tests.md:87
msgid ""
"Your editor or IDE may add additional convenience for running tests, "
"setting breakpoints, and toggling the `–no-cov` flag. Check your editor's"
" documentation for more information."
msgstr ""

#: ../../tests/run-tests.md:90
msgid "Run tests using pytest"
msgstr ""

#: ../../tests/run-tests.md:92
msgid "If you are using **pytest**, you can run your tests locally by calling:"
msgstr ""

#: ../../tests/run-tests.md:95
msgid "`pytest`"
msgstr ""

#: ../../tests/run-tests.md:97
msgid ""
"Or if you want to run a specific test file - let's call this file "
"\"`test_module.py`\" - you can run:"
msgstr ""

#: ../../tests/run-tests.md:99
msgid "`pytest test_module.py`"
msgstr ""

#: ../../tests/run-tests.md:101
msgid ""
"Learn more from the [get started docs](https://docs.pytest.org/en/7.1.x"
"/getting-started.html)."
msgstr ""

#: ../../tests/run-tests.md:103
msgid ""
"Running pytest on your computer is going to run your tests in whatever "
"Python environment you currently have activated. This means that tests "
"will be run on a single version of Python and only on the operating "
"system that you are running locally."
msgstr ""

#: ../../tests/run-tests.md:108
msgid ""
"An automation tool can simplify the process of running tests in various "
"Python environments."
msgstr ""

#: ../../tests/run-tests.md:111
msgid "Tests across operating systems"
msgstr ""

#: ../../tests/run-tests.md:112
msgid ""
"If you want to run your tests across different operating systems you can "
"[continuous integration. Learn more here](tests-ci)."
msgstr ""

#: ../../tests/run-tests.md:115
msgid "Tools to automate running your tests"
msgstr ""

#: ../../tests/run-tests.md:117
msgid ""
"To run tests on various Python versions or in various specific "
"environments with a single command, you can use an automation tool such "
"as `nox` or `tox`. Both `nox` and `tox` can create an isolated virtual "
"environments. This allows you to easily run your tests in multiple "
"environments and across Python versions."
msgstr ""

#: ../../tests/run-tests.md:120
msgid ""
"We will focus on [Nox](https://nox.thea.codes/) in this guide. `nox` is a"
" Python-based automation tool that builds upon the features of both "
"`make` and `tox`. `nox` is designed to simplify and streamline testing "
"and development workflows. Everything that you do with `nox` can be "
"implemented using a Python-based interface."
msgstr ""

#: ../../tests/run-tests.md:122
msgid "Other automation tools you'll see in the wild"
msgstr ""

#: ../../tests/run-tests.md:125
msgid ""
"**[Tox](https://tox.wiki/en/latest/index.html#useful-links)** is an "
"automation tool that supports common steps such as building "
"documentation, running tests across various versions of Python, and more."
" You can find [a nice overview of tox in the plasmaPy "
"documentation](https://docs.plasmapy.org/en/stable/contributing/testing_guide.html"
"#using-tox)."
msgstr ""

#: ../../tests/run-tests.md:127
msgid ""
"**[Hatch](https://github.com/ofek/hatch)** is a modern end-to-end "
"packaging tool that works with the popular build backend called "
"hatchling. `hatch` offers a `tox`-like setup where you can run tests "
"locally using different Python versions. If you are using `hatch` to "
"support your packaging workflow, you may want to also use its testing "
"capabilities rather than using `nox`."
msgstr ""

#: ../../tests/run-tests.md:129
msgid ""
"[**make:**](https://www.gnu.org/software/make/manual/make.html) Some "
"developers use Make, which is a build automation tool, for running tests "
"due to its versatility; it's not tied to a specific language and can be "
"used to run various build processes. However, Make's unique syntax and "
"approach can make it more challenging to learn, particularly if you're "
"not already familiar with it. Make also won't manage environments for you"
" like **nox** will do."
msgstr ""

#: ../../tests/run-tests.md:136
msgid "Run tests across Python versions with nox"
msgstr ""

#: ../../tests/run-tests.md:138
msgid "**Nox** is a great automation tool to learn because it:"
msgstr ""

#: ../../tests/run-tests.md:140
msgid "Is Python-based making it accessible if you already know Python and"
msgstr ""

#: ../../tests/run-tests.md:141
msgid "Will create isolated environments to run workflows."
msgstr ""

#: ../../tests/run-tests.md:143
msgid ""
"`nox` simplifies creating and managing testing environments. With `nox`, "
"you can set up virtual environments, and run tests across Python versions"
" using the environment manager of your choice with a single command."
msgstr ""

#: ../../tests/run-tests.md:148
msgid "Nox Installations"
msgstr ""

#: ../../tests/run-tests.md:150
msgid ""
"When you install and use nox to run tests across different Python "
"versions, nox will create and manage individual `venv` environments for "
"each Python version that you specify in the nox function."
msgstr ""

#: ../../tests/run-tests.md:152
msgid "Nox will manage each environment on its own."
msgstr ""

#: ../../tests/run-tests.md:154
msgid ""
"Nox can also be used for other development tasks such as building "
"documentation, creating your package distribution, and testing "
"installations across both PyPI related environments (e.g. venv, "
"virtualenv) and `conda` (e.g. `conda-forge`)."
msgstr ""

#: ../../tests/run-tests.md:158
msgid ""
"To get started with nox, you create a `noxfile.py` file at the root of "
"your project directory. You then define commands using Python functions. "
"Some examples of that are below."
msgstr ""

#: ../../tests/run-tests.md:162
msgid "Test Environments"
msgstr ""

#: ../../tests/run-tests.md:164
msgid ""
"By default, `nox` uses the Python built in `venv` environment manager. A "
"virtual environment (`venv`) is a self-contained Python environment that "
"allows you to isolate and manage dependencies for different Python "
"projects. It helps ensure that project-specific libraries and packages do"
" not interfere with each other, promoting a clean and organized "
"development environment."
msgstr ""

#: ../../tests/run-tests.md:166
msgid ""
"An example of using nox to run tests in `venv` environments for Python "
"versions 3.9, 3.10, 3.11 and 3.12 is below."
msgstr ""

#: ../../tests/run-tests.md:169
msgid ""
"Note that for the code below to work, you need to have all 4 versions of "
"Python installed on your computer for `nox` to find."
msgstr ""

#: ../../tests/run-tests.md:172
msgid "Nox with venv environments"
msgstr ""

#: ../../tests/run-tests.md:175
msgid ""
"TODO: add some tests above and show what the output would look like in "
"the examples below..."
msgstr ""

#: ../../tests/run-tests.md:178
msgid ""
"Below is an example of setting up nox to run tests using `venv` which is "
"the built in environment manager that comes with base Python."
msgstr ""

#: ../../tests/run-tests.md:180
msgid ""
"Note that the example below assumes that you have [setup your "
"`pyproject.toml` to declare test dependencies in a way that pip can "
"understand](../package-structure-code/declare-dependencies.md). An "
"example of that setup is below."
msgstr ""

#: ../../tests/run-tests.md:201
msgid ""
"If you have the above setup, then you can use "
"`session.install(\".[tests]\")` to install your test dependencies. Notice"
" that below one single nox session allows you to run your tests on 4 "
"different Python environments (Python 3.9, 3.10, 3.11, and 3.12)."
msgstr ""

#: ../../tests/run-tests.md:222
msgid ""
"Above you create a nox session in the form of a function with a "
"`@nox.session` decorator. Notice that within the decorator you declare "
"the versions of python that you wish to run."
msgstr ""

#: ../../tests/run-tests.md:226
msgid ""
"To run the above you'd execute the following command, specifying which "
"session with `--session` (sometimes shortened to `-s`). Your function "
"above is called test, therefore the session name is test."
msgstr ""

#: ../../tests/run-tests.md:234
msgid "Nox with conda / mamba"
msgstr ""

#: ../../tests/run-tests.md:236
msgid ""
"Below is an example for setting up nox to use mamba (or conda) for your "
"environment manager. Note that unlike venv, conda can automatically "
"install the various versions of Python that you need. You won't need to "
"install all four Python versions if you use conda/mamba, like you do with"
" `venv`."
msgstr ""

#: ../../tests/run-tests.md:242
msgid ""
"For `conda` to work with `nox`, you will need to ensure that either "
"`conda` or `mamba` is installed on your computer."
msgstr ""

#: ../../tests/run-tests.md:264
msgid "To run the above session you'd use:"
msgstr ""

#: ../../tests/test-types.md:1
msgid "Test Types for Python packages"
msgstr ""

#: ../../tests/test-types.md:3
msgid "Three types of tests: Unit, Integration & Functional Tests"
msgstr ""

#: ../../tests/test-types.md:5
msgid ""
"There are different types of tests that you want to consider when "
"creating your test suite:"
msgstr ""

#: ../../tests/test-types.md:8
msgid "Unit tests"
msgstr ""

#: ../../tests/test-types.md:9
msgid "Integration"
msgstr ""

#: ../../tests/test-types.md:10
msgid "End-to-end (also known as Functional) tests"
msgstr ""

#: ../../tests/test-types.md:12
msgid ""
"Each type of test has a different purpose. Here, you will learn about all"
" three types of tests."
msgstr ""

#: ../../tests/test-types.md:15
msgid ""
"I think this page would be stronger if we did have some examples from our"
" package here: https://github.com/pyOpenSci/pyosPackage"
msgstr ""

#: ../../tests/test-types.md:20
msgid "Unit Tests"
msgstr ""

#: ../../tests/test-types.md:22
msgid ""
"A unit test involves testing individual components or units of code in "
"isolation to ensure that they work correctly. The goal of unit testing is"
" to verify that each part of the software, typically at the function or "
"method level, performs its intended task correctly."
msgstr ""

#: ../../tests/test-types.md:24
msgid ""
"Unit tests can be compared to examining each piece of your puzzle to "
"ensure parts of it are not broken. If all of the pieces of your puzzle "
"don’t fit together, you will never complete it. Similarly, when working "
"with code, tests ensure that each function, attribute, class, method "
"works properly when isolated."
msgstr ""

#: ../../tests/test-types.md:26
msgid ""
"**Unit test example:** Pretend that you have a function that converts a "
"temperature value from Celsius to Fahrenheit. A test for that function "
"might ensure that when provided with a value in Celsius, the function "
"returns the correct value in degrees Fahrenheit. That function is a unit "
"test. It checks a single unit (function) in your code."
msgstr ""

#: ../../tests/test-types.md:44
msgid ""
"Example unit test for the above function. You'd run this test using the "
"`pytest` command in your **tests/** directory."
msgstr ""

#: ../../tests/test-types.md:65 ../../tests/test-types.md:115
msgid ""
"image of puzzle pieces that all fit together nicely. The puzzle pieces "
"are colorful - purple, green and teal."
msgstr ""

#: ../../tests/test-types.md:69
msgid ""
"Your unit tests should ensure each part of your code works as expected on"
" its own."
msgstr ""

#: ../../tests/test-types.md:72
msgid "Integration tests"
msgstr ""

#: ../../tests/test-types.md:74
msgid ""
"Integration tests involve testing how parts of your package work together"
" or integrate. Integration tests can be compared to connecting a bunch of"
" puzzle pieces together to form a whole picture. Integration tests focus "
"on how different pieces of your code fit and work together."
msgstr ""

#: ../../tests/test-types.md:76
msgid ""
"For example, if you had a series of steps that collected temperature data"
" in a spreadsheet, converted it from degrees celsius to Fahrenheit and "
"then provided an average temperature for a particular time period. An "
"integration test would ensure that all parts of that workflow behaved as "
"expected."
msgstr ""

#: ../../tests/test-types.md:107
msgid ""
"image of two puzzle pieces with some missing parts. The puzzle pieces are"
" purple teal yellow and blue. The shapes of each piece don’t fit "
"together."
msgstr ""

#: ../../tests/test-types.md:112
msgid ""
"If puzzle pieces have missing ends, they can’t work together with other "
"elements in the puzzle. The same is true with individual functions, "
"methods and classes in your software. The code needs to work both "
"individually and together to perform certain sets of tasks."
msgstr ""

#: ../../tests/test-types.md:120
msgid ""
"Your integration tests should ensure that parts of your code that are "
"expected to work together, do so as expected."
msgstr ""

#: ../../tests/test-types.md:124
msgid "End-to-end (functional) tests"
msgstr ""

#: ../../tests/test-types.md:126
msgid ""
"End-to-end tests (also referred to as functional tests) in Python are "
"like comprehensive checklists for your software. They simulate real user "
"end-to-end workflows to make sure the code base supports real life "
"applications and use-cases from start to finish. These tests help catch "
"issues that might not show up in smaller tests and ensure your entire "
"application or program behaves correctly. Think of them as a way to give "
"your software a final check before it's put into action, making sure it's"
" ready to deliver a smooth experience to its users."
msgstr ""

#: ../../tests/test-types.md:128
msgid "Image of a completed puzzle showing a daisy"
msgstr ""

#: ../../tests/test-types.md:133
msgid ""
"End-to-end or functional tests represent an entire workflow that you "
"expect your package to support."
msgstr ""

#: ../../tests/test-types.md:137
msgid ""
"End-to-end test also test how a program runs from start to finish. A "
"tutorial that you add to your documentation that runs in CI in an "
"isolated environment is another example of an end-to-end test."
msgstr ""

#: ../../tests/test-types.md:140
msgid ""
"For scientific packages, creating short tutorials that highlight core "
"workflows that your package supports, that are run when your "
"documentation is built could also serve as end-to-end tests."
msgstr ""

#: ../../tests/test-types.md:143
msgid "Comparing unit, integration and end-to-end tests"
msgstr ""

#: ../../tests/test-types.md:145
msgid ""
"Unit tests, integration tests, and end-to-end tests have complementary "
"advantages and disadvantages. The fine-grained nature of unit tests make "
"them well-suited for isolating where errors are occurring. However, unit "
"tests are not useful for verifying that different sections of code work "
"together."
msgstr ""

#: ../../tests/test-types.md:147
msgid ""
"Integration and end-to-end tests verify that the different portions of "
"the program work together, but are less well-suited for isolating where "
"errors are occurring. For example, when you refactor your code, it is "
"possible that that your end-to-end tests will break. But if the refactor "
"didn't introduce new behavior to your existing code, then you can rely on"
" your unit tests to continue to pass, testing the original functionality "
"of your code."
msgstr ""

#: ../../tests/test-types.md:152
msgid ""
"It is important to note that you don't need to spend energy worrying "
"about the specifics surrounding the different types of tests. When you "
"begin to work on your test suite, consider what your package does and how"
" you may need to test parts of your package. Bring familiar with the "
"different types of tests can provides a framework to help you think about"
" writing tests and how different types of tests can complement each "
"other."
msgstr ""

#: ../../tests/tests-ci.md:1
msgid "Run tests with Continuous Integration"
msgstr ""

#: ../../tests/tests-ci.md:3
msgid ""
"Running your [test suite locally](run-tests) is useful as you develop "
"code and also test new features or changes to the code base. However, you"
" also will want to setup Continuous Integration (CI) to run your tests "
"online. CI allows you to run all of your tests in the cloud. While you "
"may only be able to run tests locally on a specific operating system, "
"using CI you can specify tests to run both on various versions of Python "
"and across different operating systems."
msgstr ""

#: ../../tests/tests-ci.md:5
msgid ""
"CI can also be triggered for pull requests and pushes to your repository."
" This means that every pull request that you, your maintainer team or a "
"contributor submit, can be tested. In the end CI testing ensures your "
"code continues to run as expected even as changes are made to the code "
"base."
msgstr ""

#: ../../tests/tests-ci.md:9
msgid ""
"Learn more about Continuous Integration and how it can be used, here. "
"(add link)"
msgstr ""

#: ../../tests/tests-ci.md:13
msgid "CI & pull requests"
msgstr ""

#: ../../tests/tests-ci.md:15
msgid ""
"CI is invaluable if you have outside people contributing to your "
"software. You can setup CI to run on all pull requests submitted to your "
"repository. CI can make your repository more friendly to new potential "
"contributors. It allows users to contribute code, documentation fixes and"
" more without having to create development environments, run tests and "
"build documentation locally."
msgstr ""

#: ../../tests/tests-ci.md:22
msgid "Example GitHub action that runs tests"
msgstr ""

#: ../../tests/tests-ci.md:24
msgid ""
"Below is an example GitHub action that runs tests using nox across both "
"Windows, Mac and Linux and on Python versions 3.9-3.11."
msgstr ""

#: ../../tests/tests-ci.md:28
msgid ""
"To work properly, this file should be located in a root directory of your"
" GitHub repository:"
msgstr ""

#: ../../tests/write-tests.md:1
msgid "Write tests for your Python package"
msgstr ""

#: ../../tests/write-tests.md:3
msgid ""
"Writing code that tests your package code, also known as test suites, is "
"important for you as a maintainer, your users, and package contributors. "
"Test suites consist of sets of functions, methods, and classes that are "
"written with the intention of making sure a specific part of your code "
"works as you expected it to."
msgstr ""

#: ../../tests/write-tests.md:7
msgid "Why write tests for your package?"
msgstr ""

#: ../../tests/write-tests.md:9
msgid ""
"Tests act as a safety net for code changes. They help you spot and "
"rectify bugs before they affect users. Tests also instill confidence that"
" code alterations from contributors won't breaking existing "
"functionality."
msgstr ""

#: ../../tests/write-tests.md:13
msgid "Writing tests for your Python package is important because:"
msgstr ""

#: ../../tests/write-tests.md:15
msgid ""
"**Catch Mistakes:** Tests are a safety net. When you make changes or add "
"new features to your package, tests can quickly tell you if you "
"accidentally broke something that was working fine before."
msgstr ""

#: ../../tests/write-tests.md:16
msgid ""
"**Save Time:** Imagine you have a magic button that can automatically "
"check if your package is still working properly. Tests are like that "
"magic button! They can run all those checks for you saving you time."
msgstr ""

#: ../../tests/write-tests.md:17
msgid ""
"**Easier Collaboration:** If you're working with others, or have outside "
"contributors, tests help everyone stay on the same page. Your tests "
"explain how your package is supposed to work, making it easier for others"
" to understand and contribute to your project."
msgstr ""

#: ../../tests/write-tests.md:18
msgid ""
"**Fearless Refactoring:** Refactoring means making improvements to your "
"code structure without changing its behavior. Tests empower you to make "
"these changes as if you break something, test failures will let you know."
msgstr ""

#: ../../tests/write-tests.md:19
msgid ""
"**Documentation:** Tests serve as technical examples of how to use your "
"package. This can be helpful for a new technical contributor that wants "
"to contribute code to your package. They can look at your tests to "
"understand how parts of your code functionality fits together."
msgstr ""

#: ../../tests/write-tests.md:20
msgid ""
"**Long-Term ease of maintenance:** As your package evolves, tests ensure "
"that your code continues to behave as expected, even as you make changes "
"over time. Thus you are helping your future self when writing tests."
msgstr ""

#: ../../tests/write-tests.md:21
msgid ""
"**Easier pull request reviews:** By running your tests in a CI framework "
"such as GitHub actions, each time you or a contributor makes a change to "
"your code-base, you can catch issues and things that may have changed in "
"your code base. This ensures that your software behaves the way you "
"expect it to."
msgstr ""

#: ../../tests/write-tests.md:23
msgid "Tests for user edge cases"
msgstr ""

#: ../../tests/write-tests.md:25
msgid ""
"Edge cases refer to unexpected or \"outlier\" ways that some users may "
"use your package. Tests enable you to address various edge cases that "
"could impair your package's functionality. For example, what occurs if a "
"function expects a pandas `dataframe` but a user supplies a numpy "
"`array`? Does your code gracefully handle this situation, providing clear"
" feedback, or does it leave users frustrated by an unexplained failure?"
msgstr ""

#: ../../tests/write-tests.md:33
msgid ""
"For a good introduction to testing, see [this Software Carpentry "
"lesson](https://swcarpentry.github.io/python-novice-"
"inflammation/10-defensive.html)"
msgstr ""

#: ../../tests/write-tests.md:41
msgid ""
"Imagine you're working on a puzzle where each puzzle piece represents a "
"function, method, class or attribute in your Python package that you want"
" other people to be able to use. Would you want to give someone a puzzle "
"that has missing pieces or pieces that don't fit together? Providing "
"people with the right puzzle pieces that work together can be compared to"
" writing tests for your Python package."
msgstr ""

#: ../../tests/write-tests.md:44
msgid "Test examples"
msgstr ""

#: ../../tests/write-tests.md:47
msgid ""
"Let’s say you have a Python function that adds two numbers a and b "
"together."
msgstr ""

#: ../../tests/write-tests.md:54
msgid ""
"A test to ensure that function runs as you might expect when provided "
"with different numbers might look like this:"
msgstr ""

#: ../../tests/write-tests.md:72
msgid "🧩🐍"
msgstr ""

#: ../../tests/write-tests.md:74
msgid "How do I know what type of tests to write?"
msgstr ""

#: ../../tests/write-tests.md:77
msgid ""
"This section has been adapted from [a presentation by Nick "
"Murphy](https://zenodo.org/record/8185113)."
msgstr ""

#: ../../tests/write-tests.md:80
msgid ""
"At this point, you may be wondering - what should you be testing in your "
"package? Below are a few examples:"
msgstr ""

#: ../../tests/write-tests.md:82
msgid ""
"**Test some typical cases:** Test that the package functions as you "
"expect it to when users use it. For instance, if your package is supposed"
" to add two numbers, test that the outcome value of adding those two "
"numbers is correct."
msgstr ""

#: ../../tests/write-tests.md:84
msgid ""
"**Test special cases:** Sometimes there are special or outlier cases. For"
" instance, if a function performs a specific calculation that may become "
"problematic closer to the value = 0, test it with the input of both 0 and"
msgstr ""

#: ../../tests/write-tests.md:86
msgid ""
"**Test at and near the expected boundaries:** If a function requires a "
"value that is greater than or equal to 1, make sure that the function "
"still works with both the values 1 and less than one and 1.001 as well "
"(something close to the constraint value).."
msgstr ""

#: ../../tests/write-tests.md:88
msgid ""
"**Test that code fails correctly:** If a function requires a value "
"greater than or equal to 1, then test at 0.999. Make sure that the "
"function fails gracefully when given unexpected values and help and that "
"the user can easily understand why if failed (provides a useful error "
"message)."
msgstr ""
