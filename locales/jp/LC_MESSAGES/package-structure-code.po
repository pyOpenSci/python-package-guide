# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, pyOpenSci
# This file is distributed under the same license as the pyOpenSci Python
# Package Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pyOpenSci Python Package Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-02 18:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: jp\n"
"Language-Team: jp <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../package-structure-code/code-style-linting-format.md:1
msgid "Python Package Code Style, Format and Linters"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:3
#: ../../package-structure-code/publish-python-package-pypi-conda.md:12
msgid "Take Aways"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:5
msgid "pyOpenSci requires authors to follow PEP 8 code format guidelines"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:6
msgid ""
"Setting up a code formatters like Black and isort will help you enforce "
"PEP 8 style guidelines and also consistent, readable code format"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:7
msgid "Some commonly used tools are: Black, Isort, flake8, Ruff"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:8
msgid ""
"You can also setup pre-commit hooks which will run code formatters "
"locally each time you make a commit."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:10
msgid ""
"[precommit.ci](https://pre-commit.ci/) is a bot that you can add to your "
"GitHub repository. It will automagically apply code format to every PR "
"using the tools specified in your pre-commit-config.yaml file. It can "
"save significant time and make contributions easier for new contributors."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:11
msgid ""
"Automation is good! By making code quality tools care of your code, you "
"can focus on structural and high values tasks."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:14
msgid ""
"Consistent code format and style is useful to both your package and "
"across the scientific Python ecosystem because using similar formats "
"makes code easier to read."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:18
msgid ""
"For instance, if you saw a sentence like this one without any spaces, or "
"punctuation, it would take your brain longer to process it."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:25
msgid ""
"pyOpenSci peer review process requires that you to follow standard "
"[Python PEP 8 format rules](https://peps.python.org/pep-0008/) as closely"
" as you can."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:29
msgid ""
"pyOpenSci doesn't require you to use a specific code format tool. "
"However, we do look for consistency and readability in code style. Below "
"you will find a discussion of:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:33
msgid "The benefits of using linters and code format tools in your workflow"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:34
msgid "Some commonly used tools in the scientific Python space"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:35
msgid ""
"Setting up pre-commit hooks and the pre-commit.ci bot to make using code "
"format tools in daily workflows and in pull requests on GitHub easier."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:38
msgid "Use a code format tool (or tools) to make your life easier"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:40
msgid ""
"We suggest that you use a code format tool, or a set of format tools, "
"because manually applying all of the PEP 8 format specifications is both "
"time consuming for maintainers and can be a road block for potential new "
"contributors. Code formatters will automagically reformat your code for "
"you, adhering to PEP 8 standards and applying consistent style decisions "
"throughout."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:46
msgid "Setting up a code format suite of tools will:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:48
msgid "Save you and your maintainer team time in fixing PEP 8 inconsistencies."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:49
msgid "Ensure that format and style is consistent across your entire code-base."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:50
msgid ""
"Avoid lengthy discussions with contributors and other maintainers about "
"personalized code format preferences during reviews."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:52
msgid ""
"Avoid pure visual edits in the code base so that code reviews focus on "
"added value"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:54
msgid ""
"Many packages use a suite of tools to apply code format rules, taking the"
" work out of manually implementing code format requirements."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:57
msgid ""
"Consistent code format across packages within the (scientific) Python "
"ecosystem, will also broadly make code easier to scan, understand and "
"contribute to."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:60
msgid "Linting vs format and style"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:62
msgid "Before we dive in let's get a few definitions out of the way."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:64
msgid "Code Linting"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:66
msgid ""
"A code linter is a tool that will review your code and identify errors or"
" issues. A linter typically does not modify your code. It will tell you "
"what the error is and on what line it was discovered. Flake8, discussed "
"below, is an example of a commonly-used code linter."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:71
msgid "Code Formatters (and stylers)"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:73
msgid ""
"Code formatters will reformat your code for you. Python focused code "
"formatters often follow PEP 8 standards. However, they also make "
"stylistic decisions about code consistency."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:77
msgid ""
"Black is an example of a commonly-used code formatter. Black both applies"
" PEP 8 standards while also making decisions about things like consistent"
" use of double quotes for strings, and spacing of items in lists."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:81
msgid "You will learn more about Black below."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:83
msgid "Code linting, formatting and styling tools"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:85
msgid "Black"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:87
msgid ""
"[Black](https://black.readthedocs.io/en/stable/) is a code formatter. "
"Black will automagically (and _unapologetically_) fix spacing issues and "
"ensure code format is consistent throughout your package. Black also "
"generally adheres to PEP 8 style guidelines with some exceptions. A few "
"examples of those exceptions are below:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:93
msgid ""
"Black defaults to a line length of 88 (79 + 10%) rather than the 79 "
"character `PEP 8` specification. However, line length is a setting can be"
" manually overwritten in your Black configuration."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:94
msgid "Black will not adjust line length in your comments or docstrings."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:95
msgid ""
"This tool will not review and fix import order (you need `isort` or "
"`ruff` to do that - see below)."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:98
msgid ""
"If you are interested in seeing how Black will format your code, you can "
"use the [Black playground](https://black.vercel.app/)"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:102
msgid ""
"Using a code formatter like Black will leave you more time to work on "
"code function rather than worry about format."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:105
msgid "Flake8"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:107
msgid ""
"To adhere to Python `pep8` format standards, you might want to add "
"[flake8](https://flake8.pycqa.org/en/latest/) to your code format "
"toolbox."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:111
msgid "flake8 will:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:113
msgid ""
"Flag every line in your code that extends beyond 79 characters (including"
" those in docstrings and comments)"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:114
msgid ""
"Flag spacing issues that conflict with PEP 8 guidelines such as missing "
"spaces after commas"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:116
msgid ""
"Flake8 also flags unused imports and unused declared variables in your "
"modules."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:119
msgid ""
"Below you can see the output of running `flake8 filename.py` at the "
"command line for a Python file within a package called `stravalib`."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:123
msgid "The line length standard for PEP 8 is 79 characters."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:125
msgid ""
"Notice that flake8 returns a list of issues that it found in the model.py"
" module on the command line. The Python file itself is not modified. "
"Using this output, you can fix each issue line by line manually."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:140
msgid "Isort"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:142
msgid ""
"Python imports refer to the Python packages that a module in your package"
" requires. Imports should always be located at the top of each Python "
"module in your package."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:146
msgid ""
"[PEP 8 has specific standards for the order of these "
"imports](https://peps.python.org/pep-0008/#imports). These standards are "
"listed below:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:148
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:150
msgid "Standard library imports."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:151
msgid "Related third party imports."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:152
msgid "Local application/library specific imports."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:154
msgid ""
"While `flake8` will identify unused imports in your code, it won't fix or"
" identify issues with the order of package imports."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:157
msgid ""
"`isort` will identify where imports in your code are out of order. It "
"will then modify your code, automatically reordering all imports. This "
"leaves you with one less thing to think about when cleaning up your code."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:162
msgid "Example application of isort"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:164
msgid "Code imports before `isort` is run:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:166
msgid ""
"Below, the `pandas` is a third party package, `typing` is a core `Python`"
" package distributed with `Python`, and `examplePy.temperature` is a "
"first-party module which means it belongs to the same package as the file"
" doing the import. Also notice that there are no spaces in the imports "
"listed below."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:176
msgid "From the project root, run:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:182
msgid "Python file `temporal.py` imports after `isort` has been run"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:189
msgid "Ruff"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:191
msgid ""
"[Ruff](https://docs.astral.sh/ruff/) is a new addition to the code "
"quality ecosystem, gaining some traction since its release. `ruff` is "
"both a linter and a code formatter for Python, aiming to replace several "
"tools behind a single interface. As such, `ruff` can be used at a "
"replacement of all other tools mentioned here, or in complement to some "
"of them."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:197
msgid ""
"`ruff` has some interesting features that distinguish it from other "
"linters:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:199
msgid "Linter configuration in `pyproject.toml`"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:200
msgid "Several hundred rules included, many of which are automatically fixable"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:201
msgid ""
"Rules explanation, see [F403](https://docs.astral.sh/ruff/rules"
"/undefined-local-with-import-star/) for an example"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:202
msgid ""
"Fast execution time, makes a quick feedback loop possible even on large "
"projects."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:204
msgid ""
"Here is a simple configuration to get started with `ruff`. It would go "
"into your `pyproject.toml`:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:212
msgid ""
"Depending on your project, you might want to add the following to sort "
"imports correctly:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:219
msgid "How to use code formatter in your local workflow"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:221
msgid "Linters, code formatters and your favorite coding tools"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:223
msgid ""
"Linters can be run as a command-line tool as shown above. They also can "
"be run within your favorite coding tool (e.g. VScode, pycharm, etc). For "
"example, you might prefer to have tools like Black and isort run when you"
" save a file. In some editors you can also setup shortcuts that run your "
"favorite code format tools on demand."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:229
msgid "Use pre-commit hooks to run code formatters and linters on commits"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:231
msgid "You can also setup a `pre-commit hook` in your Python package repository."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:233
msgid ""
"A pre-commit hook is a tool that allows an action (or actions) to be "
"triggered when you apply a commit to your git repository."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:236
msgid "Pre-commit hook example workflow"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:238
msgid "The precommit workflow looks like this: You type and run:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:241
msgid "`git commit -m \"message here\"` at the command line"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:243
msgid ""
"Once you hit return, pre-commit will run any tools that you have "
"configured in a **.pre-commit-config.yaml** file."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:245
msgid ""
"If the tools configured in the pre-commit hook run successfully without "
"making changes or finding errors in your code, the commit will be applied"
" to the repository."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:249
msgid ""
"If the tools configured in the hook find errors in your files, the commit"
" will NOT be applied to the repository. Remember from the discussion "
"above that a code formatter like Black will run and reformat your code. A"
" linter like _flake8_ will provide you with some output that details "
"where there are syntax issues in your code. You will then need to fix "
"those issues, manually."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:256
msgid ""
"Once all of the fixes are applied you can re-add (stage) the files to be "
"commit. And re-run your commit."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:260
msgid "Diagram showing the steps of a pre-commit workflow from left to right."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:262
msgid ""
"The pre-commit workflow begins with you adding files that have changes to"
" be staged in git. Next, you'd run git commit. when you run git commit, "
"the pre-commit hooks will then run. In this example, Black, the code "
"formatter and flake8, a linter both run. If all of the files pass Black "
"and flake8 checks, then your commit will be recorded. If they don't, the "
"commit is canceled. You will have to fix any flake8 issues, and then re-"
"add / stage the files to be committed. [_Image "
"Source_](https://ljvmiranda921.github.io/notebook/2018/06/21/precommits-"
"using-black-and-flake8/*)"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:275
msgid ""
"If have a Python code-base and multiple maintainers actively working on "
"the code, and you intend to run a tool like Black, be sure to coordinate "
"across your team. An initial commit that applies Black to your entire "
"package will likely change a significant amount of your code. This could "
"lead to merge conflicts on open and new PR's before the new changes are "
"merged."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:282
msgid "General pre commit checks"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:284
msgid ""
"In addition to calling tools, Pre-commit also has a suite of [built in "
"format hooks](https://github.com/pre-commit/pre-commit-hooks#hooks-"
"available) that you can call. Some, such as trailing-whitespace can be "
"also useful to add to your pre-commit workflow to ensure clean, "
"streamlined code files."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:289
msgid ""
"An example pre-commit-config.yaml file is below with examples of how this"
" is all setup."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:292
msgid "Pre-commit.ci"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:294
msgid ""
"[Pre-commit.ci](https://pre-commit.ci) is a bot that may become your new "
"best friend. This bot, when setup on a repo can be configured to do the "
"following:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:297
msgid "It will check every pull request using all of the pre-commit hook setting"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:298
msgid ""
"If you wish, it will also submit a pull request to your repo with pre-"
"commit fixes, saving you, and new contributors the time of reformatting a"
" pr that has format issues."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:301
msgid "You can also call the bot on any pull request to run / and fix the code."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:303
msgid ""
"The pre-commit.ci bot uses the same pre-commit-config.yaml file that you "
"use to setup pre-commit locally."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:306
msgid "Setting up a bot like this can be valuable because:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:308
msgid ""
"It can make is easier for maintainers as they no longer have to worry at "
"allows about fixing code format. The bot will do the work for them."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:310
msgid ""
"It can make it easier for new comers as they never have to setup pre-"
"commit locally or worry about linting their code. They can even make "
"small fixes to the code directly on GitHub without worry."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:312
msgid "Setting up a git pre-commit hook"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:314
msgid "To setup pre-commit locally, you need to do 3 things:"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:316
msgid ""
"Install pre-commit (and include it as a development requirement in your "
"repository)"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:326
msgid ""
"Create a .pre-commit-config.yaml file in the root of your package "
"directory."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:328
msgid ""
"Below is an example **.pre-commit-cofig.yaml** file that can be used to "
"setup the pre-commit hook and the pre-commit.ci bot if you chose to "
"implement that too."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:336
msgid ""
"This file specifies a hook that will be triggered automatically before "
"each `git commit`, in this case, it specifies a `flake8` using version "
"`6.0.0`."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:339
msgid ""
"Install your pre-commit hook(s) using `pre-commit install`. This will "
"install all of the hooks specified in the pre-commit yaml file into your "
"environment."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:341
msgid ""
"Once you have done the above, you are ready to start working on your "
"code. Pre-commit will run every time you run `git commit`."
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:344
msgid "Summary"
msgstr ""

#: ../../package-structure-code/code-style-linting-format.md:346
msgid ""
"pyOpenSci suggests setting up a linter and a code styler for your "
"package, regardless of whether you use pre-commit hooks, CI or other "
"infrastructure to manage code format. Setting up these tools will give "
"you automatic feedback about your code's structure as you (or a "
"contributor) write it. And using a tool like black that format code for "
"you, reduce effort that you need to make surrounding decisions around "
"code format and style."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:1
msgid "Complex Python package builds"
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:3
msgid ""
"This guide is focused on packages that are either pure-python or that "
"have a few simple extensions in another language such as C or C++."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:6
msgid ""
"In the future, we want to provide resources for packaging workflows that "
"require more complex builds. If you have questions about these types of "
"package, please [add a question to our "
"discourse](https://pyopensci.discourse.group/) or open an [issue about "
"this guide specifically in the GitHub repo for this "
"guide](https://github.com/pyOpenSci/python-package-guide/issues). There "
"are many nuances to building and distributing Python packages that have "
"compiled extensions requiring non-Python dependencies at build time. For "
"an overview and thorough discussion of these nuances, please see [this "
"site.](https://pypackaging-native.github.io/)"
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:8
msgid "Pure Python Packages vs. packages with extensions in other languages"
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:10
msgid ""
"You can classify Python package complexity into three general categories."
" These categories can in turn help you select the correct package "
"frontend and backend tools."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:14
msgid ""
"**Pure-python packages:** these are packages that only rely on Python to "
"function. Building a pure Python package is simpler. As such, you can "
"chose a tool below that has the features that you want and be done with "
"your decision!"
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:16
msgid ""
"**Python packages with non-Python extensions:** These packages have "
"additional components called extensions written in other languages (such "
"as C or C++). If you have a package with non-Python extensions, then you "
"need to select a build backend tool that allows additional build steps "
"needed to compile your extension code. Further, if you wish to use a "
"frontend tool to support your workflow, you will need to select a tool "
"that supports additional build setups. We suggest that you chose build "
"tool that supports custom build steps like Hatch."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:18
msgid ""
"**Python packages that have extensions written in different languages "
"(e.g. Fortran and C++) or that have non Python dependencies that are "
"difficult to install (e.g. GDAL)** These packages often have complex "
"build steps (more complex than a package with just a few C extensions for"
" instance). As such, these packages require tools such as [scikit-"
"build](https://scikit-build.readthedocs.io/en/latest/) or [meson-"
"python](https://mesonbuild.com/Python-module.html) to build. NOTE: you "
"can use meson-python with PDM."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:21
msgid "Mixing frontend and backend projects"
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:23
msgid ""
"It is sometimes necessary or desirable to use a build frontend with an "
"alternative build-backend. This is because some frontends do not have a "
"default backend (`build`), and this choice is placed on the maintainer. "
"Other backends (`hatch`) have a preferred backend (`hatchling`) but allow"
" the maintainer to migrate to another, while some backends (`poetry`) "
"only work with a single backend (`poetry-core`). Refer to (#python-"
"package-build-tools) for more information about frontend and backend "
"compatibility."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:29
msgid ""
"In this packaging guide we recommend using `hatch` along with its "
"preferred backend `hatchling`. While this will be suitable for most "
"packages, an alternate backend may be used with Hatch if needed when "
"creating an extension module. A Python extension module is one that is "
"made up, either in part or entirely, of compiled code. In this case the "
"backend chosen (such as `meson-python`) must know how to compile the "
"extension language and bind it to Python. `hatchling` does not know how "
"to do this all on its own and must either make use of "
"[plugins](https://hatch.pypa.io/1.9/plugins/about/) or be replaced by a "
"backend that is already capable of building extension modules."
msgstr ""

#: ../../package-structure-code/complex-python-package-builds.md:37
msgid ""
"In order to use a different backend you will need to edit your project's "
"`pyproject.toml`. If you have a `pyproject.toml` generated by the `hatch`"
" command, or from following the packaging tutorial, you may have to make "
"a change like this"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:8
#: ../../package-structure-code/declare-dependencies.md:375
#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:25
msgid "Todo"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:10
msgid ""
"keep this comment - https://github.com/pyOpenSci/python-package-"
"guide/pull/106#issuecomment-1844278487 in this file for now - jeremiah "
"did a nice inventory of common shells and whether they need quotes or "
"not. it's really comprehensive. but do we want it in the guide?? it's "
"really useful for more advanced users i think."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:12
msgid ""
"Following this comment: https://github.com/pyOpenSci/python-package-"
"guide/pull/106#pullrequestreview-1766663571"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:15
msgid "Jonny will add a section that talks about:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:17
msgid ""
"Why you specify dependencies How to specify dependencies When you use "
"different specifiers"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:22
msgid "Python Package Dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:24
msgid "What is a package dependency?"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:26
msgid ""
"A Python package dependency refers to an external package or software "
"that your Python project:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:29
msgid "needs to function properly."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:30
msgid ""
"requires if someone wants to develop / work on improving your package "
"locally or"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:31
msgid ""
"requires if a user wants to add additional functionality (that is not "
"core) to your package"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:33
msgid ""
"A dependency is not part of your project's codebase. It is a package or "
"software that is called within the code of your project or during "
"development of your package."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:37
msgid "Understanding optional vs. required dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:38
msgid ""
"You can think about dependencies as being either optional or required. If"
" they are required, they will be listed in the `[dependency] =` table of "
"your `pyproject.toml` file. If they are optional, they will be listed in "
"the `[optional.dependencies]` table of your `pyproject.toml`."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:40
msgid "You will learn about both below."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:46
msgid ""
"There are two broad groups of Python package dependencies: those that are"
" optional and those that are required. Required packages are those that a"
" user needs to use your package. Optional dependencies are packages a "
"user can chose to install to add functionality to your package. Within "
"those 2 groups, there are three use cases that you can think about. 1. "
"Core dependencies are **required** for a user to use your package. 2. "
"Development dependencies are optional and only needed if someone wants to"
" work on your package locally. 3. Finally feature dependencies are "
"optional and add additional functionality to your package. Not all "
"packages will have feature dependencies."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:51
msgid "Required (or core) dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:53
msgid ""
"Required dependencies are called directly within your package's code. On "
"this page we refer to these dependencies as **core dependencies** as they"
" are needed in order to run your package. You should place your core or "
"required dependencies in the `[dependency]=` table of your "
"`pyproject.toml` file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:56
#: ../../package-structure-code/declare-dependencies.md:147
msgid "Optional dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:58
msgid ""
"Optional dependencies dependencies can be optionally installed by users "
"depending upon their needs. There are two broad groups of optional "
"dependencies:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:61
msgid ""
"**Development dependencies**: These are dependencies that are required to"
" support development of your package. They include tools to run tests "
"such as `pytest`, linters (like `flake8` and `ruff`) and code formatters "
"such as `black` and even automation tools such as `nox` or `tox` that run"
" tasks."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:63
msgid ""
"**Feature dependencies:** These are dependencies that a user can chose to"
" install to add functionality to your package."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:65
msgid ""
"When a Python project is installed, the Python package manager (either "
"`pip` or `conda`) installs your package's dependencies automatically. "
"This ensures that when you call a function in a specific dependency, it "
"is available in your user's environment."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:70
msgid "Dependencies can be added to your pyproject.toml file"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:72
msgid ""
"In the [pyproject.toml overview page](pyproject-toml-python-package-"
"metadata), you learned how to set up a **pyproject.toml** file with basic"
" metadata for your package. On this page, you will learn how to specify "
"different types of dependencies in your `pyproject.toml`."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:79
msgid "How do you declare dependencies?"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:81
msgid ""
"We recommend that you declare your dependencies using your "
"`pyproject.toml` file. This ensures that all of the metadata associated "
"with your package is declared in a single place, making it simpler for "
"users and contributors to understand your package infrastructure."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:86
msgid ""
"Previously, it was common to use a `requirements.txt` file to declare "
"package dependencies. However in recent years, the ecosystem has moved to"
" storing this information in your **pyproject.toml** file. You may notice"
" however that some projects still maintain a `requirements.txt` file for "
"specific local development needs."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:92
msgid "Other ways you may see packages storing dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:95
msgid ""
"If a project contains extensions written in other languages, you may need"
" a `setup.py` file. Or you may contribute to a package that us using "
"`setup.cfg` for dependency declaration. [Learn more about this in the "
"setuptools "
"documentation](https://setuptools.pypa.io/en/latest/userguide/dependency_management.html"
"#declaring-required-dependency)"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:100
msgid "Add required dependencies to your pyproject.toml file"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:102
msgid ""
"Your core project dependencies need to be installed by a package manager "
"such as `pip` or `conda` when a user installs your package. You can add "
"those dependencies to the `dependencies` array located within the "
"`[project]` table of your **pyproject.toml** file. This looks something "
"like this:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:121
msgid ""
"Ideally, you should only list the packages that are necessary to install "
"and use your package in the `[dependencies]` section. This minimizes the "
"number of additional packages that your users must install as well as the"
" number of packages that depend upon your package must also install."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:128
msgid ""
"Remember that fewer dependencies to install reduces the likelihood of "
"version mismatches in user environments."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:131
msgid "A dependency example"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:133
msgid ""
"Let's pretend you have a package called `plotMe` that creates beautiful "
"plots of data stored in `numpy` arrays. To create your plots in the "
"`plotMe` package, you use the `seaborn` package to stylize our plots and "
"also `numpy` to process array formatted data."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:135
msgid "In the example above, the plotMe package, depends upon two packages:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:137
msgid "seaborn"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:138
msgid "numpy"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:140
msgid ""
"This means that in order for plotMe to work in a user's `environment` "
"when installed, you also need to ensure that they have both of those "
"required `dependencies` installed in their environment too."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:142
msgid ""
"Declaring a dependency in your `pyproject.toml` file will ensure that it "
"is listed as a required dependency when your package is published to PyPI"
" and that a package manager (`pip` or `conda`) will automatically install"
" it into a user's environment alongside your package:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:144
msgid "`python -m pip install plotMe`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:149
msgid ""
"Optional dependencies for building your documentation, running your tests"
" and building your package's distribution files are often referred to as "
"development dependencies. These are the dependencies that a user needs to"
" work on your package locally and perform tasks such as:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:151
msgid "running your test suite"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:152
msgid "building your documentation"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:153
msgid "linting and other code cleanup tools"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:155
msgid ""
"These dependencies are considered optional, because they are not required"
" to install and use your package. Feature dependencies are considered "
"optional and should also be placed in the `[optional.dependencies]` "
"table."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:158
msgid ""
"Optional dependencies can be stored in an `[optional.dependencies]` table"
" in your **pyproject.toml** file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:161
msgid ""
"It's important to note that within the `[optional.dependencies]` table, "
"you can store additional, optional dependencies within named sub-groups. "
"This is a different table than the dependencies array located within the "
"`[project]` table discussed above which contains a single array with a "
"single list of required packages."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:163
msgid "Create optional dependency groups"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:165
msgid "To declare optional dependencies in your **pyproject.toml** file:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:167
msgid "Add a `[optional.dependencies]` table to your **pyproject.toml** file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:168
msgid "Create named groups of dependencies using the syntax:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:170
msgid "`group-name = [\"dep1\", \"dep2\"]`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:172
msgid "Installing packages from GitHub / Gitlab"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:175
msgid ""
"If you have dependencies that need to be installed directly from GitHub "
"using a `git+https` installation approach, you can do so using the "
"pyproject.toml file like so:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:185
msgid ""
"IMPORTANT: For security reasons, if your library depends on a GitHub-"
"hosted project, you will need to point to a specific commit/tag/hash of "
"that repository in order to upload your project to PyPI"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:190
msgid ""
"Below we've created three sets of optional development dependencies "
"named: tests, docs and lint. We've also added a set of feature "
"dependencies."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:213
msgid "Additional dependency resources"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:215
msgid ""
"[Learn more: View PyPA's overview of declaring optional "
"dependencies](https://packaging.python.org/en/latest/specifications"
"/declaring-project-metadata/#dependencies-optional-dependencies)"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:217
msgid ""
"[Dependency "
"specifiers](https://packaging.python.org/en/latest/specifications"
"/dependency-specifiers/)"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:221
msgid "Install dependency groups"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:226
msgid ""
"Diagram showing a ven diagram with three sections representing the "
"dependency groups listed above - docs feature and tests. In the center it"
" says your-package and lists the core dependencies of that package "
"seaborn and numpy. To the right are two arrows. The first shows the "
"command python - m pip install your-package. it them shows how installing"
" your package that way installs only the package and the two core "
"dependencies into a users environment. Below is a second arrow with "
"python -m pip install youPackage[tests]. This leads to an environment "
"with both the package dependencies - your-package, seaborn and numpy and "
"also the tests dependencies including pytest and pytest-cov"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:228
msgid ""
"When a user installs your package locally using python -m pip install "
"your-package only your package and it's core dependencies get installed. "
"When they install your package `[tests]` pip will install both your "
"package and its core dependencies plus any of the dependencies listed "
"within the tests array of your `[optional.dependencies]` table."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:231
msgid "Using `python -m pip install` vs. `pip install`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:233
msgid ""
"In all of the examples in this guide, you will notice we are calling "
"`pip` using the syntax:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:236
msgid "`python -m pip`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:238
msgid ""
"Calling pip using `python -m` ensures that the `pip` that you are using "
"to install your package comes from your current active Python "
"environment. We strongly suggest that you use this approach whenever you "
"call `pip` to avoid installation conflicts."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:242
msgid ""
"To ensure this works as you want it to, activate your package's "
"development environment prior to installing anything using `pip`."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:246
msgid ""
"You can install development dependencies using the groups that you "
"defined above using the syntax:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:249
msgid "`python -m pip install \".[docs]\"`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:251
msgid "Above you install:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:252
msgid "dependencies needed for your documentation (`docs`),"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:253
msgid "required package dependencies in the `dependency` array and"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:254
msgid "your package"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:256
msgid ""
"using pip. Below you install your package, required dependencies and "
"optional test dependencies."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:259
#: ../../package-structure-code/declare-dependencies.md:277
msgid "`python -m pip install \".[tests]\"`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:261
msgid ""
"You can install multiple dependency groups in the "
"`[optional.dependencies]` table using:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:263
msgid "`python -m pip install \".[docs, tests, lint]\"`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:266
msgid "For zsh shell users"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:270
msgid ""
"There are different shell applications that you and your package "
"contributors might use."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:271
msgid "zsh is the shell that comes by default on newer Mac OS computers"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:272
msgid "Windows users may use a tool such as git bash"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:274
msgid ""
"Some shells don't support unquoted brackets (`[tests]`) which is why we "
"add quotes to the command in this guide like this:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:279
msgid ""
"In some cases you may see commands without the quotes in guidebooks or "
"contributing guides like the example below:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:282
msgid "`python -m pip install your-package[tests]`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:284
msgid ""
"Calling your-package[tests] without the double quotes will work on some "
"shells *but not all*."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:287
msgid "Combining sets of dependencies"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:289
msgid ""
"Above we reviewed how to install dependencies from your `pyproject.toml`."
" In some cases you may want to group sets of dependencies like so:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:302
msgid ""
"The above allows you to install both the tests and docs dependency lists "
"using the command:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:305
msgid "`python -m pip install \".[dev]\"`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:308
msgid "When you install dependencies using the above syntax:"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:310
msgid "`python -m pip install \".[tests, docs]\"`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:312
msgid "`pip` will also install your package and its core dependencies."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:316
msgid "Where does conda fit in?"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:319
msgid ""
"The `pyproject.toml` file allows you to list any Python package published"
" on PyPI (or on GitHub/ GitLab) as a dependency. Once you create this "
"file, declare dependencies, [build your package](python-package-"
"distribution-files-sdist-wheel.md) and [publish your package to PyPI"
"](publish-python-package-pypi-conda.md), people can install both your "
"package and all of it's dependencies with one command."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:322
msgid "`python -m pip install your-package`"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:324
msgid "This works great if your package is pure-python (no other languages used)."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:326
msgid ""
"Some packages, particularly in the scientific Python ecosystem, require "
"dependencies that are not written in Python. Conda was created to support"
" distribution of tools that have code written in both Python and "
"languages other than Python."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:329
msgid "Support conda users with environment.yml files"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:331
msgid ""
"The above workflow assumes that you want to publish your package on PyPI."
" And then you plan to publish to conda-forge (optionally), [by submitting"
" a recipe using grayskull](https://www.pyopensci.org/python-package-guide"
"/package-structure-code/publish-python-package-pypi-conda.html)."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:333
msgid ""
"If you want to support conda users, you may want to also maintain a conda"
" environment that they can use to install your package. Maintaining a "
"conda environment will also help you test that your package installs as "
"you expect into a conda environment."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:336
msgid "A note for conda users"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:339
msgid ""
"If you use a conda environment for developing your tool, keep in mind "
"that when you install your package using `python -m pip install -e .` (or"
" using pip in general), dependencies will be installed from PyPI rather "
"than conda."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:341
msgid ""
"Thus, if you are running a conda environment, installing your package in "
"\"editable\" mode risks dependency conflicts. This is particularly "
"important if you have a spatial package that requires geospatial system "
"libraries like GDAL or another system-level dependency."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:343
msgid ""
"Alternatively, you can install your package using `python -m pip install "
"-e . --no-deps` to only install the package. And install the rest of your"
" dependencies using a conda environment file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:346
msgid "Dependencies in Read the Docs"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:348
msgid ""
"Now that you have your dependencies specified in your project, you can "
"use them to support other workflows such as publishing to Read the Docs."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:350
msgid ""
"[Read the Docs](https://readthedocs.org) is a documentation platform with"
" a continuous integration / continuous deployment service that "
"automatically builds and publishes your documentation."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:352
msgid ""
"If you are using Read the Docs to build your documentation, then you may "
"need to install your dependencies using a **readthedocs.yaml** file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:354
msgid ""
"Below is an example of installing the **docs** section of your dependency"
" table in the pyproject.toml file within a readthedocs.yaml file."
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:366
msgid "Read the Docs and Python packages"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:370
msgid ""
"[Learn more about creating a `readthedocs.yaml` file here. "
"](https://docs.readthedocs.io/en/stable/config-file/index.html)"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:371
msgid ""
"If you want to install dependencies using Poetry in Read the Docs, [you "
"can learn more here.](https://docs.readthedocs.io/en/stable/build-"
"customization.html#install-dependencies-with-poetry)"
msgstr ""

#: ../../package-structure-code/declare-dependencies.md:376
msgid "This is hidden. TO"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Intro"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Python package structure"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "pyproject.toml Package Metadata"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Build Your Package"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Declare dependencies"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Package Build Tools"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Complex Builds"
msgstr ""

#: ../../package-structure-code/intro.md:163
msgid "Package structure & code style"
msgstr ""

#: ../../package-structure-code/intro.md:177
msgid "Publish with Conda / PyPI"
msgstr ""

#: ../../package-structure-code/intro.md:177
msgid "Package versions"
msgstr ""

#: ../../package-structure-code/intro.md:177
msgid "Code style"
msgstr ""

#: ../../package-structure-code/intro.md:177
msgid "Publishing a package"
msgstr ""

#: ../../package-structure-code/intro.md:1
msgid "Python package structure information"
msgstr ""

#: ../../package-structure-code/intro.md:3
msgid ""
"This section provides guidance on your Python package's structure, code "
"formats and style. It also reviews the various packaging tools that you "
"can use to support building and publishing your package."
msgstr ""

#: ../../package-structure-code/intro.md:7
msgid ""
"If you are confused by Python packaging, you are not alone! The good news"
" is there are some great modern packaging tools that ensure that you're "
"following best practices. Here, we review tool features and suggest tools"
" that might be best fitted for your workflow."
msgstr ""

#: ../../package-structure-code/intro.md:19
msgid " 1. Package file structure "
msgstr ""

#: ../../package-structure-code/intro.md:23
msgid ""
"src layout, flat layout and where should tests folders live? No matter "
"what your level of packaging knowledge is, this page will help you decide"
" upon a package structure that follows modern python best practices."
msgstr ""

#: ../../package-structure-code/intro.md:28
msgid " 2. Learn about building your package "
msgstr ""

#: ../../package-structure-code/intro.md:32
msgid ""
"To publish your Python package on PyPI, you will need to first build it. "
"The act of \"building\" refers to the process of placing your package "
"code and metadata into a format that can be published on PyPI. Learn more"
" about building your Python package."
msgstr ""

#: ../../package-structure-code/intro.md:41
msgid " 4. Add metadata "
msgstr ""

#: ../../package-structure-code/intro.md:45
msgid ""
"Learn how to add project metadata to your Python package to support both "
"filtering on PyPI and also the metadata that a package installer needs to"
" build and install your package."
msgstr ""

#: ../../package-structure-code/intro.md:52
msgid " 3. What Python package tool should you use? "
msgstr ""

#: ../../package-structure-code/intro.md:56
msgid ""
"Learn more about the suite of packaging tools out there. And learn which "
"tool might be best for you."
msgstr ""

#: ../../package-structure-code/intro.md:62
msgid " 4. Publish to PyPI and Conda "
msgstr ""

#: ../../package-structure-code/intro.md:66
msgid ""
"If you have a pure Python package, it's a straight forward process to "
"publish to both PyPI and then a Conda channel such as conda-forge. Learn "
"more here."
msgstr ""

#: ../../package-structure-code/intro.md:73
msgid " 5. Setup package versioning "
msgstr ""

#: ../../package-structure-code/intro.md:77
msgid ""
"Semver (numeric versioning) and Calver (versioning using the date) are 2 "
"common ways to version a package. Which one should you pick? Learn more "
"here."
msgstr ""

#: ../../package-structure-code/intro.md:83
msgid " 6. Code style & linters "
msgstr ""

#: ../../package-structure-code/intro.md:87
msgid ""
"Black, blue, flake8, Ruff - which tools can help you ensure your package "
"follows best practices for code format? Learn more about the options and "
"why this is important here."
msgstr ""

#: ../../package-structure-code/intro.md:95
msgid ""
"Figure showing a decision tree with the various packaging tool front-end "
"and back-end options."
msgstr ""

#: ../../package-structure-code/intro.md:97
msgid ""
"Diagram showing the various front-end build tools that you can select "
"from. See the packaging tools page to learn more about each tool."
msgstr ""

#: ../../package-structure-code/intro.md:102
msgid ""
"If you are considering submitting a package for peer review, have a look "
"at the bare-minimum [editor checks](https://www.pyopensci.org/software-"
"peer-review/how-to/editor-in-chief-guide.html#editor-checklist-template) "
"that pyOpenSci performs before a review begins. These checks are useful "
"to explore for both authors planning to submit a package to us for review"
" and for anyone who is just getting started with creating a Python "
"package."
msgstr ""

#: ../../package-structure-code/intro.md:109
msgid "What you will learn here"
msgstr ""

#: ../../package-structure-code/intro.md:111
msgid "In this section of our Python packaging guide, we:"
msgstr ""

#: ../../package-structure-code/intro.md:113
msgid ""
"Provide an overview of the options available to you when packaging your "
"tool."
msgstr ""

#: ../../package-structure-code/intro.md:115
msgid ""
"Suggest tools and approaches that both meet your needs and also support "
"existing standards."
msgstr ""

#: ../../package-structure-code/intro.md:117
msgid ""
"Suggest tools and approaches that will allow you to expand upon a "
"workflow that may begin as a pure Python tool and evolve into a tool that"
" requires addition layers of complexity in the packaging build."
msgstr ""

#: ../../package-structure-code/intro.md:120
msgid ""
"Align our suggestions with the most current, accepted [PEPs (Python "
"Enhancement Protocols)](https://peps.python.org/pep-0000/) and the "
"[Scientific Python community SPECs](https://scientific-"
"python.org/specs/)."
msgstr ""

#: ../../package-structure-code/intro.md:123
msgid ""
"In an effort to maintain consistency within our community, we also align "
"with existing best practices being implemented by developers of core "
"Scientific Python packages such as Numpy, SciPy and others."
msgstr ""

#: ../../package-structure-code/intro.md:127
msgid "Guidelines for pyOpenSci's packaging recommendations"
msgstr ""

#: ../../package-structure-code/intro.md:129
msgid ""
"The flexibility of the Python programming language lends itself to a "
"diverse range of tool options for creating a Python package. Python is so"
" flexible that it is one of the few languages that can be used to wrap "
"around other languages. The ability of Python to wrap other languages is "
"one the reasons you will often hear Python described as a [\"glue\" "
"language](https://numpy.org/doc/stable/user/c-info.python-as-glue.html)\""
msgstr ""

#: ../../package-structure-code/intro.md:135
msgid ""
"If you are building a pure Python package, then your packaging setup can "
"be simple. However, some scientific packages have complex requirements as"
" they may need to support extensions or tools written in other languages "
"such as C or C++."
msgstr ""

#: ../../package-structure-code/intro.md:139
msgid ""
"To support the many different uses of Python, there are many ways to "
"create a Python package. In this guide, we suggest packaging approaches "
"and tools based on:"
msgstr ""

#: ../../package-structure-code/intro.md:142
msgid ""
"What we think will be best and easiest to adopt for those who are newer "
"to packaging."
msgstr ""

#: ../../package-structure-code/intro.md:144
msgid "Tools that we think are well maintained and documented."
msgstr ""

#: ../../package-structure-code/intro.md:145
msgid ""
"A shared goal of standardizing packaging approaches across this "
"(scientific) Python ecosystem."
msgstr ""

#: ../../package-structure-code/intro.md:148
msgid ""
"Here, we also try to align our suggestions with the most current, "
"accepted [Python community](https://packaging.python.org/en/latest/) and "
"[scientific community](https://scientific-python.org/specs/)."
msgstr ""

#: ../../package-structure-code/intro.md:151
msgid "Suggestions in this guide are not pyOpenSci review requirements"
msgstr ""

#: ../../package-structure-code/intro.md:154
msgid ""
"The suggestions for package layout in this section are made with the "
"intent of being helpful; they are not specific requirements for your "
"package to be reviewed and accepted into our pyOpenSci open source "
"ecosystem."
msgstr ""

#: ../../package-structure-code/intro.md:158
msgid ""
"Please check out our [package scope page](https://www.pyopensci.org"
"/software-peer-review/about/package-scope.html) and [review requirements "
"in our author guide](https://www.pyopensci.org/software-peer-review/how-"
"to/author-guide.html#) if you are looking for pyOpenSci's Python package "
"review requirements!"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:1
msgid "Publishing Your Package In A Community Repository: PyPI or Anaconda.org"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:5
msgid ""
"pyOpenSci requires that your package has an distribution that can be "
"installed from a public community repository such as PyPI or a conda "
"channel such as `bioconda` or `conda-forge` on Anaconda.org."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:9
msgid ""
"Below you will learn more about the various publishing options for your "
"Python package."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:14
msgid ""
"Installing packages in the same environment using both pip and conda can "
"lead to package conflicts."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:16
msgid ""
"To minimize conflicts for users who may be using conda (or pip) to manage"
" local environments, consider publishing your package to both PyPI and "
"the conda-forge channel on Anaconda.org."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:18
msgid ""
"Below you will learn more specifics about the differences between PyPI "
"and conda publishing of your Python package."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:24
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:6
msgid ""
"Image showing the progression of creating a Python package, building it "
"and then publishing to PyPI and conda-forge. You take your code and turn "
"it into distribution files (sdist and wheel) that PyPI accepts. then "
"there is an arrow towards the PyPI repository where ou publish both "
"distributions. From PyPI if you create a conda-forge recipe you can then "
"publish to conda-forge."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:26
msgid ""
"Once you have published both package distributions (the source "
"distribution and the wheel) to PyPI, you can then publish to conda-forge."
" conda-forge requires a source distribution on PyPI in order to build "
"your package on conda-forge. You do not need to rebuild your package to "
"publish to conda-forge."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:29
msgid "What is PyPI"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:31
msgid ""
"[PyPI](https://pypi.org/) is an online Python package repository that you"
" can use to both find and install and publish your Python package. There "
"is also a test PyPI repository where you can test publishing your package"
" prior to the final publication on PyPI."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:36
msgid ""
"Many if not most Python packages can be found on PyPI and are thus "
"installable using `pip`."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:38
msgid ""
"The biggest different between using pip and conda to install a package is"
" that conda can install any package regardless of the language(s) that it"
" is written in. Whereas `pip` can only install Python packages."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:43
msgid "Click here for a tutorial on publishing your package to PyPI."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:52
msgid ""
"On the package build page, we discussed the [two package distribution "
"types that you will create when making a Python package](python-package-"
"distribution-files-sdist-wheel): SDist (packaged as a .tar.gz or .zip) "
"and Wheel (.whl) which is really a zip file. Both of those file "
"\"bundles\" will be published on PyPI when you use [a standard build tool"
"](python-package-build-tools) to build your package."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:60
msgid "What is conda and Anaconda.org?"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:62
msgid ""
"conda is an open source package and environment management tool. conda "
"can be used to install tools from the [Anaconda "
"repository](https://repo.anaconda.com/)."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:66
msgid ""
"Anaconda.org contains public and private repositories for packages. These"
" repositories are known as channels (discussed below)."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:69
msgid "A brief history of conda's evolution"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:72
msgid ""
"The conda ecosystem evolved years ago to provide support for, and "
"simplify the process of, managing software dependencies in scientific "
"Python projects."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:76
msgid ""
"Many of the core scientific Python projects depend upon or wrap around "
"tools and extensions that are written in other languages, such as C++. In"
" the early stages of the scientific ecosystem's development, these non-"
"Python extensions and tools were not well supported on PyPI, making "
"publication difficult. In recent years there is more support for complex "
"builds that allow developers to bundle non-Python code into a Python "
"distribution using the [wheel distribution format](python-wheel)."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:78
msgid ""
"Conda provides a mechanism to manage these dependencies and ensure that "
"the required packages are installed correctly."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:82
msgid ""
"While conda was originally created to support Python packages, it is now "
"used across all languages. This cross-language support makes it easier "
"for some packages to include and have access to tools written in other "
"languages, such as C/C++ (gdal), Julia, or R. Creating an environment "
"that mixes all of these packages is usually easier and more consistent "
"with full-fledged package managers like conda."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:90
msgid "conda channels"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:92
msgid ""
"conda built packages are housed within repositories that are called "
"channels. The conda package manager can install packages from different "
"channels."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:95
msgid ""
"There are several core public channels that most people use to install "
"packages using conda, including:"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:98
msgid ""
"**defaults:** this is a channel managed by Anaconda. It is the version of"
" the Python packages that you will install if you install the Anaconda "
"Distribution. Anaconda (the company) decides what packages live on the "
"`defaults` channel."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:99
msgid ""
"[**conda-forge:**](https://anaconda.org/conda-forge) this is a community-"
"driven channel that focuses on scientific packages. This channel is ideal"
" for tools that support geospatial data. Anyone can publish a package to "
"this channel."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:100
msgid ""
"[**bioconda**](https://anaconda.org/bioconda): this channel focuses on "
"biomedical tools."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:102
msgid ""
"**conda-forge** emerged as many of the scientific packages did not exist "
"in the `defaults` Anaconda channel."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:107
msgid ""
"Graphic with the title Python package repositories. Below it says "
"Anything hosted on PyPI can be installed using pip install. Packaging "
"hosted on a conda channel can be installed using conda install. Below "
"that there are two rows. the top row says conda channels. next to it are "
"three boxes one with conda-forge, community maintained; bioconda and then"
" default - managed by the anaconda team. Below that there is a row that "
"says PyPI servers. PyPI - anyone can publish to PyPI. and test PyPI. a "
"testbed server for you to practice."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:109
msgid ""
"Conda channels represent various repositories that you can install "
"packages from. Because conda-forge is community maintained, anyone can "
"submit a recipe there. PyPI is also a community maintained repository. "
"Anyone can submit a package to PyPI and test PyPI. Unlike conda-forge "
"there are no manual checks of packages submitted to PyPI."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:113
msgid "conda channels, PyPI, conda, pip - Where to publish your package"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:115
msgid ""
"You might be wondering why there are different package repositories that "
"can be used to install Python packages."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:118
msgid ""
"And more importantly you are likely wondering how to pick the right "
"repository to publish your Python package."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:121
msgid "The answer to both questions relates dependency conflicts."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:125
msgid ""
"Image showing an XKCD comic that shows a web of Python environments and "
"tools and installations. At the bottom is says -  My python environment "
"has become so degraded that my laptop has been declared a superfund site."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:127
msgid ""
"Installing Python and Python packages from different repositories can "
"lead to environment conflicts where a version of on package doesn't work "
"with a version of another package. To keep your environments clean and "
"working, it's best to install packages from the same repository. So use "
"pip to install everything. Or use conda. If you can, try to avoid "
"installing package from both pip and conda into the same environment."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:135
msgid "Managing Python package dependency conflicts"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:137
msgid ""
"Python environments can encounter conflicts because Python tools can be "
"installed from different repositories. Broadly speaking, Python "
"environments have a smaller chance of dependency conflicts when the tools"
" are installed from the same package repository. Thus environments that "
"contain packages installed from both pip and conda are more likely to "
"yield dependency conflicts."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:144
msgid ""
"Similarly installing packages from the default anaconda package mixed "
"with the conda-forge channel can also lead to dependency conflicts."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:146
msgid ""
"Many install packages directly from conda `defaults` channel. However, "
"because this channel is managed by Anaconda, the packages available on it"
" are limited to those that Anaconda decides should be core to a stable "
"installation. The conda-forge channel was created to complement the "
"`defaults` channel. It allows anyone to submit a package to be published "
"in the channel . Thus, `conda-forge` channel ensures that a broad suite "
"of user-developed community packages can be installed from conda."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:150
msgid ""
"Take-aways: If you can, publish on both PyPI and conda-forge to "
"accommodate more users of your package"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:152
msgid ""
"The take-away here for maintainers is that if you anticipate users "
"wanting to use conda to manage their local environments (which many do), "
"you should consider publishing to both PyPI and the conda-forge channel "
"(_more on that below_)."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:157
msgid "Additional resources"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:158
msgid ""
"[learn more about why conda-forge was created, here](https://conda-"
"forge.org/docs/user/introduction.html)"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:160
msgid ""
"[To learn more about conda terminology, check out their "
"glossary.](https://docs.conda.io/projects/conda/en/latest/glossary.html )"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:165
msgid "How to submit to conda-forge"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:167
msgid ""
"While pyOpenSci doesn't require you to add your package to conda-forge, "
"we encourage you to consider doing so!"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:170
msgid ""
"Once your package is on PyPI, the process to add your package to conda-"
"forge is straight forward to do. [You can follow the detailed steps "
"provided by the conda-forge maintainer team.](https://conda-"
"forge.org/docs/maintainer/adding_pkgs.html)."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:175
msgid "Click here for a tutorial on adding your package to conda-forge."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:182
msgid "If you want a step by step tutorial, click here."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:185
msgid ""
"Once your package is added, you will have a feedstock repository on "
"GitHub with your packages name"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:188
msgid ""
"[Here is an example conda-forge feedstock for the pyOpenSci approved "
"package - movingpandas](https://github.com/conda-forge/movingpandas-"
"feedstock)"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:191
msgid "Maintaining your conda-forge package repository"
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:193
msgid ""
"Once your package is on the conda-forge channel, maintaining it is "
"simple. Every time that you push a new version of your package to PyPI, "
"it will kick off a continuous integration build that updates your package"
" in the conda-forge repository. Once that build is complete, you will get"
" a notification to review the update."
msgstr ""

#: ../../package-structure-code/publish-python-package-pypi-conda.md:199
msgid ""
"You can merge the pull request for that update once you are happy with "
"it. A ready-to-merge PR usually means ensuring that your project's "
"dependencies (known as runtime requirements) listed in the updated YAML "
"file found in the pull request match the PyPI metadata of the new "
"release."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:1
msgid "Use a pyproject.toml file for your package configuration & metadata"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:12
msgid "Important pyproject.toml take aways"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:16
msgid ""
"There are only two tables that are required for an installable Python "
"package: **[build-system]** and **[project]**. The **[project]** table "
"stores your package's metadata."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:17
msgid ""
"There are only two _required_ fields in the **[project]** table: "
"**name=** and **version=**."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:18
msgid ""
"We suggest you add additional metadata to your `pyproject.toml` file as "
"it will make it easier for users to find your project on PyPI."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:19
msgid ""
"When you are adding classifiers to the [project] table, only use valid "
"values from [PyPIs classifier page](https://PyPI.org/classifiers/). An "
"invalid value here will raise an error when you build your package or "
"publish to PyPI."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:20
msgid ""
"There is no specific order for tables in the `pyproject.toml` file. "
"However fields need to be placed within the correct table sections. For "
"example `requires =` always need to be associated with the **[build-"
"system]** table."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:21
msgid ""
"**python-requires**: is important to have in your `pyproject.toml` file "
"as it helps pip install your package."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:27
msgid "when these are published, remove this todo"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:36
msgid ""
"Need help creating your pyproject.toml file?  This tutorial will walk you"
" through the process."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:50
msgid ""
"Click here if need help migrating from setup.py/setup.cfg to "
"pyproject.toml"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:60
msgid "About the pyproject.toml file"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:62
msgid ""
"Every modern Python package should include a `pyproject.toml` file. If "
"your project is pure Python and you're using a `setup.py` or `setup.cfg` "
"file to describe its metadata, you should consider migrating your "
"metadata and build information to a `pyproject.toml` file."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:64
msgid ""
"If your project isnt pure-python, you might still require a `setup.py` "
"file to build the non Python extensions. However, a `pyproject.toml` file"
" should still be used to store your projects metadata."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:66
msgid "What happened to setup.py & how do i migrate to pyproject.toml?"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:68
msgid ""
"Prior to August 2017, Python package metadata was stored either in the "
"`setup.py` file or a `setup.cfg` file. In recent years, there has been a "
"shift to storing Python package metadata in a much more user-readable "
"`pyproject.toml` format. Having all metadata in a single file:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:70
msgid "simplifies package management,"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:71
msgid ""
"allows you to use a suite of different [build "
"backends](https://www.pyopensci.org/python-package-guide/package-"
"structure-code/python-package-build-tools.html#build-back-ends) such as "
"(flit-core, hatchling, pdm-build), and"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:72
msgid "aligns with modern best practices."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:79
msgid ""
"The standard file that Python packages use to [specify build requirements"
" and metadata is called a "
"**pyproject.toml**](https://packaging.python.org/en/latest/specifications"
"/declaring-project-metadata/). Adding metadata, build requirements and "
"package dependencies to a **pyproject.toml** file replaces storing that "
"information in a setup.py or setup.cfg file."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:84
msgid "About the .toml format"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:86
msgid ""
"The **pyproject.toml** file is written in [TOML (Tom's Obvious, Minimal "
"Language) format](https://toml.io/en/). TOML is an easy-to-read structure"
" that is founded on key/value pairs. Each section in the "
"**pyproject.toml** file contains a `[table identifier]`. Below that table"
" identifier are key/value pairs that support configuration for that "
"particular table."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:90
msgid "Below `[build-system]` is considered a table in the toml language."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:91
msgid "Within the `build-system` table below `requires =` is a key."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:92
msgid ""
"The associated value for `requires` is an array containing the value "
"`\"hatchling\"`."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:100
msgid "How the pyproject.toml is used when you build a package"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:104
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:81
msgid ""
"When you publish to PyPI, you will notice that each package has metadata "
"listed. Lets have a look at [xclim](https://pypi.org/project/xclim/), "
"one of our [pyOpenSci packages](https://www.pyopensci.org/python-"
"packages.html). Notice that on the PyPI landing page you see some "
"metadata about the package including python, maintainer information and "
"more. PyPI is able to populate this metadata because it was defined using"
" correct syntax and classifiers by Xclim's maintainers, [pyproject.toml "
"file](https://github.com/Ouranosinc/xclim/blob/master/pyproject.toml). "
"This metadata when the xclim package is built, is translated into a "
"distribution file that allows PyPI to read the metadata and print it out "
"on their website."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:106
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:83
msgid ""
"Image showing the left side bar of PyPI for the package xclim. The "
"section at the top says Classifier. Below there is a list of items "
"including Development status, intended audience, License, natural "
"language, operating system, programming language and topic. Below each of"
" those sections are various classifier options.\" width=\"300px\">"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:111
#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:88
msgid ""
"When you add the classifier section to your pyproject.toml and your "
"package is built, the build tool organizes the metadata into a format "
"that PyPI can understand and represent on your PyPI landing page. These "
"classifiers also allow users to sort through packages by version of "
"python they support, categories and more."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:116
msgid "Benefits of using a pyproject.toml file"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:118
msgid ""
"Including your package's metadata in a separate human-readable "
"**pyproject.toml** format also allows someone to view the project's "
"metadata in a GitHub repository."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:126
msgid "Setup.py is still useful for complex package builds"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:130
msgid ""
"Using **setup.py** to manage package builds and metadata [can cause "
"problems with package "
"development](https://blog.ganssle.io/articles/2021/10/setup-py-"
"deprecated.html). In some cases where a Python package build is complex, "
"a **setup.py** file may be required. While this guide will not cover "
"complex builds, we will provide resources working with complex builds in "
"the future."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:136
msgid "Optional vs. Required pyproject.toml file fields"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:138
msgid ""
"When you create your `pyproject.toml` file, there are numerous metadata "
"fields that you can use. Below we suggest specific fields to get you "
"started that support publication on PyPI and users finding your package."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:140
msgid ""
"[An overview of all of the project metadata elements can be found "
"here.](https://packaging.python.org/en/latest/specifications/core-"
"metadata/#project-url-multiple-use)"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:142
msgid "Required fields for the [project] table"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:144
msgid ""
"As mentioned above, your pyproject.toml file needs to have a **name** and"
" **version** field in order to properly build your package:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:146
msgid "Name: This is the name of your project provided as a string"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:147
msgid ""
"Version: This is the version of your project. If you are using a scm tool"
" for versioning (using git tags to determine versions), then the version "
"may be dynamic (more on that below)."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:149
msgid "Optional fields to include in the `[project]` table"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:151
msgid ""
"We strongly suggest that you also add the metadata keys below as they "
"will help users finding your package on PyPI. These fields will make it "
"clear how your package is structured, what platforms you support and what"
" dependencies your package requires."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:156
msgid "**Description:** this is a short one-line description of your package."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:157
msgid ""
"**Readme:** A link to your README.md file is used for the long long-"
"description. This information will be published on your packages PyPI "
"landing page."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:158
msgid ""
"**Requires-python** (used by pip): this is a field that is used by pip. "
"Here you tell the installer whether you are using Python 2.x or 3.x. Most"
" projects will be using 3.x."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:159
msgid "**License:** the license you are using"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:160
msgid ""
"**Authors:** these are the original authors of the package. Sometimes the"
" authors are different from the maintainers. Other times they might be "
"the same."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:161
msgid ""
"**Maintainers:** you can choose to populate this or not. You can populate"
" this using a list with a sub element for each author or maintainer name,"
" email"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:169
msgid ""
"**dependencies:** dependencies are optional but we strongly suggest you "
"include them in your pyproject.toml. Dependencies will be installed by "
"pip when your project is installed creating a better user-experience."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:171
msgid ""
"**`[project.optional-dependencies]`:** the optional or development "
"dependencies will be installed if someone runs `python -m pip install "
"projectname[dev]`. This is a nice way to include your development "
"dependencies for users who may wish to contribute to your project."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:173
msgid ""
"**keywords:** These are the keywords that will appear on your PyPI "
"landing page. Think of them as words that people might use to search for "
"your package."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:174
msgid ""
"**classifiers:** The classifiers section of your metadata is also "
"important for the landing page of your package in PyPI and for filtering "
"of packages in PyPI. A list of [all options for classifiers can be found "
"her](https://PyPI.org/classifiers/)e. Some of the classifiers that you "
"should consider including"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:175
msgid "Development Status"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:176
msgid "Intended Audience"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:177
msgid "Topic"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:178
msgid "LIcense"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:179
msgid "Programming language"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:181
msgid "Advanced options in the pyproject.toml file"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:183
msgid "The examples at the bottom of this page contain ..."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:185
msgid ""
"**`[project.scripts]` (Entry points):** Entry points are optional. If you"
" have a command line tool that runs a specific script hosted in your "
"package, you may include an entry point to call that script directly at "
"the command line (rather than at the Python shell)."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:186
msgid ""
"Here is an example of[ a package that has entry point "
"script](https://github.com/pyOpenSci/update-web-"
"metadata/blob/main/pyproject.toml#L60)s. Notice that there are several "
"core scripts defined in that package that perform sets of tasks. "
"pyOpenSci is using those scripts to process their metadata."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:187
msgid ""
"**Dynamic Fields:** if you have fields that are dynamically populated. "
"One example of this is if you are using scm / version control based "
"version with tools like `setuptooms_scm`, then you might use the dynamic "
"field. such as version (using scm) **dynamic = [\"version\"]**"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:189
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Add dependencies to your pyproject.toml file"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:191
msgid ""
"The pyproject.toml file can also be used as a replacement for the "
"requirements.txt file which has been traditionally used to store "
"development dependencies such as pytest, code formatters such as Black "
"and documentation tools such as sphinx."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:193
msgid ""
"To add dependencies to your build, add a `[project.optional-"
"dependencies]` table to your pyproject.toml file."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:195
msgid "Then specify dependency groups as follows:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:202
msgid "Following the above example, you install dependencies like this:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:204
msgid "`python -m pip install -e .[tests]`"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:206
msgid ""
"The above will install both your package in editable mode and all of the "
"dependencies declared in the tests section of your `[project.optional-"
"dependencies]` table."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:208
msgid "To install all dependencies and also your package, you'd use:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:210
msgid "`python -m pip install -e .[tests,lint,docs]`"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:212
msgid "Recursive dependencies"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:216
msgid ""
"You can also setup sets of recursive dependencies. [See this blog post "
"for more.](https://hynek.me/articles/python-recursive-optional-"
"dependencies/)"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:219
msgid "Example pyproject.toml for building using hatchling"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:221
msgid ""
"Below is an example build configuration for a Python project. This "
"example package setup uses **hatchling** to build the [package's sdist "
"and wheels](python-package-distribution-files-sdist-wheel)."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:229
msgid "Notice that dependencies are specified in this file."
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:231
msgid "Example pyproject.toml for building using setuptools"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:233
msgid ""
"The package metadata including authors, keywords, etc is also easy to "
"read. Below you can see the same TOML file that uses a different build "
"system (setuptools). Notice how simple it is to swap out the tools needed"
" to build this package!"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:237
msgid "In this example package setup you use:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:239
msgid ""
"**setuptools** to build the [package's sdist and wheels](python-package-"
"distribution-files-sdist-wheel)"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:240
msgid ""
"**setuptools_scm** to manage package version updates using version "
"control tags"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:242
msgid ""
"In the example below `[build-system]` is the first table of values. It "
"has two keys that specify the build backend API and containing package:"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:245
msgid "`requires =`"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:246
msgid "`build-back-end =`"
msgstr ""

#: ../../package-structure-code/pyproject-toml-python-package-metadata.md:253
msgid ""
"[Click here to read about our packaging build tools including PDM, "
"setuptools, Poetry and Hatch.](/package-structure-code/python-package-"
"build-tools)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:1
msgid "Python Packaging Tools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:3
msgid "Tools for building your package"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:5
msgid ""
"There are a several different build tools that you can use to [create "
"your Python package's _sdist_ and _wheel_ distributions](python-package-"
"distribution-files-sdist-wheel). Below, we discuss the features, benefits"
" and limitations of the most commonly used Python packaging tools. We "
"focus on pure-python packages in this guide. However, we also highlight "
"tools that currently support packages with C/C++ and other language "
"extensions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:13
msgid ""
"Decision tree diagram showing the various front and back end packaging "
"tools. You can decide what packaging tool to use by thinking about what "
"features you need. PDM and Hatch are  currently the most flexible tools "
"as they also using different build back-ends. As such currently PDM and "
"Hatch are the tools we think beginners might appreciate most with Poetry "
"being a close second. Poetry is nice for pure Python projects."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:15
msgid ""
"Diagram showing the different front end build tools available to use in "
"the Python package ecosystem that you can select from. We selected tools "
"to include in this diagram based upon the PyPI survey which helped us "
"understand the most populate tools in the ecosystem. Each tool has "
"different features as highlighted below."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:18
msgid ""
"If you want to know more about Python packages that have extensions "
"written in other languages, [check out the page on complex package builds"
".](complex-python-package-builds)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:21
msgid "Tools that we review here"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:23
msgid ""
"In this section we have selected tools that were returned as the most "
"popular packaging tools in the PyPA survey. You will learn more about the"
" following tools on this page:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:27
msgid ""
"[Twine](https://twine.readthedocs.io/en/stable/), [Build](https://pypa-"
"build.readthedocs.io/en/stable/) + "
"[setuptools](https://setuptools.pypa.io/en/latest/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:28
msgid "[Flit](https://flit.pypa.io/en/stable/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:29
msgid "[Hatch](https://hatch.pypa.io/latest/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:30
msgid "[PDM](https://pdm.fming.dev/latest/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:31
msgid "[Poetry](https://python-poetry.org/docs/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:33
msgid "Summary of tools Hatch vs. PDM vs. Poetry (and setuptools)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:35
msgid "If you are looking for a quick summary, read below."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:37
msgid ""
"In general, any modern tool that you select from this page will be great "
"to build your package. Selecting a tool comes down to the features that "
"you are looking for in your workflow."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:38
msgid ""
"We suggest that beginners start with a modern workflow tool like PDM as "
"opposed to navigating the complexities of setuptools."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:39
msgid ""
"If you are going to use Poetry (it is the most popular tool and does have"
" the best documentation) beware of the upper bounds dependency additions "
"and consider overriding dependencies when you add them. If you do that "
"Poetry will work well for pure-python builds! Poetry also has an active "
"discord where you can ask questions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:41
msgid "Below are some features that Hatch and PDM offer that Poetry does not."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:43
msgid "PDM:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:45
msgid ""
"Supports other back-ends making it ideal for builds that are not pure "
"Python. This means PDM is a great option for both pure python and more "
"complex Python builds as it supports meson-python and other build "
"backends."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:46
msgid "Offers flexibility in dependency management which we like"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:47
msgid "Offers lock files if you need them"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:49
msgid "Hatch:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:51
msgid ""
"Offers matrix environment management that allows you to run tests across "
"Python versions. If this feature is important to you, then Hatch is a "
"clear winner."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:52
msgid ""
"Offers a Nox / Make file like tool to streamline your build workflow. If "
"you are looking to reduce the number of tools in your workflow, Hatch "
"might be for you."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:55
msgid "Build front-end vs. build back-end tools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:57
msgid ""
"To better understand your options, when it comes to building a Python "
"package, it's important to first understand the difference between a "
"build tool front-end and build back-end."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:62
msgid "Build back-ends"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:64
msgid ""
"Most packaging tools have a back-end build tool that builds you package "
"and creates associated [(sdist and wheel) distribution files](python-"
"package-distribution-files-sdist-wheel). Some tools, such as **Flit**, "
"only support pure-Python package builds. A pure-Python build refers to a "
"package build that does not have extensions that are written in another "
"programming language (such as `C` or `C++`)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:71
msgid ""
"Other packages that have C and C++ extensions (or that wrap other "
"languages such as fortran) require additional code compilation steps when"
" built. Back-ends such as **setuptools.build**, **meson.build** and "
"**scikit-build** support complex builds with custom steps. If your build "
"is particularly complex (i.e. you have more than a few `C`/`C++` "
"extensions), then we suggest you use **meson.build** or **scikit-build**."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:77
msgid "Python package build front-ends"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:79
msgid ""
"A packaging front-end tool refers to a tool that makes it easier for you "
"to perform common packaging tasks using similar commands. These tasks "
"include:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:82
msgid ""
"[Build your packages (create the sdist and wheel distributions)](python-"
"package-distribution-files-sdist-wheel)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:83
msgid ""
"Installing your package in a development mode (so it updates when you "
"update your code)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:84
msgid "Publishing to PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:85
msgid "Running tests"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:86
msgid "Building documentation"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:87
msgid ""
"Managing an environment or multiple environments in which you need to run"
" tests and develop your package"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:89
msgid ""
"There are several Python packaging tools that you can use for pure Python"
" builds. Each front-end tool discussed below supports a slightly "
"different set of Python packaging tasks."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:93
msgid ""
"For instance, you can use the packaging tools **Flit**, **Hatch** or "
"**PDM** to both build and publish your package to PyPI. However while "
"**Hatch** and **PDM** support versioning and environment management, "
"**Flit** does not. If you want a tool that supports dependency locking, "
"you can use **PDM** or **Poetry** but not **Hatch**. If you only need to "
"build your package's sdist and wheel distribution files, then you can "
"stick with PyPA's Build. You'd then use Twine to publish to PyPI."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:100
msgid ""
"If you are using **Setuptools**, there is no default user-friendly build "
"front-end that performs multiple tasks. You will need to use **build** to"
" build your package and **twine** to publish to PyPI."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:103
msgid "Example build steps that can be simplified using a front-end tool"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:105
msgid ""
"Below, you can see how a build tool streamlines your packaging "
"experience. Example to build your package with **Hatch**:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:115
msgid "Example build steps using the **setuptools** back-end and **build**:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:125
msgid "Choosing a build back-end"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:127
msgid ""
"Most front-end packaging tools have their own back-end build tool. The "
"build tool creates your package's (sdist and wheel) distribution files. "
"For pure Python packages, the main difference between the different build"
" back-ends discussed below is:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:132
msgid ""
"How configurable they are - for example, do they allow you to add build "
"steps that support non python extensions?"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:133
msgid ""
"How much you need to configure them to ensure the correct files are "
"included in your sdist and wheel distributions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:135
msgid "Build back-end support for non pure-python packages"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:137
msgid ""
"It is important to note that some build back-ends, such as **Flit-core**,"
" only support pure Python builds. Other back-ends support C and C++ "
"extensions as follows:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:140
msgid "setuptools supports builds using C / C++ extensions"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:141
msgid ""
"Hatchling (hatch's back-end) supports C / C++ extensions via plugins that"
" the developer creates to customize a build"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:142
msgid "PDM's back-end supports C / C++ extensions by using setuptools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:143
msgid ""
"Poetry's back-end supports C/C++ extensions however this functionality is"
" currently undocumented. As such we don't recommend using Poetry for "
"complex or non pure Python builds until it is documented."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:145
msgid ""
"While we won't discuss more complex builds below, we will identify which "
"tools have documented support for C / C++ extensions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:148
msgid "An ecosystem of Python build tools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:150
msgid ""
"Below we introduce several of the most commonly used Python packaging "
"build front-end tools. We highlight the features that each tool offers as"
" a way to help you decide what tool might be best for your workflow."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:154
msgid "We do not suggest using setuptools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:157
msgid ""
"We suggest that you pick one of the modern tools listed above rather than"
" setuptools because setuptools will require some additional knowledge to "
"set up correctly."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:161
msgid ""
"We review setuptools as a back-end because it is still popular. However "
"it is not the most user friendly option."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:165
msgid ""
"The most commonly used tools in the ecosystem are setuptools back-end "
"(with build) and Poetry (a front end tool with numerous features and "
"excellent documentation)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:171
msgid ""
"Graph showing the results of the 2022 PyPA survey of Python packaging "
"tools. On the x axis is percent response and on the y axis are the tools."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:173
msgid ""
"The Python developers survey results (n=>8,000 PyPI users) show "
"setuptools and poetry as the most commonly used Python packaging tools. "
"The core tools that we've seen being used in the scientific community are"
" included here. [You can view the full survey results by clicking "
"here.](https://drive.google.com/file/d/1U5d5SiXLVkzDpS0i1dJIA4Hu5Qg704T9/view)"
" NOTE: this data represent maintainers across domains and is likely "
"heavily represented by those in web development. So this represents a "
"snapshot across the broader Python ecosystem."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:176
msgid "Chose a build workflow tool"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:178
msgid "The tools that we review below include:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:180
msgid "Twine, Build + setuptools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:181
#: ../../package-structure-code/python-package-build-tools.md:291
msgid "Flit"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:182
#: ../../package-structure-code/python-package-build-tools.md:331
msgid "Hatch"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:183
#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:230
msgid "PDM"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:184
#: ../../package-structure-code/python-package-build-tools.md:374
msgid "Poetry"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:186
msgid ""
"When you are selecting a tool, you might consider this general workflow "
"of questions:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:189
msgid ""
"**Is your tool pure python? Yes?** You can use any tool that you wish! "
"Pick the tool that has the features that you want to use in your build "
"workflow. We suggest:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:191
msgid "Flit, Hatch, PDM or Poetry (read below for more)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:193
msgid ""
"**Does your tool have a few C or C++ extensions?** Great, we suggest "
"using **PDM** for the time being. It is the only tool in the list below "
"that has both documented workflow to support such extensions and support "
"for other back-ends in the case that build hooks are not enough for your "
"workflow. PDM supports other back-ends such as scikit-build and meson-"
"python that will allow you to fully customize your package's build."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:197
msgid ""
"NOTE: You can also use Hatch for non pure python builds. Hatch, similar "
"to PDM, allows you to write your own build hooks or plugins to support "
"custom build steps. But currently, hatch does not support other build "
"back ends. Many of the core scientific packages are moving to meson-"
"python to build their packages. Thus, we appreciate that PDM can work "
"with meson-python specifically."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:199
msgid "Python packaging tools summary"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:201
msgid ""
"Below, we summarize features offered by the most popular build front end "
"tools. It is important to keep in mind that these front-end tools remove "
"the need to use other core tools in your workflow. For example if you use"
" setuptools, you will need to also use Build and Twine to build your "
"package and publish to PyPI. But if you use Poetry, Hatch or PDM you can "
"do all of those things using the same tool (e.g. `hatch build`, `hatch "
"publish` or `pdm build`, `pdm publish`)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:204
msgid ""
"Note that because setuptools does not offer a front-end interface, it is "
"not included in the table."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:208
msgid "Package tool features table"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Feature, Flit, Hatch, PDM, Poetry"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Default Build Back-end"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Flit-core"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "hatchling"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Poetry-core"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Use Other Build Backends"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Dependency management"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Publish to PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "Version Control based versioning (using `git tags`)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Version bumping"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Environment Management"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:215
msgid "More than one maintainer? (bus factor)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:225
msgid "Notes:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:227
msgid "_Hatch plans to support dependency management in the future_"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:228
msgid ""
"Poetry supports semantic versioning. Thus, it will support version "
"bumping following commit messages if you use a tool such as Python "
"Semantic Release"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:232
msgid ""
"[PDM is a Python packaging and dependency management "
"tool](https://pdm.fming.dev/latest/). PDM supports builds for pure Python"
" projects. It also provides multiple layers of support for projects that "
"have C and C++ extensions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:236
msgid "PDM support for C and C++ extensions"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:238
msgid ""
"PDM supports using the PDM-back-end and setuptools at the same time. This"
" means that you can run setuptools to compile and build C extensions. "
"PDM's build back-end receives the compiled extension files (.so, .pyd) "
"and packages them with the pure Python files."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:244
msgid "PDM Features"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Feature, PDM, Notes"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"When you setup PDM it allows you to select one of several build back ends"
" including: PDM-core, flit-core and hatchling. PDM also can work with "
"Meson-Python which supports move complex python builds."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Dependency specifications"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM has flexible support for  managing dependencies. PDM defaults to "
"using an open bound (e.g. `requests >=1.2`) approach to dependencies. "
"However you can  [customize how you want to add dependencies in case you "
"prefer another approach such as that of Poetry which uses an upper bound "
"limit](https://pdm.fming.dev/latest/usage/dependency/#about-update-"
"strategy).**"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Environment lock files"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM and Poetry are currently the only tools that create environment lock "
"files. Lock files are often most useful to developers creating web apps "
"where locking the environment is critical for consistent user experience."
" For community-used packages, you will likely never want to use a lock "
"file."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Environment management"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM provides environment management support. It supports Python virtual "
"environments, conda and a local `__pypackages__` environment which is a "
"newer option in the Python ecosystem. No extensions are needed for this "
"support."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "Select your environment type on install"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"When you run `PDM init`, PDM will discover environments that are already "
"on your system and allow you to select one to use for your project."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "PDM supports publishing to both test PyPI and PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Version Control based versioning"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM has a setuptools_scm like tool built into it which allows you to use "
"dynamic versioning that rely on git tags."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Follows current packaging standards"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"PDM supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Install your package in editable mode"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid "PDM supports installing your package in editable mode."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Build your sdist and wheel distributions"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:251
msgid ""
"Similar to all of the other tools PDM builds your packages sdist and "
"wheel files for you."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:264
msgid "PDM vs. Poetry"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:265
msgid ""
"The functionality of PDM is similar to Poetry. However, PDM also offers "
"additional, documented support for C extensions and version control based"
" versioning. As such, PDM is preferred for those working on non pure-"
"Python packages."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:269
msgid ""
"If you are deciding between the Poetry and PDM, a smaller  difference is "
"the default way that dependencies are added to your pyproject.toml file."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:271
msgid ""
"Poetry by default follows strict semantic versioning adding dependencies "
"to your pyproject.toml file [using an upper bounds constraint "
"(`^`)](https://python-poetry.org/docs/dependency-specification/#version-"
"constraints). Upper bounds lock means that Poetry will never bump a "
"dependency to the next major version (i.e. from 1.2 to 2.0). However, you"
" can tell Poetry to use an open bound approach by explicitly adding the "
"package like this: `poetry add requests >= 1.2` rather than just using "
"`poetry add requests` which will result in a upper bound locked (ie Upper"
" bound locks means that requests 2.0 could never be installed even if it "
"came out and your package could benefit from it)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:272
msgid ""
"PDM defaults to open-bounds (`>=`) dependency additions which is the "
"preferred approach in the scientific python ecosystem. However, PDM also "
"allows you to specify the way dependencies are added by default. As such,"
" you can also specify upper-bounds (`^`) using PDM if require that "
"approach."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:274
msgid ""
"Finally there are some nuanced differences in how both tools create lock "
"files which we will not go into detail about here."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:277
msgid "Challenges with PDM"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:279
msgid ""
"PDM is a full-featured packaging tool. However it is not without "
"challenges:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:281
msgid ""
"Its documentation can be confusing, especially if you are new to "
"packaging. For example, PDM doesn't provide an end to end beginning "
"workflow in its documentation."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:283
msgid ""
"PDM also only has one maintainer currently. We consider individual "
"maintainer teams to be a potential risk. If the maintainer finds they no "
"longer have time to work on the project, it leaves users with a gap in "
"support. Hatch and Flit also have single maintainer teams."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:288
msgid ""
"[You can view an example of a package that uses PDM "
"here](https://github.com/pyOpenSci/examplePy/tree/main/example4_pdm). The"
" README file for this directly provides you with an overview of what the "
"PDM command line interface looks like when you use it."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:293
msgid ""
"[Flit is a no-frills, streamlined packaging "
"tool](https://flit.pypa.io/en/stable/) that supports modern Python "
"packaging standards. Flit is a great choice if you are building a basic "
"package to use in a local workflow that doesn't require any advanced "
"features. And if your package structure is already created. More on that "
"below."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:297
msgid "Flit Features"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Feature, Flit, Notes"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
#: ../../package-structure-code/python-package-build-tools.md:348
#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Publish to PyPI and test PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit supports publishing to both test PyPI and PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Helps you add metadata to your **pyproject.toml** file"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid ""
"Flit does support adding metadata to your **pyproject.toml** file "
"following modern packaging standards."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid ""
"Flit supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit supports installing your package in editable mode.**"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:304
msgid "Flit can be used to build your packages sdist and wheel distributions."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:311
msgid ""
"NOTE: _If you are using the most current version of pip, it supports both"
" a symlink approach `flit install -s` and `python -m pip install -e .`_"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:313
msgid "Learn more about flit"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:314
msgid "[Why use flit?](https://flit.pypa.io/en/stable/rationale.html)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:317
msgid "Why you might not want to use Flit"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:319
msgid ""
"Because Flit is no frills, it is best for basic, quick builds. If you are"
" a beginner you may want to select Hatch or PDM which will offer you more"
" support in common operations."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:323
msgid "You may NOT want to use flit if:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:325
msgid ""
"You want to setup more advanced version tracking and management (using "
"version control for version bumping)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:326
msgid ""
"You want a tool that handles dependency versions (use PDM or Poetry "
"instead)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:327
msgid "You have a project that is not pure Python (Use Hatch, PDM or setuptools)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:328
msgid "You want environment management (use PDM, Hatch or Poetry)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:333
msgid ""
"[**Hatch**](https://hatch.pypa.io/latest/), similar to Poetry and PDM, "
"provides a unified command line interface. To separate Hatch from Poetry "
"and PDM, it also provides an environment manager for testing that will "
"make it easier for you to run tests locally across different versions of "
"Python. It also offers a nox / makefile like feature that allows you to "
"create custom build workflows such as building your documentation "
"locally. This means that you could potentially drop a tool like **Make** "
"or **Nox** from your workflow and use Hatch instead."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:340
msgid "Hatch features"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Feature, Hatch, Notes"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch is used with the backend Hatchling by default, but allows you to "
"use another backend by switching the declaration in pyproject.toml."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Currently you have to add dependencies manually with Hatch. However a "
"feature to support dependencies management may be added in a future "
"release."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports Python virtual environments. If you wish to use other "
"types of environments such as Conda, you will need to [install a plugin "
"such as hatch-conda for conda support](https://github.com/OldGrumpyViking"
"/hatch-conda)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Hatch supports publishing to both test PyPI and PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch offers `hatch_vcs` which is a plugin that uses setuptools_scm to "
"support versioning using git tags. The workflow with `hatch_vcs` is the "
"same as that with `setuptools_scm`."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch supports current packaging standards for adding metadata to the "
"**pyproject.toml** file."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"Hatch will install your package into any of its environments by default "
"in editable mode. You can install your package in editable mode manually "
"using `python -m pip install -e .` Hatch mentions [editable "
"installs](https://hatch.pypa.io/latest/config/build/#dev-mode) but refers"
" to pip in its documentation."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Hatch will build the sdist and wheel distributions"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "Matrix environment creation to support testing across Python versions"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"The matrix environment creation is a feature that is unique to Hatch in "
"the packaging ecosystem. This feature is useful if you wish to test your "
"package locally across Python versions (instead of using a tool such as "
"tox)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"[Nox / MAKEFILE like "
"functionality](https://hatch.pypa.io/latest/environment/#selection)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"This feature is also unique to Hatch. This functionality allows you to "
"create workflows in the **pyproject.toml** configuration to do things "
"like serve docs locally and clean your package build directory. This "
"means you may have one less tool in your build workflow."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid "A flexible build backend: **hatchling**"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:348
msgid ""
"**The hatchling build backend offered by the maintainer of Hatch allows "
"developers to easily build plugins to support custom build steps when "
"packaging."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:362
msgid ""
"_There is some argument about this approach placing a burden on "
"maintainers to create a custom build system. But others appreciate the "
"flexibility. The Hatch build hook approach is also comparable with the "
"features offered by PDM._"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:364
msgid "Why you might not want to use Hatch"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:366
msgid ""
"There are a few features that hatch is missing that may be important for "
"some. These include:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:369
msgid ""
"Hatch doesn't support adding dependencies. You will have to add them "
"manually."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:370
msgid "Hatch won't by default recognize Conda environments without a plugin."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:371
msgid ""
"Similar to PDM, Hatch's documentation can difficult to work through, "
"particularly if you are just getting started with creating a package."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:372
msgid "Hatch, similar to PDM and Flit currently only has one maintainer."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:376
msgid ""
"[Poetry is a full-featured build tool.](https://python-poetry.org/) It is"
" also the second most popular front-end packaging tool (based upon the "
"PyPA survey). Poetry is user-friendly and has clean and easy-to-read "
"documentation."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:381
msgid ""
"While some have used Poetry for Python builds with C/C++ extensions, this"
" support is currently undocumented. Thus, we don't recommend using Poetry"
" for more complex builds."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:385
msgid "Poetry features"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Feature, Poetry, Notes"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry helps you add dependencies to your `pyproject.toml` metadata. "
"_NOTE: currently Poetry adds dependencies using an approach that is "
"slightly out of alignment with current Python peps - however there is a "
"plan to fix this in an upcoming release._ Poetry also allows you to "
"organize dependencies in groups such as  documentation, packaging and "
"tests."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Dependency specification"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry allows you to be specific about version of dependencies that you "
"add to your package's pyproject.toml file. However, it's default upper "
"bound approach can be problematic for some packages (We suggest you "
"override the default setting when adding dependencies). Read below for "
"more."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry allows you to either use its built in environment or you can "
"select the environment type that you want to use for managing your "
"package. [Read more about its built in environment management "
"options](https://python-poetry.org/docs/basic-usage/#using-your-virtual-"
"environment)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Lock files"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry creates a **poetry.lock** file that you can use if you need a lock"
" file for your build."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Poetry supports publishing to both test PyPI and PyPI"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"The plugin [Poetry dynamic versioning](https://github.com/mtkennerly"
"/poetry-dynamic-versioning) supports versioning using git tags with "
"Poetry."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry supports you bumping the version of your package using standard "
"semantic version terms patch; minor; major"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry does not quite support current packaging standards for adding "
"metadata to the **pyproject.toml** file but plans to fix this in an "
"upcoming release."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid ""
"Poetry supports installing your package in editable mode using "
"`--editable`"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:392
msgid "Poetry will build your sdist and wheel distributions using `poetry build`"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:407
msgid "Challenges with Poetry"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:409
msgid "Some challenges of Poetry include:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:411
msgid ""
"Poetry, by default, pins dependencies using an \"upper bound\" limit "
"specified with the `^` symbol by default. However, this behavior can be "
"over-written by specifying the dependency when you use `Poetry add` as "
"follows: `poetry add \"requests>=2.1\"` See breakout below for more "
"discussion on issues surrounding upper-bounds pinning."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:412
msgid ""
"_Minor Challenge:_ The way Poetry currently adds metadata to your "
"pyproject.toml file does not follow current Python standards. However, "
"this is going to be addressed with Poetry release version 2.0."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:414
msgid ""
"Poetry is an excellent tool. Use caution when using it to pin "
"dependencies as Poetry's approach to pinning can be problematic for many "
"builds. If you use Poetry, we strongly suggest that you override the "
"default upper bound dependency option."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:420
msgid "Challenges with Poetry dependency pinning"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:423
msgid ""
"By default, Poetry pins dependencies using `^` by default. This `^` "
"symbol means that there is an \"upper bound\" to the dependency. Thus "
"poetry won't bump a dependency version to a new major version. Thus, if "
"your package uses a dependency that is at version 1.2.3, Poetry will "
"never bump the dependency to 2.0 even if there is a new major version of "
"the package. Poetry will instead bump up to 1.9.x."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:429
msgid ""
"Poetry does this because it adheres to strict semantic versioning which "
"states that a major version bump (from 1.0 to 2.0 for example) means "
"there are breaking changes in the tool. However, not all tools follow "
"strict semantic versioning. [This approach has been found to be "
"problematic by many of our core scientific "
"packages.](https://iscinumpy.dev/post/bound-version-constraints/)"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:434
msgid ""
"This approach also won't support others ways of versioning tools, for "
"instance, some tools use [calver](https://calver.org/) which creates new "
"versions based on the date."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:438
msgid "Using Setuptools Back-end for Python Packaging with Build Front-end"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:440
msgid ""
"[Setuptools](https://setuptools.pypa.io/en/latest/) is the most mature "
"Python packaging build tool with [development dating back to 2009 and "
"earlier](https://setuptools.pypa.io/en/latest/history.html#). Setuptools "
"also has the largest number of community users (according to the PyPA "
"survey). Setuptools does not offer a user front-end like Flit, Poetry and"
" Hatch offer. As such you will need to use other tools such as **build** "
"to create your package distributions and **twine** to publish to PyPI."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:448
msgid ""
"While setuptools is the most commonly used tool, we encourage package "
"maintainers to consider using a more modern tool for packaging such as "
"Poetry, Hatch or PDM."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:451
msgid ""
"We discuss setuptools here because it's commonly found in the ecosystem "
"and contributors may benefit from understanding it."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:454
msgid "Setuptools Features"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:456
msgid "Some of features of setuptools include:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:458
msgid "Fully customizable build workflow"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:459
msgid "Many scientific Python packages use it."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:460
msgid ""
"It offers version control based package versioning using "
"**setuptools_scm**"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:461
msgid "It supports modern packaging using **pyproject.toml** for metadata"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:462
msgid "Supports backwards compatibly for older packaging approaches."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:464
msgid "Challenges using setuptools"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:468
msgid "Setuptools has a few challenges:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:470
msgid ""
"Setuptools does not support interactive features such as auto / tab "
"completion by default if you are working in an IDE like VSCODE and using "
"an editable install for development. [See notes here about pylance "
"support](https://github.com/microsoft/pylance-"
"release/blob/main/TROUBLESHOOTING.md#editable-install-modules-not-found)."
" In comparison, tools such as flit, hatch, PDM support interactive "
"features such as tab / auto completion when using an IDE like VSCODE or "
"pycharm (as long as your version of pip is current!)."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:471
msgid ""
"Because **setuptools** has to maintain backwards compatibility across a "
"range of packages, it is not as flexible in its adoption of modern Python"
" packaging standards."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:474
msgid ""
"The above-mentioned backwards compatibility makes for a more complex "
"code-base."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:475
msgid ""
"Your experience as a user will be less streamlined and simple using "
"setuptools compared to other tools discussed on this page."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:477
msgid ""
"There are also some problematic default settings that users should be "
"aware of when using setuptools. For instance:"
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:480
msgid ""
"setuptools will build a project without a name or version if you are not "
"using a **pyproject.toml** file to store metadata."
msgstr ""

#: ../../package-structure-code/python-package-build-tools.md:482
msgid ""
"setuptools also will include all of the files in your package repository "
"if you do not explicitly tell it to exclude files using a **MANIFEST.in**"
" file"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:1
msgid "Learn about Building a Python Package"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:8
msgid ""
"Once you have published both package distributions (the source "
"distribution and the wheel) to PyPI, you can then publish to conda-forge."
" conda-forge requires an source distribution on PyPI in order to build "
"your package on conda-forge. You do not need to rebuild your package to "
"publish to conda-forge."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:11
msgid ""
"You need to build your Python package in order to publish it to PyPI (or "
"a conda channel). The build process organizes your code and metadata into"
" a distribution format that can be uploaded to PyPI and subsequently "
"downloaded and installed by users. NOTE: you need to publish a sdist to "
"PyPI in order for conda-forge to properly build your package "
"automatically."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:14
msgid "What is building a Python package?"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:16
msgid ""
"To [publish your Python package](publish-python-package-pypi-conda) and "
"make it easy for anyone to install, you first need to build it."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:18
msgid "But, what does it mean to build a Python package?"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:20
msgid ""
"[As shown in the figure above](#pypi-conda-channels), when you build your"
" Python package, you convert the source files into something called a "
"distribution package. A distribution package contains your source code "
"and metadata about the package, in the format required by the Python "
"Package Index, so that it can be installed by tools like pip."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:23
msgid ""
"The term package used to mean many different things in Python and other "
"languages. On this page, we adapt the convention of the [Python Packaging"
" Authority](https://www.pypa.io/en/latest/) and refer to the product of "
"the build step as a **distribution package**."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:27
msgid ""
"This process of organizing and formatting your code, documentation, tests"
" and metadata into a format that both pip and PyPI can use, is called a "
"build step."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:31
msgid "Project metadata and PyPI"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:33
msgid ""
"The metadata that both build tools and PyPI uses to describe and "
"understand your package is generally stored in a [pyproject.toml file"
"](pyproject-toml-python-package-metadata). This metadata is used for "
"several purposes:"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:35
msgid ""
"It helps whatever tool you use to build your package (pip, [pypa's "
"Build](https://pypi.org/project/build/) or an end-to-end tool such as "
"poetry, PDM or Hatch) understand how to build your package. Information "
"it provides to your build tool includes:"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:37
msgid ""
"The `[build-system]` table in your pyproject.toml file tells pip what "
"[build backend tool](build_backends) you wish to use for creating your "
"sdist and wheel distributions."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:45
msgid ""
"And the dependencies section of your project table tells the build tool "
"and PyPI what dependencies your project requires."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:54
msgid ""
"When the build tool creates your package distribution file (the file that"
" you publish on PyPI), it also creates a METADATA file which PyPI can "
"read and use to help users find your package. For example:"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:56
msgid ""
"The `classifiers = ` section of your `[project]` table in the "
"pyproject.toml file provides information that users on PyPI can use to "
"filter for packages that contain specific licenses or that support "
"specific versions of python."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:73
msgid "What happened to setup.py and setup.cfg for metadata?"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:76
msgid ""
"Project metadata used to be stored in either a setup.py file or a "
"setup.cfg file. The current recommended practice for storing package "
"metadata is to use a pyproject.toml file. [Learn more about the "
"pyproject.toml file here.](pyproject-toml-python-package-metadata)"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:79
msgid "An example - xclim"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:94
msgid ""
"Graphic showing the high level packaging workflow. On the left you see a "
"graphic with code, metadata and tests in it. those items all go into your"
" package. Documentation and data are below that box because they aren't "
"normally published in your packaging wheel distribution. an arrow to the "
"right takes you to a build distribution files box. that box leads you to "
"either publishing to TestPyPI or the real PyPI. from PyPI you can then "
"connect to conda-forge for an automated build that sends distributions "
"from PyPI to conda-forge."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:96
msgid ""
"You need to build your Python package in order to publish it to PyPI (or "
"Conda). The build process organizes your code and metadata into a "
"distribution format that can be uploaded to PyPI and subsequently "
"downloaded and installed by users. NOTE: you need to publish a sdist to "
"PyPI in order for conda-forge to properly build your package "
"automatically."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:101
msgid ""
"This screenshot shows the metadata on PyPI for the xclim package. on it "
"you can see the name of the license, the author and maintainer names "
"keywords associated with the package and the base python version it "
"requires which is 3.8."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:103
msgid "PyPI screenshot showing metadata for the xclim package."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:110
msgid ""
"Here you see the maintinaer metadata as it is displayed on PyPI. for "
"xclim there are three maintainers listed with their profile pictures and "
"github user names to the right."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:112
msgid ""
"Maintainer names and GitHub usernames for the xclim package as they are "
"displayed on PyPI. This information is recorded in your pyproject.toml "
"and then processed by your build tool and stored in your packages sdist "
"and wheel distributions."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:115
msgid "How to create the distribution format that PyPI and Pip expects?"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:117
msgid ""
"You could in theory create your own scripts to organize your code the way"
" PyPI wants it to be. However, just like there are packages that handle "
"known structures such as Pandas for data frames and Numpy for arrays, "
"there are packages and tools that help you create package build "
"distribution files."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:121
msgid ""
"There are a suite of packaging tools that can either help you with the "
"entire packaging process or just one step of the process. For instance "
"setuptools is a commonly used build back end that can be used to create "
"your sdist and wheel. Whereas tools like Hatch, PDM, Poetry and flit help"
" with other parts of the packaging process."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:127
msgid ""
"While this can cause some confusion and complexity in the packaging "
"ecosystem - for the most part, each tool provides the same distribution "
"output (with minor differences that most users may not care about). Learn"
" more about those tools on this page."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:133
msgid ""
"Below, you will learn about the two distribution files that PyPI expects "
"you to publish: sdist and wheel. You will learn about their structure and"
" what files belong in each."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:136
msgid ""
"There are two core distribution files that you need to create to publish "
"your Python package to PyPI source distribution (often called an sdist) "
"and wheel. The sdist contains the raw source code for your package. The "
"wheel (.whl) contains the built / compiled files that can be directly "
"installed onto anyones' computer."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:142
msgid "Learn more about both distributions below."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:145
msgid ""
"If your package is a pure python package with no additional build / "
"compilation steps then the sdist and wheel distributions will have "
"similar content. However if your package has extensions in other "
"languages or is more complex in its build, the two distributions will be "
"very different."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:150
msgid ""
"Also note that we are not discussing conda build workflows in this "
"section. [You can learn more about conda builds "
"here.](https://conda.io/projects/conda-build/en/latest/user-"
"guide/tutorials/index.html)"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:155
msgid "Source Distribution (sdist)"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:157
msgid ""
"**Source files** are the unbuilt files needed to build your package. "
"These are the \"raw / as-is\" files that you store on GitHub or whatever "
"platform you use to manage your code."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:161
msgid ""
"Source Distributions (**S** + **Dist**) are referred to as sdist. As the "
"name implies, a SDIST contains the source code; it has not been built or "
"compiled in any way. Thus, when a user installs your source distribution "
"using pip, pip needs to run a build step first. For this reason, you "
"could define a source distribution as a compressed archive that contains "
"everything required to build a wheel (except for project dependencies) "
"without network access."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:165
msgid ""
"Sdist is normally stored as a `.tar.gz` archive (often called a "
"\"tarball\"). Thus, when a user installs your source distribution using "
"pip, pip needs to run a build step first."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:167
msgid "Below is an example sdist for the stravalib Python package:"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:219
msgid "GitHub archive vs sdist"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:221
msgid ""
"When you make a release on GitHub, it creates a `git archive` that "
"contains all of the files in your GitHub repository. While these files "
"are similar to an sdist, these two archives are not the same. The sdist "
"contains a few other items including a metadata directory and if you use "
"`setuptools_scm` or `hatch_vcs` the sdist may also contain a file that "
"stores the version."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:229
msgid "Wheel (.whl files):"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:231
msgid ""
"A wheel file is a ZIP-format archive whose filename follows a specific "
"format (below) and has the extension `.whl`. The `.whl` archive contains "
"a specific set of files, including metadata that are generated from your "
"project's pyproject.toml file. The pyproject.toml and other files that "
"may be included in source distributions are not included in wheels "
"because it is a built distribution."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:238
msgid ""
"The wheel (.whl) is your built binary distribution. **Binary files** are "
"the built / compiled source files. These files are ready to be installed."
" A wheel (**.whl**) is a **zip** file containing all of the files needed "
"to directly install your package. All of the files in a wheel are "
"binaries - this means that code is already compiled / built. Wheels are "
"thus faster to install - particularly if you have a package that requires"
" build steps."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:240
msgid ""
"The wheel does not contain any of your package's configuration files such"
" as **setup.cfg** or **pyproject.toml**. This distribution is already "
"built so it's ready to install."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:244
msgid ""
"Because it is built, the wheel file will be faster to install for pure "
"Python projects and can lead to consistent installs across machines."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:252
msgid ""
"Wheels are also useful in the case that a package needs a **setup.py** "
"file to support a more complex build. In this case, because the files in "
"the wheel bundle are pre built, the user installing doesn't have to worry"
" about malicious code injections when it is installed."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:259
msgid "The filename of a wheel contains important metadata about your package."
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:261
msgid "Example: **stravalib-1.1.0.post2-py3-none.whl**"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:263
msgid "name: stravalib"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:264
msgid "version: 1.1.0"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:265
msgid ""
"build-number: 2 (post2) [(read more about post "
"here)](https://peps.python.org/pep-0440/#post-release-separators)"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:266
msgid "py3: supports Python 3.x"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:267
msgid "none: is not operating system specific (runs on windows, mac, linux)"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:268
msgid "any: runs on any computer processor / architecture"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:270
msgid "What a wheel file looks like when unpacked (unzipped):"
msgstr ""

#: ../../package-structure-code/python-package-distribution-files-sdist-wheel.md:304
msgid "[Read more about the wheel format here](https://pythonwheels.com/)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:1
msgid "Python Package Structure for Scientific Python Projects"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:3
msgid ""
"There are two different layouts that you will commonly see within the "
"Python packaging ecosystem: [src and flat "
"layouts.](https://packaging.python.org/en/latest/discussions/src-layout-"
"vs-flat-layout/) Both layouts have advantages for different groups of "
"maintainers."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:8
msgid ""
"We strongly suggest, but do not require, that you use the **src/** layout"
" (discussed below) for creating your Python package. This layout is also "
"recommended in the [PyPA packaging "
"guide](https://packaging.python.org/en/latest/tutorials/packaging-"
"projects/)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:12
msgid "pyOpenSci will never require a specific package structure for peer review"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:15
msgid ""
"We understand that it would be tremendous effort for existing maintainers"
" to move to a new layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:18
msgid ""
"The overview on this page presents recommendations that we think are best"
" for someone getting started with Python packaging or someone who's "
"package has a simple build and might be open to moving to a more fail-"
"proof approach."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:23
msgid "An example of the **src/package** layout structure can be seen below."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:45
msgid "Note the location of the following directories in the example above:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:47
msgid ""
"**docs/:** discussed in our docs chapter, this directory contains your "
"user-facing documentation website. In a **src/** layout docs/ are "
"normally included at the same directory level of the **src/** folder."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:48
msgid ""
"**tests/** this directory contains the tests for your project code. In a "
"**src/** layout tests are normally included at the same directory level "
"of the **src/** folder."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:49
msgid ""
"**src/package/**: this is the directory that contains the code for your "
"Python project. \"Package\" is normally your project's name."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:51
msgid ""
"Also in the above example, notice that all of the core documentation "
"files that pyOpenSci requires live in the root of your project directory."
" These files include:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:55
msgid "CHANGELOG.md"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:56
msgid "CODE_OF_CONDUCT.md"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:57
msgid "CONTRIBUTING.md"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:58
msgid "LICENSE.txt"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:59
msgid "README.md"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:63
msgid "Click here to read about our packaging documentation requirements."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:70
msgid ""
"While we recommend the **src/** layout we also review the **flat** layout"
" here. Both are used in the Python ecosystem."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:72
msgid "Example scientific packages that use **src/package** layout"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:74
msgid "[Sourmash](https://github.com/sourmash-bio/sourmash)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:75
msgid "[bokeh](https://github.com/bokeh/bokeh)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:76
msgid "[openscm](https://github.com/openscm/openscm-runner)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:77
msgid "[awkward](https://github.com/scikit-hep/awkward)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:78
msgid "[poliastro](https://github.com/poliastro/poliastro/)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:82
msgid "The src/ layout and testing"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:84
msgid ""
"The benefit of using the **src/package** layout, particularly if you are "
"creating a new package, is that it ensures tests are run against the "
"installed version of your package rather than the files in your package "
"working directory. If you run your tests on your files rather than the "
"installed version, you may be missing issues that users encounter when "
"your package is installed."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:91
msgid ""
"If `tests/` are outside of the **src/package** directory, they aren't "
"included in the package wheel. This makes your package size slightly "
"smaller which then places places a smaller storage burden on PyPI which "
"has over 400,000 packages to support."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:93
msgid ""
"[Read more about reasons to use the **src/package** "
"layout](https://hynek.me/articles/testing-packaging/)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:95
msgid "How Python discovers and prioritizes importing modules"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:97
msgid ""
"By default, Python adds a module in your current working directory to the"
" front of the Python module search path."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:99
msgid ""
"This means that if you run your tests in your package's working "
"directory, using a flat layout, `/package/module.py`, Python will "
"discover `package/module.py` file before it discovers the installed "
"package."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:101
msgid ""
"However, if your package lives in a src/ directory structure "
"**src/package** then it won't be, by default, added to the Python path. "
"This means that when you import your package, Python will be forced to  "
"search the active environment (which has your package installed)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:103
msgid ""
"Note: Python versions 3.11 and above have a path setting that can be "
"adjusted to ensure the priority is to use installed packages first (e.g. "
"`PYTHONSAFEPATH`)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:106
msgid "Sometimes tests are needed in a distribution"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:108
msgid ""
"We do not recommend including tests as part of your package wheel by "
"default. However, not including tests in your package distribution will "
"make it harder for people other than yourself to test whether your "
"package is functioning correctly on their system. If you have a small "
"test suite (Python files + data), and think your users may want to run "
"tests locally on their systems, you can include tests by moving the "
"`tests/` directory into the **src/package** directory (see example "
"below)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:117
msgid ""
"Including the **tests/** directory in your **src/package** directory "
"ensures that tests will be included in your package's wheel."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:119
msgid ""
"Be sure to read the [pytest documentation for more about including tests "
"in your package "
"distribution](https://docs.pytest.org/en/7.2.x/explanation/goodpractices.html#choosing-a"
"-test-layout-import-rules)."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:121
msgid "Challenges with including tests and data in a package wheel"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:124
msgid ""
"Tests, especially when accompanied by test data can create a few small "
"challenges including:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:126
msgid ""
"Take up space in your distribution which will build up over time as "
"storage space on PyPI"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:127
msgid "Large file sizes can also slow down package install."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:129
msgid ""
"However, in some cases, particularly in the scientific Python ecosystems "
"you may need to include tests."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:132
msgid "**Don't include test suite datasets in your package**"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:134
msgid ""
"If you do include your tests in your package distribution, we strongly "
"discourage you from including data in your test suite directory. Rather, "
"host your test data in a repository such as Figshare or Zenodo. Use a "
"tool such as [Pooch](https://www.fatiando.org/pooch/latest/) to access "
"the data when you (or a user) runs tests."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:140
msgid ""
"Check out the testing section of our guide for more information about "
"tests."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:142
msgid ""
"The **src/package** layout is semantically more clear. Code is always "
"found in the **src/package** directory, `tests/` and `docs/`are in the "
"root directory."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:146
msgid ""
"If your package tests require data, we suggest that you do NOT include "
"that data within your package structure. We will discuss this in more "
"detail in a tutorial. Include data in your package structure increases "
"the size of your distribution files. This places a maintenance toll on "
"repositories like PyPI and Anaconda.org that have to deal with thousands "
"of package uploads."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:153
msgid "About the flat Python package layout"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:155
msgid "Currently most scientific packages use the **flat-layout** given:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:157
msgid ""
"It's the most commonly found layout with the scientific Python ecosystem "
"and people tend to look to other packages / maintainers that they respect"
" for examples of how to build Python packages."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:160
msgid ""
"Many Python tools depend upon tools in other language and / or complex "
"builds with compilation steps. Many developers thus appreciate / are used"
" to features of the flat layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:164
msgid ""
"While we present this layout here in our guide, we suggest that those "
"just getting started with python packaging start with the src/package "
"layout discussed above. Numerous packages in the ecosystem [have had to "
"move to a src/ layout](https://github.com/scikit-build/cmake-python-"
"distributions/pull/145)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:169
msgid "Why most scientific Python packages do not use source"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:172
msgid ""
"In most cases the advantages of using the **src/package** layout for "
"larger scientific packages that already use flat approach are not worth "
"it. Moving from a flat layout to a **src/package** layout would come at a"
" significant cost to maintainers."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:177
msgid ""
"However, the advantages of using the  **src/package** layout for a "
"beginner are significant. As such, we recommend that if you are getting "
"started with creating a package, that you consider using a  "
"**src/package** layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:182
msgid "What does the flat layout structure look like?"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:184
msgid "The flat layout's primary characteristics are:"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:186
msgid ""
"The source code for your package lives in a directory with your package's"
" name in the root of your directory"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:188
msgid ""
"Often the `tests/` directory also lives within that same `package` "
"directory."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:190
msgid ""
"Below you can see the recommended structure of a scientific Python "
"package using the flat layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:212
msgid "Benefits of using the flat layout in your Python package"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:214
msgid ""
"There are some benefits to the scientific community in using the flat "
"layout."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:216
msgid ""
"This structure has historically been used across the ecosystem and "
"packages using it are unlikely to change."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:218
msgid ""
"You can import the package directly from the root directory. For some "
"this is engrained in their respective workflows. However, for a beginner "
"the danger of doing this is that you are not developing and testing "
"against the installed version of your package. Rather, you are working "
"directly with the flat files."
msgstr ""

#: ../../package-structure-code/python-package-structure.md:224
msgid "Core scientific Python packages that use the flat layout"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:227
msgid "[numpy](https://github.com/numpy/numpy)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:228
msgid "[scipy](https://github.com/scipy/scipy)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:229
msgid "[pandas](https://github.com/pandas-dev/pandas)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:230
msgid "[xarray](https://github.com/pydata/xarray)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:231
msgid "[Jupyter-core](https://github.com/jupyter/jupyter_core)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:232
msgid "[Jupyter notebook](https://github.com/jupyter/notebook)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:233
msgid "[scikit-learn](https://github.com/scikit-learn/scikit-learn)"
msgstr ""

#: ../../package-structure-code/python-package-structure.md:235
msgid ""
"It would be a significant maintenance cost and burden to move all of "
"these packages to a different layout. The potential benefits of the "
"source layout for these tools is not worth the maintenance investment."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:1
msgid "Creating New Versions of Your Python Package"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:6
msgid "Key Takeways"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:8
msgid ""
"Follow [semantic versioning guidelines (SemVer) "
"rules](https://semver.org/) when bumping (increasing) your Python's "
"package version; for example a major version bump (version 1.0 --> 2.0) "
"equates to breaking changes in your package's code for a user."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:9
msgid ""
"You may want to consider using a plugin like hatch_vsc for managing "
"versions of your package - if you want to have a GitHub only release "
"workflow."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:10
msgid ""
"Otherwise most major package build tools such as Hatch, Flit and PDM have"
" a version feature that will help you update your package's version"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:11
msgid "Avoid updating your packages version number manually by hand in your code!"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:14
msgid ""
"pyOpenSci recommends that you follow the [Python PEP "
"440](https://peps.python.org/pep-0440) which recommends using [semantic "
"versioning guidelines](https://www.python.org/dev/peps/pep-0440"
"/#semantic-versioning) when assigning release values to new versions of "
"your Python package."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:18
msgid ""
"[Semantic versioning](https://semver.org/) is an approach to updating "
"package versions that considers the type and extent of a change that you "
"are making to the package code. Being consistent with how and when you "
"update your package versions is important as:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:23
msgid ""
"It helps your users (which might include other developers that depend on "
"your package) understand the extent of changes to a package."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:24
msgid ""
"It helps your development team make decisions about when to bump a "
"package version based on standard rules."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:26
msgid ""
"Consistent version increases following semver rules mean that values of "
"your package version explain the extent of the changes made in the code "
"base from version to version. thus your package version numbers become "
"\"expressive\" in the same way that naming code variables well can [make "
"code expressive](https://medium.com/@daniel.oliver.king/writing-"
"expressive-code-b69ef7a5a2fa)."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:28
msgid "A note about versioning"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:29
msgid ""
"In some cases even small version changes can turn a package update into a"
" breaking change for some users. What is also important is that you "
"document how you version your code and if you can, also document your "
"deprecation policy for code."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:37
msgid "SemVer rules"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:39
msgid "Following SemVer, your bump your package version to a:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:41
msgid "patch (1.1.1 --> 1.1.**2**)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:42
msgid "minor (1.1.1 --> 1.**2**.1)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:43
msgid "major (1.1.1 --> **2**.1.1)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:45
msgid "version number change based on the following rules:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:47
msgid "Given a version number MAJOR.MINOR.PATCH, increment the:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:49
msgid "**MAJOR version** when you make incompatible API changes"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:50
msgid ""
"**MINOR version** when you add functionality in a backwards compatible "
"manner"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:51
msgid ""
"**PATCH version** when you make backwards compatible bug fixes Additional"
" labels for pre-release and build metadata are available as extensions to"
" the MAJOR.MINOR.PATCH format."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:56
msgid ""
"Some people prefer to use [calver](https://calver.org/index.html) for "
"versioning. It may be a simpler-to-use system given it relies upon date "
"values associated with released versions. However, calver does not "
"provide a user with a sense of when a new version might break an existing"
" build. As such we still suggest semver."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:59
msgid ""
"pyOpenSci will never require semver in a peer review as long as a package"
" has a reasonable approach to versioning!"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:63
msgid "Avoid manually updating Python package version numbers if you can"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:65
msgid ""
"Often times you may want to have your package version value in multiple "
"locations. One example of this is that it might be both an attribute in "
"your package **version** and also called in your documentation."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:70
msgid ""
"We recommend that you avoid manual updates of your package version number"
" to avoid human-error. It is better practice to keep your version number "
"in one location."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:74
msgid ""
"If you can't implement a single location version, then consider using a "
"tool like hatch, PDM or bump2version that will update the version values "
"for you - throughout your package."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:78
msgid ""
"Below we discuss some tools that you can use to manage updating Python "
"package versions."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:83
msgid "Tools to manage versions for your Python package"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:85
msgid ""
"There are a handful of tools that are widely used in the scientific "
"ecosystem that you can use to manage your package versions. Some of these"
" tools are built into or work with your chosen [packaging build tools "
"that discussed in this chapter.](python-package-build-tools)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:91
msgid "Below, we provide an overview of these tools."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:97
msgid ""
"There are three general groups of tools that you can use to manage "
"package versions:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:100
msgid ""
"**semantic release tools:** These tools will automagically determine what"
" type of version bump to use using the text in your commit messages. "
"Below we discuss [Python Semantic Release](https://python-semantic-"
"release.readthedocs.io/en/latest/) as a Python tool that implements a "
"semantic versioning approach."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:102
msgid ""
"**Manual incremental bump tools:** Tools like "
"[Hatch](https://hatch.pypa.io/latest/version/) offer version bumping "
"within your package. Normally this is implemented at the command link for"
" instance `hatch version major` would bump your project from 0.x to 1.0."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:103
msgid ""
"**Version Control System tools:** Finally there are tools that rely on "
"your version control system to track versions. These tools often are "
"plugins to your package build tool (ex: setuptools build or hatchling). "
"We discuss this option below assuming that you are using **.git tags** "
"and **GitHub** to manage your package repository."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:105
msgid "Semantic release, vs version control based vs manual version bumping"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:107
msgid ""
"Generally semantic release and version control system tools can be setup "
"to run automatically on GitHub using GitHub actions. This means that you "
"can create a workflow where a GitHub release and associated new version "
"tag is used to trigger an automated build that:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:113
msgid "Builds your package and updates the version following the new tag"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:114
msgid "Tests the build and publishes to test PyPI"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:115
msgid "Publishes the package to PyPI"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:118
msgid ""
"Bumping a package version refers to the step of increasing the package "
"version after a set number of changes have been made to it. For example, "
"you might bump from version 0.8 to 0.9 of a package. or from 0.9 to 1.0."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:122
msgid ""
"Using semantic versioning, there are three main \"levels\" of versions "
"that you might consider:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:125
msgid "Major, minor and patch. These are described in more detail below."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:128
msgid "Tools for bumping Python package versions"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:130
msgid ""
"In this section we discuss the following tools for managing your Python "
"package's version:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:133
msgid "hatch &"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:134
msgid "hatch_vcs plugin for hatchling"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:135
msgid "setuptools-scm"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:136
msgid "python-semantic-version"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:138
msgid "Tool 1: Hatch and other build tools that offer incremental versioning"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:140
msgid ""
"Many of the modern build tool front end tools offer version support that "
"follow semantic versioning rules. These tools are different from Python "
"Semantic Version in that they do not require specific commit messages to "
"implement version. Rather, they allow you to update the version at the "
"command line using commands such as:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:146
msgid "`tool-name version update major`"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:147
msgid "`tool-name version update minor`"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:149
msgid ""
"[Hatch](https://hatch.pypa.io/latest/version/), for instance offers "
"`hatch version minor` which will modify the version of your package "
"incrementally. With **Hatch** the version value will be found in your "
"`pyproject.toml` file. <!-- TODO double check this -->"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:152
msgid "Hatch (or other tools like PDM) Pros"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:154
msgid "Easy to use version updates locally using a single tool!"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:156
msgid "Hatch (or other tools like PDM) Cons"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:158
msgid ""
"There will be some setup involved to ensure package version is updated "
"throughout your package"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:160
msgid "Tool 2: Hatch_vcs & hatchling build back-end"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:162
msgid ""
"[hatch_vcs](https://github.com/ofek/hatch-vcs) is a versioning tool that "
"allows you to manage package versions using **git tags**. Hatch_vcs "
"creates a **\\_version.py** file in your package ecosystem that keeps "
"track of the package's current version."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:167
msgid ""
"Hatch keeps track of your package's version in a `_version.py` file. "
"Storing the version in a single file managed by Hatch provides your "
"package with a \"single source of truth\" value for the version number. "
"This in turn eliminates potential error associated with manually updating"
" your package's version."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:173
msgid ""
"When you (or your CI system) build your package, hatch checks the current"
" tag number for your package. if it has increased, it will update the "
"**\\_version.py** file with the new value."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:176
msgid ""
"Thus, when you create a new tag or a new release with a tag and build "
"your package, Hatch will access the new tag value and use it to update "
"your package version."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:179
msgid ""
"To use **hatch_vcs** you will need to use the **hatchling** build back "
"end."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:182
msgid ""
"Hatchling can also be used with any of the modern build tools including "
"**Flit** and **PDM** if you prefer those for your day to day workflow."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:187
msgid "Hatch example setup in your pyproject.toml"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:196
msgid ""
"**Hatch_vcs** supports a fully automated package release and build, and "
"push to PyPI workflow on GitHub."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:206
msgid ""
"If you use **setuptools_scm**, then you might find **hatch_vcs** and "
"**hatchling** to be the modern equivalent to your current setuptools / "
"build workflow."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:209
msgid "hatch_vcs Pros"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:211
msgid "Hatch supports modern Python packaging standards"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:212
#: ../../package-structure-code/python-package-versions.md:238
msgid "It creates a single-source file that contains your package version."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:213
#: ../../package-structure-code/python-package-versions.md:239
msgid "You never manually update the package version"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:214
#: ../../package-structure-code/python-package-versions.md:240
msgid ""
"You can automate writing the version anywhere in your package including "
"your documentation!"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:215
#: ../../package-structure-code/python-package-versions.md:241
msgid ""
"It supports a purely GitHub based release workflow. This simplifies "
"maintenance workflows."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:216
#: ../../package-structure-code/python-package-versions.md:242
msgid ""
"Version number is updated in your package via a hidden `_version.py` "
"file. There is no manual configuration updates required."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:217
#: ../../package-structure-code/python-package-versions.md:243
msgid ""
"While we like detailed commit messages (See Python Semantic Version "
"below), we know that sometimes when maintaining a package specific "
"guidelines around commit messages can be hard to apply and manage."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:219
msgid "hatch_vcs Cons"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:221
msgid ""
"In a CI workflow you will end up manually entering or creating the "
"version number via a tag on GitHub. But you could locally develop a build"
" to \"bump\" tag versions"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:224
msgid "Tool 3: setuptools-scm versioning using git tags"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:226
msgid ""
"[`Setuptools_scm`](https://github.com/pypa/setuptools_scm/) is an "
"extension that you can use with setuptools to manage package versions. "
"**Setuptools_scm** operates the same way that **hatch_vcs** (discussed "
"above) does. It stores a version in a **\\_version.py** file and relies "
"on (**git**) tags to determine the package's current version."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:232
msgid ""
"If you are using **setuptools** as your primary build tool, then "
"`*setuptools-scm` is a good choice as:"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:236
msgid "setuptools_scm Pros"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:244
msgid "**setuptools** is still the most commonly used Python packaging build tool"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:246
msgid "setuptools_scm Cons"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:248
msgid ""
"In a CI workflow you will end up manually entering or creating the "
"version number via a tag on GitHub."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:249
msgid "Not well documented"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:250
msgid ""
"Because setuptools will always have to support backwards compatibility it"
" will always be slower in adopting modern Python packaging conventions."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:252
msgid ""
"As such you might consider using a more modern tool such as **hatch_vcs**"
" and **hatchling** to build your package and manage package versions."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:264
msgid ""
"Tool 4: [Python semantic release](https://python-semantic-"
"release.readthedocs.io/en/latest/)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:266
msgid ""
"Python semantic release uses a commit message workflow that updates the "
"version of your package based on keywords found in your commit messages. "
"As the name implies, Python Semantic Release follows semver release "
"rules."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:271
msgid ""
"With Python Semantic Release, versions are triggered using specific "
"language found in a git commit message."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:274
msgid ""
"For example, the words `fix(attribute_warning):` trigger Python Semantic "
"Release to implement a **patch** version bump. For instance if your "
"package was at version 1.1.0 and you made the commit below with the words"
" fix(text-here), Python Semantic Release would bump your package to "
"version 1.1.1."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:284
msgid ""
"Similarly a feature (`feat()`) triggers a minor version bump. For example"
" from version 1.1 to version 1.2"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:292
msgid ""
"You can find a thoughtful discussion of python semantic version [in this "
"Python package guide](https://py-pkgs.org/07-releasing-versioning"
"#automatic-version-bumping). Note that the guide hasn't been updated "
"since 2020 and will potentially be updated in the future! But for now, "
"some of the commands are dated but the content is still excellent."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:295
msgid "Python Semantic Release Pros"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:297
msgid "Follows semver versioning closely"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:298
msgid ""
"Enforces maintainers using descriptive commit messages which can simplify"
" troubleshooting and ensure a cleaner and more self-describing git "
"history."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:300
msgid "Python Semantic Release Cons"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:302
msgid ""
"Requires very specific commit language to work. In practice some "
"maintainers and contributors may not be able to maintain that level of "
"specificity in commit messages (NOTE: there are bots that will check git "
"commit messages in a repo)"
msgstr ""

#: ../../package-structure-code/python-package-versions.md:303
msgid ""
"Release happens at the command line. This makes is harder to implement a "
"GitHub based release workflow as the wrong commit message could trigger a"
" release."
msgstr ""

#: ../../package-structure-code/python-package-versions.md:304
msgid ""
"The version number is manually updated in a configuration file such as "
"`pyproject.toml` vs. in a package **\\_version.py** file."
msgstr ""

